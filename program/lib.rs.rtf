use anchor_lang::prelude::*;
use anchor_spl::token_interface::{self, Burn, TokenAccount, TokenInterface, TransferChecked, Mint};

declare_id!("3Es13GXc4qwttE6uSgAAfi1zvBD3qzLkZpY21KfT3sZ3");

// ─────────────────────────────────────────────────────────────
//  GHOST Protocol v1.3 — Token-2022 compatible
//  Changes from v1.2:
//    - GhostAccount gains whole_vault_recipient: Option<Pubkey>
//    - New instruction: set_whole_vault_recipient
//    - New instruction: recovery_withdraw (recovery wallet can withdraw vault assets)
//    - GHOST_ACCOUNT_SPACE bumped from 908 to 958 (927 needed + 31 headroom)
// ─────────────────────────────────────────────────────────────

pub const GHOST_SEED: &[u8] = b"ghost";
pub const VAULT_SEED: &[u8] = b"vault";
pub const MIN_STAKE: u64 = 10_000 * 1_000_000;
pub const MIN_INTERVAL: i64 = 7 * 24 * 60 * 60;
pub const MIN_GRACE_PERIOD: i64 = 24 * 60 * 60;
pub const MAX_BENEFICIARIES: usize = 10;
pub const SILENCE_BOUNTY_BPS: u64 = 500;
pub const BURN_ON_ABANDON_BPS: u64 = 5_000;
// v1.2: 8 + 900 = 908. New layout needs 927 min. Using 8 + 950 = 958 for headroom.
pub const GHOST_ACCOUNT_SPACE: usize = 8 + 950;

#[program]
pub mod ghost_protocol {
    use super::*;

    pub fn initialize_ghost(
        ctx: Context<InitializeGhost>,
        interval_seconds: i64,
        grace_period_seconds: i64,
        recovery_wallet: Option<Pubkey>,
        stake_amount: u64,
    ) -> Result<()> {
        require!(stake_amount >= MIN_STAKE, GhostError::InsufficientStake);
        require!(interval_seconds >= MIN_INTERVAL, GhostError::IntervalTooShort);
        require!(grace_period_seconds >= MIN_GRACE_PERIOD, GhostError::GracePeriodTooShort);

        let ghost = &mut ctx.accounts.ghost;
        let clock = Clock::get()?;

        ghost.owner = ctx.accounts.signer.key();
        ghost.recovery_wallet = recovery_wallet;
        ghost.last_heartbeat = clock.unix_timestamp;
        ghost.interval_seconds = interval_seconds;
        ghost.grace_period_seconds = grace_period_seconds;
        ghost.awakened = false;
        ghost.awakened_at = None;
        ghost.executed = false;
        ghost.executed_at = None;
        ghost.staked_ghost = stake_amount;
        ghost.bump = ctx.bumps.ghost;
        ghost.vault_bump = ctx.bumps.vault;
        ghost.registered_at = clock.unix_timestamp;
        ghost.ping_count = 0;
        ghost.beneficiary_count = 0;
        ghost.whole_vault_recipient = None;
        for i in 0..10 {
            ghost.beneficiaries[i] = Beneficiary::default();
        }

        let cpi_ctx = CpiContext::new(
            ctx.accounts.token_program.to_account_info(),
            TransferChecked {
                from: ctx.accounts.signer_token_account.to_account_info(),
                to: ctx.accounts.ghost_stake_vault.to_account_info(),
                authority: ctx.accounts.signer.to_account_info(),
                mint: ctx.accounts.ghost_mint.to_account_info(),
            },
        );
        token_interface::transfer_checked(cpi_ctx, stake_amount, ctx.accounts.ghost_mint.decimals)?;

        emit!(GhostRegistered {
            soul: ghost.owner,
            interval: interval_seconds,
            grace_period: grace_period_seconds,
            recovery_wallet,
            staked: stake_amount,
            timestamp: clock.unix_timestamp,
        });

        msg!("Ghost initialized for {}", ghost.owner);
        Ok(())
    }

    pub fn ping(ctx: Context<Ping>) -> Result<()> {
        let ghost = &mut ctx.accounts.ghost;
        require!(!ghost.executed, GhostError::GhostAlreadyExecuted);

        let clock = Clock::get()?;
        ghost.last_heartbeat = clock.unix_timestamp;
        ghost.ping_count += 1;

        if ghost.awakened {
            ghost.awakened = false;
            ghost.awakened_at = None;
            msg!("Ping received - awakening cancelled");
        } else {
            msg!("Heartbeat #{} recorded", ghost.ping_count);
        }

        emit!(HeartbeatReceived {
            soul: ghost.owner,
            timestamp: clock.unix_timestamp,
            ping_number: ghost.ping_count,
        });

        Ok(())
    }

    pub fn add_beneficiary(
        ctx: Context<ManageBeneficiaries>,
        recipient: Pubkey,
        amount: u64,
        token_mint: Option<Pubkey>,
        action: u8,
    ) -> Result<()> {
        let ghost = &mut ctx.accounts.ghost;
        require!(!ghost.awakened, GhostError::GhostAlreadyAwakened);
        require!(
            (ghost.beneficiary_count as usize) < MAX_BENEFICIARIES,
            GhostError::TooManyBeneficiaries
        );

        let idx = ghost.beneficiary_count as usize;
        ghost.beneficiaries[idx] = Beneficiary { recipient, amount, token_mint, action, executed: false };
        ghost.beneficiary_count += 1;

        emit!(BeneficiaryAdded { soul: ghost.owner, recipient, amount, action });
        msg!("Beneficiary added: {} receives {}", recipient, amount);
        Ok(())
    }

    pub fn remove_beneficiary(ctx: Context<ManageBeneficiaries>, index: u8) -> Result<()> {
        let ghost = &mut ctx.accounts.ghost;
        require!(!ghost.awakened, GhostError::GhostAlreadyAwakened);
        require!((index as usize) < ghost.beneficiary_count as usize, GhostError::InvalidBeneficiary);

        let count = ghost.beneficiary_count as usize;
        for i in (index as usize)..(count - 1) {
            ghost.beneficiaries[i] = ghost.beneficiaries[i + 1];
        }
        ghost.beneficiary_count -= 1;
        msg!("Beneficiary at index {} removed", index);
        Ok(())
    }

    /// Set or clear the whole-vault recipient.
    /// When set, on execution the entire vault is sent to this single address.
    /// This is separate from individual beneficiary slots.
    /// Pass recipient=None to clear.
    pub fn set_whole_vault_recipient(
        ctx: Context<UpdateSettings>,
        recipient: Option<Pubkey>,
    ) -> Result<()> {
        let ghost = &mut ctx.accounts.ghost;
        require!(!ghost.awakened, GhostError::GhostAlreadyAwakened);
        require!(!ghost.executed, GhostError::GhostAlreadyExecuted);

        let previous = ghost.whole_vault_recipient;
        ghost.whole_vault_recipient = recipient;

        emit!(WholeVaultRecipientSet {
            soul: ghost.owner,
            recipient,
            cleared: recipient.is_none(),
            previous,
        });
        msg!("Whole vault recipient updated");
        Ok(())
    }

    pub fn check_silence(ctx: Context<CheckSilence>) -> Result<()> {
        let clock = Clock::get()?;
        let owner = ctx.accounts.ghost.owner;
        let awakened = ctx.accounts.ghost.awakened;
        let executed = ctx.accounts.ghost.executed;
        let last_heartbeat = ctx.accounts.ghost.last_heartbeat;
        let interval_seconds = ctx.accounts.ghost.interval_seconds;
        let grace_period_seconds = ctx.accounts.ghost.grace_period_seconds;
        let staked_ghost = ctx.accounts.ghost.staked_ghost;
        let bump = ctx.accounts.ghost.bump;
        let caller_key = ctx.accounts.caller.key();

        require!(!awakened, GhostError::GhostAlreadyAwakened);
        require!(!executed, GhostError::GhostAlreadyExecuted);

        let silence = clock.unix_timestamp - last_heartbeat;
        require!(silence > interval_seconds, GhostError::SoulStillAlive);

        let bounty = staked_ghost.checked_mul(SILENCE_BOUNTY_BPS).unwrap().checked_div(10_000).unwrap();

        ctx.accounts.ghost.awakened = true;
        ctx.accounts.ghost.awakened_at = Some(clock.unix_timestamp);

        let seeds = &[GHOST_SEED, owner.as_ref(), &[bump]];
        let signer_seeds = &[&seeds[..]];

        let cpi_ctx = CpiContext::new_with_signer(
            ctx.accounts.token_program.to_account_info(),
            TransferChecked {
                from: ctx.accounts.ghost_stake_vault.to_account_info(),
                to: ctx.accounts.caller_token_account.to_account_info(),
                authority: ctx.accounts.ghost.to_account_info(),
                mint: ctx.accounts.ghost_mint.to_account_info(),
            },
            signer_seeds,
        );
        token_interface::transfer_checked(cpi_ctx, bounty, ctx.accounts.ghost_mint.decimals)?;

        emit!(GhostAwakened {
            soul: owner,
            silence_duration: silence,
            awakened_at: clock.unix_timestamp,
            grace_period_ends: clock.unix_timestamp + grace_period_seconds,
            bounty_paid: bounty,
            caller: caller_key,
        });

        msg!("Ghost awakened! Grace period: {}s", grace_period_seconds);
        Ok(())
    }

    pub fn cancel_awakening(ctx: Context<CancelAwakening>) -> Result<()> {
        let ghost = &mut ctx.accounts.ghost;
        require!(ghost.awakened, GhostError::GhostNotAwakened);
        require!(!ghost.executed, GhostError::GhostAlreadyExecuted);

        let clock = Clock::get()?;
        let grace_end = ghost.awakened_at.unwrap() + ghost.grace_period_seconds;
        require!(clock.unix_timestamp <= grace_end, GhostError::GracePeriodExpired);

        let caller = ctx.accounts.signer.key();
        require!(
            caller == ghost.owner || ghost.recovery_wallet.map_or(false, |r| r == caller),
            GhostError::Unauthorized
        );

        ghost.awakened = false;
        ghost.awakened_at = None;
        ghost.last_heartbeat = clock.unix_timestamp;

        emit!(AwakeningCancelled { soul: ghost.owner, cancelled_by: caller, timestamp: clock.unix_timestamp });
        msg!("Awakening cancelled by {}", caller);
        Ok(())
    }

    pub fn execute_legacy(ctx: Context<ExecuteLegacy>) -> Result<()> {
        let ghost = &mut ctx.accounts.ghost;
        require!(ghost.awakened, GhostError::GhostNotAwakened);
        require!(!ghost.executed, GhostError::GhostAlreadyExecuted);

        let clock = Clock::get()?;
        let grace_end = ghost.awakened_at.unwrap() + ghost.grace_period_seconds;
        require!(clock.unix_timestamp > grace_end, GhostError::GracePeriodActive);

        ghost.executed = true;
        ghost.executed_at = Some(clock.unix_timestamp);

        emit!(LegacyExecuted { soul: ghost.owner, executed_at: clock.unix_timestamp, beneficiary_count: ghost.beneficiary_count });
        msg!("Ghost executed. {} beneficiaries to distribute.", ghost.beneficiary_count);
        Ok(())
    }

    pub fn execute_transfer(ctx: Context<ExecuteTransfer>, beneficiary_index: u8) -> Result<()> {
        require!(ctx.accounts.ghost.executed, GhostError::GhostNotExecuted);
        require!((beneficiary_index as usize) < ctx.accounts.ghost.beneficiary_count as usize, GhostError::InvalidBeneficiary);

        let beneficiary = ctx.accounts.ghost.beneficiaries[beneficiary_index as usize];
        require!(!beneficiary.executed, GhostError::BeneficiaryAlreadyPaid);
        require!(beneficiary.recipient == ctx.accounts.recipient.key(), GhostError::WrongRecipient);

        let owner = ctx.accounts.ghost.owner;
        let vault_bump = ctx.accounts.ghost.vault_bump;
        let seeds = &[VAULT_SEED, owner.as_ref(), &[vault_bump]];
        let signer_seeds = &[&seeds[..]];

        let cpi_ctx = CpiContext::new_with_signer(
            ctx.accounts.token_program.to_account_info(),
            TransferChecked {
                from: ctx.accounts.vault_token_account.to_account_info(),
                to: ctx.accounts.recipient_token_account.to_account_info(),
                authority: ctx.accounts.vault.to_account_info(),
                mint: ctx.accounts.ghost_mint.to_account_info(),
            },
            signer_seeds,
        );
        token_interface::transfer_checked(cpi_ctx, beneficiary.amount, ctx.accounts.ghost_mint.decimals)?;

        ctx.accounts.ghost.beneficiaries[beneficiary_index as usize].executed = true;
        emit!(TransferExecuted { soul: owner, recipient: beneficiary.recipient, amount: beneficiary.amount });
        msg!("Transferred {} to {}", beneficiary.amount, beneficiary.recipient);
        Ok(())
    }

    pub fn deposit_to_vault(ctx: Context<DepositToVault>, amount: u64) -> Result<()> {
        let cpi_ctx = CpiContext::new(
            ctx.accounts.token_program.to_account_info(),
            TransferChecked {
                from: ctx.accounts.owner_token_account.to_account_info(),
                to: ctx.accounts.vault_token_account.to_account_info(),
                authority: ctx.accounts.signer.to_account_info(),
                mint: ctx.accounts.ghost_mint.to_account_info(),
            },
        );
        token_interface::transfer_checked(cpi_ctx, amount, ctx.accounts.ghost_mint.decimals)?;
        emit!(VaultDeposit { soul: ctx.accounts.ghost.owner, amount });
        msg!("Deposited {} to vault", amount);
        Ok(())
    }

    pub fn withdraw_from_vault(ctx: Context<WithdrawFromVault>, amount: u64) -> Result<()> {
        require!(!ctx.accounts.ghost.awakened, GhostError::GhostAlreadyAwakened);

        let owner = ctx.accounts.ghost.owner;
        let vault_bump = ctx.accounts.ghost.vault_bump;
        let seeds = &[VAULT_SEED, owner.as_ref(), &[vault_bump]];
        let signer_seeds = &[&seeds[..]];

        let cpi_ctx = CpiContext::new_with_signer(
            ctx.accounts.token_program.to_account_info(),
            TransferChecked {
                from: ctx.accounts.vault_token_account.to_account_info(),
                to: ctx.accounts.owner_token_account.to_account_info(),
                authority: ctx.accounts.vault.to_account_info(),
                mint: ctx.accounts.ghost_mint.to_account_info(),
            },
            signer_seeds,
        );
        token_interface::transfer_checked(cpi_ctx, amount, ctx.accounts.ghost_mint.decimals)?;
        emit!(VaultWithdrawal { soul: owner, amount });
        msg!("Withdrew {} from vault", amount);
        Ok(())
    }

    /// Recovery wallet withdraws a vault asset on behalf of the owner.
    /// Ghost PDA is derived from owner (UncheckedAccount), NOT from signer.
    /// This is what allows the recovery wallet (a different key) to pass seeds validation.
    /// Allowed while ghost is awakened (grace period) — recovery wallet may want to
    /// evacuate assets instead of/before cancelling the awakening.
    /// NOT allowed after execution (assets already distributed).
    pub fn recovery_withdraw(ctx: Context<RecoveryWithdraw>, amount: u64) -> Result<()> {
        let ghost = &ctx.accounts.ghost;

        // Verify signer is the registered recovery wallet
        require!(
            ghost.recovery_wallet.map_or(false, |r| r == ctx.accounts.recovery_wallet.key()),
            GhostError::Unauthorized
        );
        require!(!ghost.executed, GhostError::GhostAlreadyExecuted);

        let owner = ghost.owner;
        let vault_bump = ghost.vault_bump;
        let seeds = &[VAULT_SEED, owner.as_ref(), &[vault_bump]];
        let signer_seeds = &[&seeds[..]];

        let cpi_ctx = CpiContext::new_with_signer(
            ctx.accounts.token_program.to_account_info(),
            TransferChecked {
                from: ctx.accounts.vault_token_account.to_account_info(),
                to: ctx.accounts.recipient_token_account.to_account_info(),
                authority: ctx.accounts.vault.to_account_info(),
                mint: ctx.accounts.ghost_mint.to_account_info(),
            },
            signer_seeds,
        );
        token_interface::transfer_checked(cpi_ctx, amount, ctx.accounts.ghost_mint.decimals)?;

        emit!(RecoveryWithdrawal {
            soul: owner,
            recovery_wallet: ctx.accounts.recovery_wallet.key(),
            amount,
        });
        msg!("Recovery withdrawal: {} tokens moved by guardian", amount);
        Ok(())
    }

    pub fn update_interval(ctx: Context<UpdateSettings>, interval_seconds: i64) -> Result<()> {
        require!(interval_seconds >= MIN_INTERVAL, GhostError::IntervalTooShort);
        ctx.accounts.ghost.interval_seconds = interval_seconds;
        msg!("Interval updated to {}s", interval_seconds);
        Ok(())
    }

    pub fn update_grace_period(ctx: Context<UpdateSettings>, grace_period_seconds: i64) -> Result<()> {
        require!(grace_period_seconds >= MIN_GRACE_PERIOD, GhostError::GracePeriodTooShort);
        ctx.accounts.ghost.grace_period_seconds = grace_period_seconds;
        msg!("Grace period updated to {}s", grace_period_seconds);
        Ok(())
    }

    pub fn update_recovery_wallet(ctx: Context<UpdateSettings>, recovery_wallet: Option<Pubkey>) -> Result<()> {
        ctx.accounts.ghost.recovery_wallet = recovery_wallet;
        msg!("Recovery wallet updated");
        Ok(())
    }

    pub fn abandon_ghost(ctx: Context<AbandonGhost>) -> Result<()> {
        let owner = ctx.accounts.ghost.owner;
        let staked = ctx.accounts.ghost.staked_ghost;
        let bump = ctx.accounts.ghost.bump;

        let burn_amount = staked.checked_mul(BURN_ON_ABANDON_BPS).unwrap().checked_div(10_000).unwrap();
        let return_amount = staked.checked_sub(burn_amount).unwrap();

        let seeds = &[GHOST_SEED, owner.as_ref(), &[bump]];
        let signer_seeds = &[&seeds[..]];

        let burn_ctx = CpiContext::new_with_signer(
            ctx.accounts.token_program.to_account_info(),
            Burn {
                mint: ctx.accounts.ghost_mint.to_account_info(),
                from: ctx.accounts.ghost_stake_vault.to_account_info(),
                authority: ctx.accounts.ghost.to_account_info(),
            },
            signer_seeds,
        );
        token_interface::burn(burn_ctx, burn_amount)?;

        let return_ctx = CpiContext::new_with_signer(
            ctx.accounts.token_program.to_account_info(),
            TransferChecked {
                from: ctx.accounts.ghost_stake_vault.to_account_info(),
                to: ctx.accounts.owner_token_account.to_account_info(),
                authority: ctx.accounts.ghost.to_account_info(),
                mint: ctx.accounts.ghost_mint.to_account_info(),
            },
            signer_seeds,
        );
        token_interface::transfer_checked(return_ctx, return_amount, ctx.accounts.ghost_mint.decimals)?;

        emit!(GhostAbandoned { soul: owner, burned: burn_amount, returned: return_amount });
        msg!("Ghost abandoned. Burned: {}, Returned: {}", burn_amount, return_amount);
        Ok(())
    }
}

// ─── STRUCTS ──────────────────────────────────────────────────

#[derive(AnchorSerialize, AnchorDeserialize, Clone, Copy, PartialEq)]
pub struct Beneficiary {
    pub recipient: Pubkey,          // 32 bytes
    pub amount: u64,                // 8 bytes
    pub token_mint: Option<Pubkey>, // 33 bytes (1 tag + 32)
    pub action: u8,                 // 1 byte
    pub executed: bool,             // 1 byte
    // total: 75 bytes per entry
}

impl Default for Beneficiary {
    fn default() -> Self {
        Self { recipient: Pubkey::default(), amount: 0, token_mint: None, action: 0, executed: false }
    }
}

// GhostAccount field layout (offsets from byte 0 of account data, after discriminator):
//  off  8: owner Pubkey (32)
//  off 40: recovery_wallet Option<Pubkey> (33)
//  off 73: last_heartbeat i64 (8)
//  off 81: interval_seconds i64 (8)
//  off 89: grace_period_seconds i64 (8)
//  off 97: awakened bool (1)
//  off 98: awakened_at Option<i64> (9)
// off 107: executed bool (1)
// off 108: executed_at Option<i64> (9)
// off 117: staked_ghost u64 (8)
// off 125: bump u8 (1)
// off 126: vault_bump u8 (1)
// off 127: registered_at i64 (8)
// off 135: ping_count u64 (8)
// off 143: beneficiary_count u8 (1)
// off 144: beneficiaries [Beneficiary; 10] (750) — ends at 894
// off 894: whole_vault_recipient Option<Pubkey> (33) — ends at 927
// GHOST_ACCOUNT_SPACE = 8 + 950 = 958 (31 bytes headroom)
#[account]
pub struct GhostAccount {
    pub owner: Pubkey,
    pub recovery_wallet: Option<Pubkey>,
    pub last_heartbeat: i64,
    pub interval_seconds: i64,
    pub grace_period_seconds: i64,
    pub awakened: bool,
    pub awakened_at: Option<i64>,
    pub executed: bool,
    pub executed_at: Option<i64>,
    pub staked_ghost: u64,
    pub bump: u8,
    pub vault_bump: u8,
    pub registered_at: i64,
    pub ping_count: u64,
    pub beneficiary_count: u8,
    pub beneficiaries: [Beneficiary; 10],
    // v1.3 — added at offset 894
    pub whole_vault_recipient: Option<Pubkey>,
}

// ─── CONTEXTS ─────────────────────────────────────────────────

#[derive(Accounts)]
pub struct InitializeGhost<'info> {
    #[account(
        init,
        payer = signer,
        space = GHOST_ACCOUNT_SPACE,
        seeds = [GHOST_SEED, signer.key().as_ref()],
        bump,
    )]
    pub ghost: Box<Account<'info, GhostAccount>>,

    /// CHECK: Vault PDA — bump derivation only
    #[account(seeds = [VAULT_SEED, signer.key().as_ref()], bump)]
    pub vault: UncheckedAccount<'info>,

    pub ghost_mint: InterfaceAccount<'info, Mint>,

    #[account(
        init,
        payer = signer,
        seeds = [b"stake_vault", signer.key().as_ref()],
        bump,
        token::mint = ghost_mint,
        token::authority = ghost,
        token::token_program = token_program,
    )]
    pub ghost_stake_vault: InterfaceAccount<'info, TokenAccount>,

    #[account(mut, token::mint = ghost_mint, token::authority = signer, token::token_program = token_program)]
    pub signer_token_account: InterfaceAccount<'info, TokenAccount>,

    #[account(mut)]
    pub signer: Signer<'info>,

    pub token_program: Interface<'info, TokenInterface>,
    pub system_program: Program<'info, System>,
}

#[derive(Accounts)]
pub struct Ping<'info> {
    #[account(mut, seeds = [GHOST_SEED, signer.key().as_ref()], bump = ghost.bump, constraint = ghost.owner == signer.key() @ GhostError::Unauthorized)]
    pub ghost: Account<'info, GhostAccount>,
    #[account(mut)]
    pub signer: Signer<'info>,
}

#[derive(Accounts)]
pub struct ManageBeneficiaries<'info> {
    #[account(mut, seeds = [GHOST_SEED, signer.key().as_ref()], bump = ghost.bump, constraint = ghost.owner == signer.key() @ GhostError::Unauthorized)]
    pub ghost: Account<'info, GhostAccount>,
    #[account(mut)]
    pub signer: Signer<'info>,
}

#[derive(Accounts)]
pub struct CheckSilence<'info> {
    #[account(mut, seeds = [GHOST_SEED, ghost.owner.as_ref()], bump = ghost.bump)]
    pub ghost: Account<'info, GhostAccount>,
    #[account(mut)]
    pub caller: Signer<'info>,
    pub ghost_mint: InterfaceAccount<'info, Mint>,
    #[account(mut, token::mint = ghost_mint, token::token_program = token_program)]
    pub ghost_stake_vault: InterfaceAccount<'info, TokenAccount>,
    #[account(mut, token::mint = ghost_mint, token::token_program = token_program)]
    pub caller_token_account: InterfaceAccount<'info, TokenAccount>,
    pub token_program: Interface<'info, TokenInterface>,
}

#[derive(Accounts)]
pub struct CancelAwakening<'info> {
    #[account(mut, seeds = [GHOST_SEED, ghost.owner.as_ref()], bump = ghost.bump)]
    pub ghost: Account<'info, GhostAccount>,
    #[account(mut)]
    pub signer: Signer<'info>,
}

#[derive(Accounts)]
pub struct ExecuteLegacy<'info> {
    #[account(mut, seeds = [GHOST_SEED, ghost.owner.as_ref()], bump = ghost.bump)]
    pub ghost: Account<'info, GhostAccount>,
    pub caller: Signer<'info>,
}

#[derive(Accounts)]
pub struct ExecuteTransfer<'info> {
    #[account(mut, seeds = [GHOST_SEED, ghost.owner.as_ref()], bump = ghost.bump)]
    pub ghost: Account<'info, GhostAccount>,
    /// CHECK: Vault PDA authority
    #[account(seeds = [VAULT_SEED, ghost.owner.as_ref()], bump = ghost.vault_bump)]
    pub vault: UncheckedAccount<'info>,
    pub ghost_mint: InterfaceAccount<'info, Mint>,
    #[account(mut, token::mint = ghost_mint, token::token_program = token_program)]
    pub vault_token_account: InterfaceAccount<'info, TokenAccount>,
    /// CHECK: validated against beneficiary list inside instruction
    pub recipient: UncheckedAccount<'info>,
    #[account(mut, token::mint = ghost_mint, token::token_program = token_program)]
    pub recipient_token_account: InterfaceAccount<'info, TokenAccount>,
    pub token_program: Interface<'info, TokenInterface>,
    pub caller: Signer<'info>,
}

#[derive(Accounts)]
pub struct DepositToVault<'info> {
    #[account(seeds = [GHOST_SEED, signer.key().as_ref()], bump = ghost.bump, constraint = ghost.owner == signer.key() @ GhostError::Unauthorized)]
    pub ghost: Account<'info, GhostAccount>,
    #[account(mut)]
    pub signer: Signer<'info>,
    pub ghost_mint: InterfaceAccount<'info, Mint>,
    #[account(mut, token::mint = ghost_mint, token::token_program = token_program)]
    pub owner_token_account: InterfaceAccount<'info, TokenAccount>,
    #[account(mut, token::mint = ghost_mint, token::token_program = token_program)]
    pub vault_token_account: InterfaceAccount<'info, TokenAccount>,
    pub token_program: Interface<'info, TokenInterface>,
}

#[derive(Accounts)]
pub struct WithdrawFromVault<'info> {
    // Ghost PDA seeded from signer.key() — signer must be owner
    #[account(seeds = [GHOST_SEED, signer.key().as_ref()], bump = ghost.bump, constraint = ghost.owner == signer.key() @ GhostError::Unauthorized)]
    pub ghost: Account<'info, GhostAccount>,
    /// CHECK: Vault PDA authority
    #[account(seeds = [VAULT_SEED, signer.key().as_ref()], bump = ghost.vault_bump)]
    pub vault: UncheckedAccount<'info>,
    #[account(mut)]
    pub signer: Signer<'info>,
    pub ghost_mint: InterfaceAccount<'info, Mint>,
    #[account(mut, token::mint = ghost_mint, token::token_program = token_program)]
    pub owner_token_account: InterfaceAccount<'info, TokenAccount>,
    #[account(mut, token::mint = ghost_mint, token::token_program = token_program)]
    pub vault_token_account: InterfaceAccount<'info, TokenAccount>,
    pub token_program: Interface<'info, TokenInterface>,
}

/// Recovery wallet withdraws vault assets.
/// Ghost PDA is derived from owner (UncheckedAccount) — signer is recovery_wallet.
/// This is the key structural difference from WithdrawFromVault.
#[derive(Accounts)]
pub struct RecoveryWithdraw<'info> {
    // Ghost derived from owner — NOT from signer
    #[account(mut, seeds = [GHOST_SEED, owner.key().as_ref()], bump = ghost.bump)]
    pub ghost: Account<'info, GhostAccount>,
    /// CHECK: Owner pubkey — used for PDA derivation, not a signer
    pub owner: UncheckedAccount<'info>,
    /// CHECK: Vault PDA — derived from owner
    #[account(seeds = [VAULT_SEED, owner.key().as_ref()], bump = ghost.vault_bump)]
    pub vault: UncheckedAccount<'info>,
    // Recovery wallet is the transaction signer
    #[account(mut)]
    pub recovery_wallet: Signer<'info>,
    pub ghost_mint: InterfaceAccount<'info, Mint>,
    #[account(mut, token::mint = ghost_mint, token::token_program = token_program)]
    pub vault_token_account: InterfaceAccount<'info, TokenAccount>,
    #[account(mut, token::mint = ghost_mint, token::token_program = token_program)]
    pub recipient_token_account: InterfaceAccount<'info, TokenAccount>,
    pub token_program: Interface<'info, TokenInterface>,
}

#[derive(Accounts)]
pub struct UpdateSettings<'info> {
    #[account(mut, seeds = [GHOST_SEED, signer.key().as_ref()], bump = ghost.bump, constraint = ghost.owner == signer.key() @ GhostError::Unauthorized)]
    pub ghost: Account<'info, GhostAccount>,
    #[account(mut)]
    pub signer: Signer<'info>,
}

#[derive(Accounts)]
pub struct AbandonGhost<'info> {
    #[account(mut, seeds = [GHOST_SEED, signer.key().as_ref()], bump = ghost.bump, constraint = ghost.owner == signer.key() @ GhostError::Unauthorized, close = signer)]
    pub ghost: Account<'info, GhostAccount>,
    #[account(mut)]
    pub signer: Signer<'info>,
    pub ghost_mint: InterfaceAccount<'info, Mint>,
    #[account(mut, token::mint = ghost_mint, token::token_program = token_program)]
    pub ghost_stake_vault: InterfaceAccount<'info, TokenAccount>,
    #[account(mut, token::mint = ghost_mint, token::token_program = token_program)]
    pub owner_token_account: InterfaceAccount<'info, TokenAccount>,
    pub token_program: Interface<'info, TokenInterface>,
}

// ─── EVENTS ───────────────────────────────────────────────────

#[event] pub struct GhostRegistered { pub soul: Pubkey, pub interval: i64, pub grace_period: i64, pub recovery_wallet: Option<Pubkey>, pub staked: u64, pub timestamp: i64 }
#[event] pub struct HeartbeatReceived { pub soul: Pubkey, pub timestamp: i64, pub ping_number: u64 }
#[event] pub struct GhostAwakened { pub soul: Pubkey, pub silence_duration: i64, pub awakened_at: i64, pub grace_period_ends: i64, pub bounty_paid: u64, pub caller: Pubkey }
#[event] pub struct AwakeningCancelled { pub soul: Pubkey, pub cancelled_by: Pubkey, pub timestamp: i64 }
#[event] pub struct LegacyExecuted { pub soul: Pubkey, pub executed_at: i64, pub beneficiary_count: u8 }
#[event] pub struct TransferExecuted { pub soul: Pubkey, pub recipient: Pubkey, pub amount: u64 }
#[event] pub struct BeneficiaryAdded { pub soul: Pubkey, pub recipient: Pubkey, pub amount: u64, pub action: u8 }
#[event] pub struct VaultDeposit { pub soul: Pubkey, pub amount: u64 }
#[event] pub struct VaultWithdrawal { pub soul: Pubkey, pub amount: u64 }
#[event] pub struct GhostAbandoned { pub soul: Pubkey, pub burned: u64, pub returned: u64 }
#[event] pub struct WholeVaultRecipientSet { pub soul: Pubkey, pub recipient: Option<Pubkey>, pub cleared: bool, pub previous: Option<Pubkey> }
#[event] pub struct RecoveryWithdrawal { pub soul: Pubkey, pub recovery_wallet: Pubkey, pub amount: u64 }

// ─── ERRORS ───────────────────────────────────────────────────

#[error_code]
pub enum GhostError {
    #[msg("Insufficient $GHOST staked. Minimum 10,000 $GHOST required.")] InsufficientStake,
    #[msg("Heartbeat interval too short. Minimum 7 days.")] IntervalTooShort,
    #[msg("Grace period too short. Minimum 24 hours.")] GracePeriodTooShort,
    #[msg("This ghost has already awakened.")] GhostAlreadyAwakened,
    #[msg("This ghost has not yet awakened.")] GhostNotAwakened,
    #[msg("This ghost has already been executed.")] GhostAlreadyExecuted,
    #[msg("This ghost has not been executed yet.")] GhostNotExecuted,
    #[msg("Soul is still alive. Heartbeat detected within interval.")] SoulStillAlive,
    #[msg("Grace period is still active. Cannot execute yet.")] GracePeriodActive,
    #[msg("Grace period has expired. Cannot cancel.")] GracePeriodExpired,
    #[msg("Unauthorized.")] Unauthorized,
    #[msg("Too many beneficiaries. Maximum 10.")] TooManyBeneficiaries,
    #[msg("Invalid beneficiary index.")] InvalidBeneficiary,
    #[msg("Beneficiary already paid.")] BeneficiaryAlreadyPaid,
    #[msg("Wrong recipient account.")] WrongRecipient,
    #[msg("Arithmetic overflow.")] Overflow,
}