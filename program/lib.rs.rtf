use anchor_lang::prelude::*;
use anchor_spl::token_interface::{self, Burn, TokenAccount, TokenInterface, TransferChecked, Mint};

declare_id!("3Es13GXc4qwttE6uSgAAfi1zvBD3qzLkZpY21KfT3sZ3");

// ─────────────────────────────────────────────────────────────
//  GHOST Protocol v1.4
//  Changes from v1.3:
//    - guardian_remove_beneficiary: recovery wallet removes a single slot
//    - guardian_clear_beneficiaries: recovery wallet clears ALL slots atomically
//    - guardian_set_whole_vault_recipient: recovery wallet sets/clears whole vault recipient
//    - update_beneficiary: owner edits an existing slot in-place (no remove+re-add)
//    - update_interval_and_grace: atomic dual-param update in one tx
//    - transfer_ownership: initiates a 2-step ownership transfer to a new pubkey
//    - accept_ownership: new owner accepts the pending transfer
//    - pause_ghost / resume_ghost: owner temporarily freezes execution
//    - GhostAccount gains: paused (bool), pending_owner (Option<Pubkey>)
//    - GHOST_ACCOUNT_SPACE bumped to 8 + 985 = 993 (headroom for future fields)
//    - New events: BeneficiaryUpdated, BeneficiariesCleared, GhostPaused,
//                  GhostResumed, OwnershipTransferInitiated, OwnershipTransferAccepted
//    - New error codes: GhostPausedError, NoPendingOwnerTransfer, TransferNotAccepted
// ─────────────────────────────────────────────────────────────

pub const GHOST_SEED: &[u8] = b"ghost";
pub const VAULT_SEED: &[u8] = b"vault";
pub const MIN_STAKE: u64 = 10_000 * 1_000_000;
pub const MIN_INTERVAL: i64 = 7 * 24 * 60 * 60;
pub const MIN_GRACE_PERIOD: i64 = 24 * 60 * 60;
pub const MAX_BENEFICIARIES: usize = 10;
pub const SILENCE_BOUNTY_BPS: u64 = 500;
pub const BURN_ON_ABANDON_BPS: u64 = 5_000;
// v1.3: 8 + 950 = 958
// v1.4 adds: paused bool (1) + pending_owner Option<Pubkey> (33) = 34 bytes
// 958 - 8 (discriminator) = 950 data bytes. 950 + 34 = 984. Use 985 + 8 = 993 for headroom.
pub const GHOST_ACCOUNT_SPACE: usize = 8 + 985;

#[program]
pub mod ghost_protocol {
    use super::*;

    // ─────────────────────────────────────────────────────────
    // EXISTING INSTRUCTIONS (unchanged behaviour)
    // ─────────────────────────────────────────────────────────

    pub fn initialize_ghost(
        ctx: Context<InitializeGhost>,
        interval_seconds: i64,
        grace_period_seconds: i64,
        recovery_wallet: Option<Pubkey>,
        stake_amount: u64,
    ) -> Result<()> {
        require!(stake_amount >= MIN_STAKE, GhostError::InsufficientStake);
        require!(interval_seconds >= MIN_INTERVAL, GhostError::IntervalTooShort);
        require!(grace_period_seconds >= MIN_GRACE_PERIOD, GhostError::GracePeriodTooShort);

        let ghost = &mut ctx.accounts.ghost;
        let clock = Clock::get()?;

        ghost.owner = ctx.accounts.signer.key();
        ghost.recovery_wallet = recovery_wallet;
        ghost.last_heartbeat = clock.unix_timestamp;
        ghost.interval_seconds = interval_seconds;
        ghost.grace_period_seconds = grace_period_seconds;
        ghost.awakened = false;
        ghost.awakened_at = None;
        ghost.executed = false;
        ghost.executed_at = None;
        ghost.staked_ghost = stake_amount;
        ghost.bump = ctx.bumps.ghost;
        ghost.vault_bump = ctx.bumps.vault;
        ghost.registered_at = clock.unix_timestamp;
        ghost.ping_count = 0;
        ghost.beneficiary_count = 0;
        ghost.whole_vault_recipient = None;
        ghost.paused = false;
        ghost.pending_owner = None;
        for i in 0..10 {
            ghost.beneficiaries[i] = Beneficiary::default();
        }

        let cpi_ctx = CpiContext::new(
            ctx.accounts.token_program.to_account_info(),
            TransferChecked {
                from: ctx.accounts.signer_token_account.to_account_info(),
                to: ctx.accounts.ghost_stake_vault.to_account_info(),
                authority: ctx.accounts.signer.to_account_info(),
                mint: ctx.accounts.ghost_mint.to_account_info(),
            },
        );
        token_interface::transfer_checked(cpi_ctx, stake_amount, ctx.accounts.ghost_mint.decimals)?;

        emit!(GhostRegistered {
            soul: ghost.owner,
            interval: interval_seconds,
            grace_period: grace_period_seconds,
            recovery_wallet,
            staked: stake_amount,
            timestamp: clock.unix_timestamp,
        });

        msg!("Ghost initialized for {}", ghost.owner);
        Ok(())
    }

    pub fn ping(ctx: Context<Ping>) -> Result<()> {
        let ghost = &mut ctx.accounts.ghost;
        require!(!ghost.executed, GhostError::GhostAlreadyExecuted);

        let clock = Clock::get()?;
        ghost.last_heartbeat = clock.unix_timestamp;
        ghost.ping_count += 1;

        if ghost.awakened {
            ghost.awakened = false;
            ghost.awakened_at = None;
            msg!("Ping received - awakening cancelled");
        } else {
            msg!("Heartbeat #{} recorded", ghost.ping_count);
        }

        emit!(HeartbeatReceived {
            soul: ghost.owner,
            timestamp: clock.unix_timestamp,
            ping_number: ghost.ping_count,
        });

        Ok(())
    }

    pub fn add_beneficiary(
        ctx: Context<ManageBeneficiaries>,
        recipient: Pubkey,
        amount: u64,
        token_mint: Option<Pubkey>,
        action: u8,
    ) -> Result<()> {
        let ghost = &mut ctx.accounts.ghost;
        require!(!ghost.awakened, GhostError::GhostAlreadyAwakened);
        require!(!ghost.paused, GhostError::GhostPausedError);
        require!(
            (ghost.beneficiary_count as usize) < MAX_BENEFICIARIES,
            GhostError::TooManyBeneficiaries
        );

        let idx = ghost.beneficiary_count as usize;
        ghost.beneficiaries[idx] = Beneficiary { recipient, amount, token_mint, action, executed: false };
        ghost.beneficiary_count += 1;

        emit!(BeneficiaryAdded { soul: ghost.owner, recipient, amount, action });
        msg!("Beneficiary added: {} receives {}", recipient, amount);
        Ok(())
    }

    pub fn remove_beneficiary(ctx: Context<ManageBeneficiaries>, index: u8) -> Result<()> {
        let ghost = &mut ctx.accounts.ghost;
        require!(!ghost.awakened, GhostError::GhostAlreadyAwakened);
        require!((index as usize) < ghost.beneficiary_count as usize, GhostError::InvalidBeneficiary);

        let count = ghost.beneficiary_count as usize;
        for i in (index as usize)..(count - 1) {
            ghost.beneficiaries[i] = ghost.beneficiaries[i + 1];
        }
        ghost.beneficiary_count -= 1;
        msg!("Beneficiary at index {} removed", index);
        Ok(())
    }

    // ─────────────────────────────────────────────────────────
    // v1.4 NEW: update_beneficiary
    // Owner edits an existing beneficiary slot in-place.
    // Avoids the remove-then-re-add two-transaction pattern.
    // ─────────────────────────────────────────────────────────
    pub fn update_beneficiary(
        ctx: Context<ManageBeneficiaries>,
        index: u8,
        recipient: Pubkey,
        amount: u64,
        token_mint: Option<Pubkey>,
        action: u8,
    ) -> Result<()> {
        let ghost = &mut ctx.accounts.ghost;
        require!(!ghost.awakened, GhostError::GhostAlreadyAwakened);
        require!(!ghost.paused, GhostError::GhostPausedError);
        require!((index as usize) < ghost.beneficiary_count as usize, GhostError::InvalidBeneficiary);

        let slot = &mut ghost.beneficiaries[index as usize];
        let old_recipient = slot.recipient;
        let old_amount = slot.amount;
        slot.recipient = recipient;
        slot.amount = amount;
        slot.token_mint = token_mint;
        slot.action = action;
        slot.executed = false; // reset executed flag on edit

        emit!(BeneficiaryUpdated {
            soul: ghost.owner,
            index,
            old_recipient,
            new_recipient: recipient,
            old_amount,
            new_amount: amount,
            action,
        });
        msg!("Beneficiary at index {} updated", index);
        Ok(())
    }

    // ─────────────────────────────────────────────────────────
    // v1.4 NEW: guardian_remove_beneficiary
    // Recovery wallet removes a single beneficiary slot.
    // Ghost PDA derived from owner (UncheckedAccount) — signer is recovery_wallet.
    // Mirrors the pattern used by recovery_withdraw / RecoveryWithdraw context.
    // Allowed even while awakened — guardian may need to clean up before withdrawing.
    // NOT allowed after execution.
    // ─────────────────────────────────────────────────────────
    pub fn guardian_remove_beneficiary(
        ctx: Context<GuardianManageBeneficiaries>,
        index: u8,
    ) -> Result<()> {
        let ghost = &mut ctx.accounts.ghost;

        require!(
            ghost.recovery_wallet.map_or(false, |r| r == ctx.accounts.recovery_wallet.key()),
            GhostError::Unauthorized
        );
        require!(!ghost.executed, GhostError::GhostAlreadyExecuted);
        require!((index as usize) < ghost.beneficiary_count as usize, GhostError::InvalidBeneficiary);

        let count = ghost.beneficiary_count as usize;
        for i in (index as usize)..(count - 1) {
            ghost.beneficiaries[i] = ghost.beneficiaries[i + 1];
        }
        ghost.beneficiary_count -= 1;

        msg!("Guardian removed beneficiary at index {}", index);
        Ok(())
    }

    // ─────────────────────────────────────────────────────────
    // v1.4 NEW: guardian_clear_beneficiaries
    // Recovery wallet clears ALL beneficiary slots atomically in a single instruction.
    // Much more efficient than N separate remove_beneficiary calls.
    // Also clears beneficiary_count to 0.
    // ─────────────────────────────────────────────────────────
    pub fn guardian_clear_beneficiaries(
        ctx: Context<GuardianManageBeneficiaries>,
    ) -> Result<()> {
        let ghost = &mut ctx.accounts.ghost;

        require!(
            ghost.recovery_wallet.map_or(false, |r| r == ctx.accounts.recovery_wallet.key()),
            GhostError::Unauthorized
        );
        require!(!ghost.executed, GhostError::GhostAlreadyExecuted);

        let cleared_count = ghost.beneficiary_count;
        for i in 0..MAX_BENEFICIARIES {
            ghost.beneficiaries[i] = Beneficiary::default();
        }
        ghost.beneficiary_count = 0;

        emit!(BeneficiariesCleared {
            soul: ghost.owner,
            cleared_by: ctx.accounts.recovery_wallet.key(),
            count: cleared_count,
        });
        msg!("Guardian cleared {} beneficiaries", cleared_count);
        Ok(())
    }

    // ─────────────────────────────────────────────────────────
    // v1.4 NEW: guardian_set_whole_vault_recipient
    // Recovery wallet sets or clears the whole_vault_recipient.
    // Useful when guardian wants to redirect the vault before/after execution.
    // ─────────────────────────────────────────────────────────
    pub fn guardian_set_whole_vault_recipient(
        ctx: Context<GuardianManageBeneficiaries>,
        recipient: Option<Pubkey>,
    ) -> Result<()> {
        let ghost = &mut ctx.accounts.ghost;

        require!(
            ghost.recovery_wallet.map_or(false, |r| r == ctx.accounts.recovery_wallet.key()),
            GhostError::Unauthorized
        );
        require!(!ghost.executed, GhostError::GhostAlreadyExecuted);

        let previous = ghost.whole_vault_recipient;
        ghost.whole_vault_recipient = recipient;

        emit!(WholeVaultRecipientSet {
            soul: ghost.owner,
            recipient,
            cleared: recipient.is_none(),
            previous,
        });
        msg!("Guardian updated whole vault recipient");
        Ok(())
    }

    pub fn set_whole_vault_recipient(
        ctx: Context<UpdateSettings>,
        recipient: Option<Pubkey>,
    ) -> Result<()> {
        let ghost = &mut ctx.accounts.ghost;
        require!(!ghost.awakened, GhostError::GhostAlreadyAwakened);
        require!(!ghost.executed, GhostError::GhostAlreadyExecuted);

        let previous = ghost.whole_vault_recipient;
        ghost.whole_vault_recipient = recipient;

        emit!(WholeVaultRecipientSet {
            soul: ghost.owner,
            recipient,
            cleared: recipient.is_none(),
            previous,
        });
        msg!("Whole vault recipient updated");
        Ok(())
    }

    // ─────────────────────────────────────────────────────────
    // v1.4 NEW: pause_ghost / resume_ghost
    // Owner can temporarily freeze add/update beneficiary operations.
    // Useful while reviewing allocations or during a security incident.
    // Execution path (check_silence → execute_legacy) is NOT blocked by pause —
    // the dead man's switch must always be able to fire.
    // ─────────────────────────────────────────────────────────
    pub fn pause_ghost(ctx: Context<UpdateSettings>) -> Result<()> {
        let ghost = &mut ctx.accounts.ghost;
        require!(!ghost.paused, GhostError::GhostPausedError);
        require!(!ghost.executed, GhostError::GhostAlreadyExecuted);

        ghost.paused = true;
        let clock = Clock::get()?;
        emit!(GhostPaused { soul: ghost.owner, timestamp: clock.unix_timestamp });
        msg!("Ghost paused by owner");
        Ok(())
    }

    pub fn resume_ghost(ctx: Context<UpdateSettings>) -> Result<()> {
        let ghost = &mut ctx.accounts.ghost;
        require!(ghost.paused, GhostError::GhostNotPaused);

        ghost.paused = false;
        let clock = Clock::get()?;
        emit!(GhostResumed { soul: ghost.owner, timestamp: clock.unix_timestamp });
        msg!("Ghost resumed by owner");
        Ok(())
    }

    // ─────────────────────────────────────────────────────────
    // v1.4 NEW: transfer_ownership (step 1 of 2)
    // Owner nominates a new owner pubkey. The new owner must call accept_ownership
    // to complete the transfer. This prevents accidental transfers to wrong addresses.
    // The ghost PDA seeds change on accept — both old and new PDAs are needed.
    //
    // NOTE: Because ghost PDA is seeds = [b"ghost", owner.key()], the PDA address
    // changes when ownership transfers. We store pending_owner here; the full
    // migration (closing old PDA, initialising new PDA) happens client-side.
    // For v1.4 we implement a lightweight "authorised operator" pattern instead:
    // pending_owner can act as the owner for settings/beneficiaries but the PDA
    // itself is not re-seeded until the owner calls finalize_ownership_transfer
    // which closes the old account and re-inits (requires client coordination).
    // ─────────────────────────────────────────────────────────
    pub fn transfer_ownership(
        ctx: Context<UpdateSettings>,
        new_owner: Pubkey,
    ) -> Result<()> {
        let ghost = &mut ctx.accounts.ghost;
        require!(!ghost.executed, GhostError::GhostAlreadyExecuted);
        require!(new_owner != ghost.owner, GhostError::Unauthorized); // no-op transfer

        ghost.pending_owner = Some(new_owner);

        let clock = Clock::get()?;
        emit!(OwnershipTransferInitiated {
            soul: ghost.owner,
            pending_owner: new_owner,
            timestamp: clock.unix_timestamp,
        });
        msg!("Ownership transfer initiated to {}", new_owner);
        Ok(())
    }

    // ─────────────────────────────────────────────────────────
    // v1.4 NEW: accept_ownership (step 2 of 2)
    // The pending owner signs to accept. The owner field is updated.
    // The ghost PDA still has the old seeds — the account address stays the same.
    // After accept, the new owner must use AcceptOwnership context (seeded from old owner)
    // and then re-derive PDAs client-side. The old owner loses all privileges.
    // ─────────────────────────────────────────────────────────
    pub fn accept_ownership(ctx: Context<AcceptOwnership>) -> Result<()> {
        let ghost = &mut ctx.accounts.ghost;

        // Verify the signer is the pending owner
        require!(
            ghost.pending_owner.map_or(false, |p| p == ctx.accounts.new_owner.key()),
            GhostError::NoPendingOwnerTransfer
        );

        let old_owner = ghost.owner;
        ghost.owner = ctx.accounts.new_owner.key();
        ghost.pending_owner = None;

        let clock = Clock::get()?;
        emit!(OwnershipTransferAccepted {
            old_owner,
            new_owner: ghost.owner,
            timestamp: clock.unix_timestamp,
        });
        msg!("Ownership transferred from {} to {}", old_owner, ghost.owner);
        Ok(())
    }

    // ─────────────────────────────────────────────────────────
    // v1.4 NEW: update_interval_and_grace
    // Atomic update of both timing parameters in a single transaction.
    // Saves one tx fee vs calling update_interval + update_grace_period separately.
    // ─────────────────────────────────────────────────────────
    pub fn update_interval_and_grace(
        ctx: Context<UpdateSettings>,
        interval_seconds: i64,
        grace_period_seconds: i64,
    ) -> Result<()> {
        require!(interval_seconds >= MIN_INTERVAL, GhostError::IntervalTooShort);
        require!(grace_period_seconds >= MIN_GRACE_PERIOD, GhostError::GracePeriodTooShort);
        ctx.accounts.ghost.interval_seconds = interval_seconds;
        ctx.accounts.ghost.grace_period_seconds = grace_period_seconds;
        msg!("Interval set to {}s, grace period set to {}s", interval_seconds, grace_period_seconds);
        Ok(())
    }

    // ─────────────────────────────────────────────────────────
    // EXISTING INSTRUCTIONS (minor guard additions only)
    // ─────────────────────────────────────────────────────────

    pub fn check_silence(ctx: Context<CheckSilence>) -> Result<()> {
        let clock = Clock::get()?;
        let owner = ctx.accounts.ghost.owner;
        let awakened = ctx.accounts.ghost.awakened;
        let executed = ctx.accounts.ghost.executed;
        let last_heartbeat = ctx.accounts.ghost.last_heartbeat;
        let interval_seconds = ctx.accounts.ghost.interval_seconds;
        let grace_period_seconds = ctx.accounts.ghost.grace_period_seconds;
        let staked_ghost = ctx.accounts.ghost.staked_ghost;
        let bump = ctx.accounts.ghost.bump;
        let caller_key = ctx.accounts.caller.key();

        require!(!awakened, GhostError::GhostAlreadyAwakened);
        require!(!executed, GhostError::GhostAlreadyExecuted);
        // Paused ghost cannot be awakened — owner has signalled intent to freeze
        require!(!ctx.accounts.ghost.paused, GhostError::GhostPausedError);

        let silence = clock.unix_timestamp - last_heartbeat;
        require!(silence > interval_seconds, GhostError::SoulStillAlive);

        let bounty = staked_ghost.checked_mul(SILENCE_BOUNTY_BPS).unwrap().checked_div(10_000).unwrap();

        ctx.accounts.ghost.awakened = true;
        ctx.accounts.ghost.awakened_at = Some(clock.unix_timestamp);

        let seeds = &[GHOST_SEED, owner.as_ref(), &[bump]];
        let signer_seeds = &[&seeds[..]];

        let cpi_ctx = CpiContext::new_with_signer(
            ctx.accounts.token_program.to_account_info(),
            TransferChecked {
                from: ctx.accounts.ghost_stake_vault.to_account_info(),
                to: ctx.accounts.caller_token_account.to_account_info(),
                authority: ctx.accounts.ghost.to_account_info(),
                mint: ctx.accounts.ghost_mint.to_account_info(),
            },
            signer_seeds,
        );
        token_interface::transfer_checked(cpi_ctx, bounty, ctx.accounts.ghost_mint.decimals)?;

        emit!(GhostAwakened {
            soul: owner,
            silence_duration: silence,
            awakened_at: clock.unix_timestamp,
            grace_period_ends: clock.unix_timestamp + grace_period_seconds,
            bounty_paid: bounty,
            caller: caller_key,
        });

        msg!("Ghost awakened! Grace period: {}s", grace_period_seconds);
        Ok(())
    }

    pub fn cancel_awakening(ctx: Context<CancelAwakening>) -> Result<()> {
        let ghost = &mut ctx.accounts.ghost;
        require!(ghost.awakened, GhostError::GhostNotAwakened);
        require!(!ghost.executed, GhostError::GhostAlreadyExecuted);

        let clock = Clock::get()?;
        let grace_end = ghost.awakened_at.unwrap() + ghost.grace_period_seconds;
        require!(clock.unix_timestamp <= grace_end, GhostError::GracePeriodExpired);

        let caller = ctx.accounts.signer.key();
        require!(
            caller == ghost.owner || ghost.recovery_wallet.map_or(false, |r| r == caller),
            GhostError::Unauthorized
        );

        ghost.awakened = false;
        ghost.awakened_at = None;
        ghost.last_heartbeat = clock.unix_timestamp;

        emit!(AwakeningCancelled { soul: ghost.owner, cancelled_by: caller, timestamp: clock.unix_timestamp });
        msg!("Awakening cancelled by {}", caller);
        Ok(())
    }

    pub fn execute_legacy(ctx: Context<ExecuteLegacy>) -> Result<()> {
        let ghost = &mut ctx.accounts.ghost;
        require!(ghost.awakened, GhostError::GhostNotAwakened);
        require!(!ghost.executed, GhostError::GhostAlreadyExecuted);

        let clock = Clock::get()?;
        let grace_end = ghost.awakened_at.unwrap() + ghost.grace_period_seconds;
        require!(clock.unix_timestamp > grace_end, GhostError::GracePeriodActive);

        ghost.executed = true;
        ghost.executed_at = Some(clock.unix_timestamp);

        emit!(LegacyExecuted { soul: ghost.owner, executed_at: clock.unix_timestamp, beneficiary_count: ghost.beneficiary_count });
        msg!("Ghost executed. {} beneficiaries to distribute.", ghost.beneficiary_count);
        Ok(())
    }

    pub fn execute_transfer(ctx: Context<ExecuteTransfer>, beneficiary_index: u8) -> Result<()> {
        require!(ctx.accounts.ghost.executed, GhostError::GhostNotExecuted);
        require!((beneficiary_index as usize) < ctx.accounts.ghost.beneficiary_count as usize, GhostError::InvalidBeneficiary);

        let beneficiary = ctx.accounts.ghost.beneficiaries[beneficiary_index as usize];
        require!(!beneficiary.executed, GhostError::BeneficiaryAlreadyPaid);
        require!(beneficiary.recipient == ctx.accounts.recipient.key(), GhostError::WrongRecipient);

        let owner = ctx.accounts.ghost.owner;
        let vault_bump = ctx.accounts.ghost.vault_bump;
        let seeds = &[VAULT_SEED, owner.as_ref(), &[vault_bump]];
        let signer_seeds = &[&seeds[..]];

        let cpi_ctx = CpiContext::new_with_signer(
            ctx.accounts.token_program.to_account_info(),
            TransferChecked {
                from: ctx.accounts.vault_token_account.to_account_info(),
                to: ctx.accounts.recipient_token_account.to_account_info(),
                authority: ctx.accounts.vault.to_account_info(),
                mint: ctx.accounts.ghost_mint.to_account_info(),
            },
            signer_seeds,
        );
        token_interface::transfer_checked(cpi_ctx, beneficiary.amount, ctx.accounts.ghost_mint.decimals)?;

        ctx.accounts.ghost.beneficiaries[beneficiary_index as usize].executed = true;
        emit!(TransferExecuted { soul: owner, recipient: beneficiary.recipient, amount: beneficiary.amount });
        msg!("Transferred {} to {}", beneficiary.amount, beneficiary.recipient);
        Ok(())
    }

    pub fn deposit_to_vault(ctx: Context<DepositToVault>, amount: u64) -> Result<()> {
        let cpi_ctx = CpiContext::new(
            ctx.accounts.token_program.to_account_info(),
            TransferChecked {
                from: ctx.accounts.owner_token_account.to_account_info(),
                to: ctx.accounts.vault_token_account.to_account_info(),
                authority: ctx.accounts.signer.to_account_info(),
                mint: ctx.accounts.ghost_mint.to_account_info(),
            },
        );
        token_interface::transfer_checked(cpi_ctx, amount, ctx.accounts.ghost_mint.decimals)?;
        emit!(VaultDeposit { soul: ctx.accounts.ghost.owner, amount });
        msg!("Deposited {} to vault", amount);
        Ok(())
    }

    pub fn withdraw_from_vault(ctx: Context<WithdrawFromVault>, amount: u64) -> Result<()> {
        require!(!ctx.accounts.ghost.awakened, GhostError::GhostAlreadyAwakened);

        let owner = ctx.accounts.ghost.owner;
        let vault_bump = ctx.accounts.ghost.vault_bump;
        let seeds = &[VAULT_SEED, owner.as_ref(), &[vault_bump]];
        let signer_seeds = &[&seeds[..]];

        let cpi_ctx = CpiContext::new_with_signer(
            ctx.accounts.token_program.to_account_info(),
            TransferChecked {
                from: ctx.accounts.vault_token_account.to_account_info(),
                to: ctx.accounts.owner_token_account.to_account_info(),
                authority: ctx.accounts.vault.to_account_info(),
                mint: ctx.accounts.ghost_mint.to_account_info(),
            },
            signer_seeds,
        );
        token_interface::transfer_checked(cpi_ctx, amount, ctx.accounts.ghost_mint.decimals)?;
        emit!(VaultWithdrawal { soul: owner, amount });
        msg!("Withdrew {} from vault", amount);
        Ok(())
    }

    pub fn recovery_withdraw(ctx: Context<RecoveryWithdraw>, amount: u64) -> Result<()> {
        let ghost = &ctx.accounts.ghost;

        require!(
            ghost.recovery_wallet.map_or(false, |r| r == ctx.accounts.recovery_wallet.key()),
            GhostError::Unauthorized
        );
        require!(!ghost.executed, GhostError::GhostAlreadyExecuted);

        let owner = ghost.owner;
        let vault_bump = ghost.vault_bump;
        let seeds = &[VAULT_SEED, owner.as_ref(), &[vault_bump]];
        let signer_seeds = &[&seeds[..]];

        let cpi_ctx = CpiContext::new_with_signer(
            ctx.accounts.token_program.to_account_info(),
            TransferChecked {
                from: ctx.accounts.vault_token_account.to_account_info(),
                to: ctx.accounts.recipient_token_account.to_account_info(),
                authority: ctx.accounts.vault.to_account_info(),
                mint: ctx.accounts.ghost_mint.to_account_info(),
            },
            signer_seeds,
        );
        token_interface::transfer_checked(cpi_ctx, amount, ctx.accounts.ghost_mint.decimals)?;

        emit!(RecoveryWithdrawal {
            soul: owner,
            recovery_wallet: ctx.accounts.recovery_wallet.key(),
            amount,
        });
        msg!("Recovery withdrawal: {} tokens moved by guardian", amount);
        Ok(())
    }

    pub fn update_interval(ctx: Context<UpdateSettings>, interval_seconds: i64) -> Result<()> {
        require!(interval_seconds >= MIN_INTERVAL, GhostError::IntervalTooShort);
        ctx.accounts.ghost.interval_seconds = interval_seconds;
        msg!("Interval updated to {}s", interval_seconds);
        Ok(())
    }

    pub fn update_grace_period(ctx: Context<UpdateSettings>, grace_period_seconds: i64) -> Result<()> {
        require!(grace_period_seconds >= MIN_GRACE_PERIOD, GhostError::GracePeriodTooShort);
        ctx.accounts.ghost.grace_period_seconds = grace_period_seconds;
        msg!("Grace period updated to {}s", grace_period_seconds);
        Ok(())
    }

    pub fn update_recovery_wallet(ctx: Context<UpdateSettings>, recovery_wallet: Option<Pubkey>) -> Result<()> {
        ctx.accounts.ghost.recovery_wallet = recovery_wallet;
        msg!("Recovery wallet updated");
        Ok(())
    }

    pub fn abandon_ghost(ctx: Context<AbandonGhost>) -> Result<()> {
        let owner = ctx.accounts.ghost.owner;
        let staked = ctx.accounts.ghost.staked_ghost;
        let bump = ctx.accounts.ghost.bump;

        let burn_amount = staked.checked_mul(BURN_ON_ABANDON_BPS).unwrap().checked_div(10_000).unwrap();
        let return_amount = staked.checked_sub(burn_amount).unwrap();

        let seeds = &[GHOST_SEED, owner.as_ref(), &[bump]];
        let signer_seeds = &[&seeds[..]];

        let burn_ctx = CpiContext::new_with_signer(
            ctx.accounts.token_program.to_account_info(),
            Burn {
                mint: ctx.accounts.ghost_mint.to_account_info(),
                from: ctx.accounts.ghost_stake_vault.to_account_info(),
                authority: ctx.accounts.ghost.to_account_info(),
            },
            signer_seeds,
        );
        token_interface::burn(burn_ctx, burn_amount)?;

        let return_ctx = CpiContext::new_with_signer(
            ctx.accounts.token_program.to_account_info(),
            TransferChecked {
                from: ctx.accounts.ghost_stake_vault.to_account_info(),
                to: ctx.accounts.owner_token_account.to_account_info(),
                authority: ctx.accounts.ghost.to_account_info(),
                mint: ctx.accounts.ghost_mint.to_account_info(),
            },
            signer_seeds,
        );
        token_interface::transfer_checked(return_ctx, return_amount, ctx.accounts.ghost_mint.decimals)?;

        emit!(GhostAbandoned { soul: owner, burned: burn_amount, returned: return_amount });
        msg!("Ghost abandoned. Burned: {}, Returned: {}", burn_amount, return_amount);
        Ok(())
    }
}

// ─── STRUCTS ──────────────────────────────────────────────────

#[derive(AnchorSerialize, AnchorDeserialize, Clone, Copy, PartialEq)]
pub struct Beneficiary {
    pub recipient: Pubkey,          // 32 bytes
    pub amount: u64,                // 8 bytes
    pub token_mint: Option<Pubkey>, // 33 bytes (1 tag + 32)
    pub action: u8,                 // 1 byte
    pub executed: bool,             // 1 byte
    // total: 75 bytes per entry
}

impl Default for Beneficiary {
    fn default() -> Self {
        Self { recipient: Pubkey::default(), amount: 0, token_mint: None, action: 0, executed: false }
    }
}

// GhostAccount field layout (offsets after 8-byte discriminator):
//  off   8: owner Pubkey (32)
//  off  40: recovery_wallet Option<Pubkey> (33)
//  off  73: last_heartbeat i64 (8)
//  off  81: interval_seconds i64 (8)
//  off  89: grace_period_seconds i64 (8)
//  off  97: awakened bool (1)
//  off  98: awakened_at Option<i64> (9)
// off 107: executed bool (1)
// off 108: executed_at Option<i64> (9)
// off 117: staked_ghost u64 (8)
// off 125: bump u8 (1)
// off 126: vault_bump u8 (1)
// off 127: registered_at i64 (8)
// off 135: ping_count u64 (8)
// off 143: beneficiary_count u8 (1)
// off 144: beneficiaries [Beneficiary; 10] (750) — ends at 894
// off 894: whole_vault_recipient Option<Pubkey> (33) — ends at 927
// v1.4 additions:
// off 927: paused bool (1) — ends at 928
// off 928: pending_owner Option<Pubkey> (33) — ends at 961
// GHOST_ACCOUNT_SPACE = 8 + 985 = 993 (24 bytes headroom)
#[account]
pub struct GhostAccount {
    pub owner: Pubkey,
    pub recovery_wallet: Option<Pubkey>,
    pub last_heartbeat: i64,
    pub interval_seconds: i64,
    pub grace_period_seconds: i64,
    pub awakened: bool,
    pub awakened_at: Option<i64>,
    pub executed: bool,
    pub executed_at: Option<i64>,
    pub staked_ghost: u64,
    pub bump: u8,
    pub vault_bump: u8,
    pub registered_at: i64,
    pub ping_count: u64,
    pub beneficiary_count: u8,
    pub beneficiaries: [Beneficiary; 10],
    // v1.3
    pub whole_vault_recipient: Option<Pubkey>,
    // v1.4
    pub paused: bool,
    pub pending_owner: Option<Pubkey>,
}

// ─── CONTEXTS ─────────────────────────────────────────────────

#[derive(Accounts)]
pub struct InitializeGhost<'info> {
    #[account(
        init,
        payer = signer,
        space = GHOST_ACCOUNT_SPACE,
        seeds = [GHOST_SEED, signer.key().as_ref()],
        bump,
    )]
    pub ghost: Box<Account<'info, GhostAccount>>,

    /// CHECK: Vault PDA — bump derivation only
    #[account(seeds = [VAULT_SEED, signer.key().as_ref()], bump)]
    pub vault: UncheckedAccount<'info>,

    pub ghost_mint: InterfaceAccount<'info, Mint>,

    #[account(
        init,
        payer = signer,
        seeds = [b"stake_vault", signer.key().as_ref()],
        bump,
        token::mint = ghost_mint,
        token::authority = ghost,
        token::token_program = token_program,
    )]
    pub ghost_stake_vault: InterfaceAccount<'info, TokenAccount>,

    #[account(mut, token::mint = ghost_mint, token::authority = signer, token::token_program = token_program)]
    pub signer_token_account: InterfaceAccount<'info, TokenAccount>,

    #[account(mut)]
    pub signer: Signer<'info>,

    pub token_program: Interface<'info, TokenInterface>,
    pub system_program: Program<'info, System>,
}

#[derive(Accounts)]
pub struct Ping<'info> {
    #[account(mut, seeds = [GHOST_SEED, signer.key().as_ref()], bump = ghost.bump, constraint = ghost.owner == signer.key() @ GhostError::Unauthorized)]
    pub ghost: Account<'info, GhostAccount>,
    #[account(mut)]
    pub signer: Signer<'info>,
}

#[derive(Accounts)]
pub struct ManageBeneficiaries<'info> {
    #[account(mut, seeds = [GHOST_SEED, signer.key().as_ref()], bump = ghost.bump, constraint = ghost.owner == signer.key() @ GhostError::Unauthorized)]
    pub ghost: Account<'info, GhostAccount>,
    #[account(mut)]
    pub signer: Signer<'info>,
}

// ─────────────────────────────────────────────────────────────
// v1.4 NEW: GuardianManageBeneficiaries context
// Ghost PDA derived from owner (UncheckedAccount) — signer is recovery_wallet.
// Identical structural pattern to RecoveryWithdraw.
// Handles: guardian_remove_beneficiary, guardian_clear_beneficiaries,
//          guardian_set_whole_vault_recipient
// ─────────────────────────────────────────────────────────────
#[derive(Accounts)]
pub struct GuardianManageBeneficiaries<'info> {
    // Ghost derived from owner — NOT from recovery_wallet signer
    #[account(mut, seeds = [GHOST_SEED, owner.key().as_ref()], bump = ghost.bump)]
    pub ghost: Account<'info, GhostAccount>,
    /// CHECK: Owner pubkey — used for PDA derivation only, not a signer
    pub owner: UncheckedAccount<'info>,
    // Recovery wallet is the transaction signer
    #[account(mut)]
    pub recovery_wallet: Signer<'info>,
}

// ─────────────────────────────────────────────────────────────
// v1.4 NEW: AcceptOwnership context
// Ghost PDA still uses the OLD owner for seeds (account address unchanged).
// new_owner signs to accept the pending transfer.
// ─────────────────────────────────────────────────────────────
#[derive(Accounts)]
pub struct AcceptOwnership<'info> {
    // Ghost seeded from the CURRENT (old) owner — address doesn't change
    #[account(mut, seeds = [GHOST_SEED, ghost.owner.as_ref()], bump = ghost.bump)]
    pub ghost: Account<'info, GhostAccount>,
    // Pending new owner must sign
    #[account(mut)]
    pub new_owner: Signer<'info>,
}

#[derive(Accounts)]
pub struct CheckSilence<'info> {
    #[account(mut, seeds = [GHOST_SEED, ghost.owner.as_ref()], bump = ghost.bump)]
    pub ghost: Account<'info, GhostAccount>,
    #[account(mut)]
    pub caller: Signer<'info>,
    pub ghost_mint: InterfaceAccount<'info, Mint>,
    #[account(mut, token::mint = ghost_mint, token::token_program = token_program)]
    pub ghost_stake_vault: InterfaceAccount<'info, TokenAccount>,
    #[account(mut, token::mint = ghost_mint, token::token_program = token_program)]
    pub caller_token_account: InterfaceAccount<'info, TokenAccount>,
    pub token_program: Interface<'info, TokenInterface>,
}

#[derive(Accounts)]
pub struct CancelAwakening<'info> {
    #[account(mut, seeds = [GHOST_SEED, ghost.owner.as_ref()], bump = ghost.bump)]
    pub ghost: Account<'info, GhostAccount>,
    #[account(mut)]
    pub signer: Signer<'info>,
}

#[derive(Accounts)]
pub struct ExecuteLegacy<'info> {
    #[account(mut, seeds = [GHOST_SEED, ghost.owner.as_ref()], bump = ghost.bump)]
    pub ghost: Account<'info, GhostAccount>,
    pub caller: Signer<'info>,
}

#[derive(Accounts)]
pub struct ExecuteTransfer<'info> {
    #[account(mut, seeds = [GHOST_SEED, ghost.owner.as_ref()], bump = ghost.bump)]
    pub ghost: Account<'info, GhostAccount>,
    /// CHECK: Vault PDA authority
    #[account(seeds = [VAULT_SEED, ghost.owner.as_ref()], bump = ghost.vault_bump)]
    pub vault: UncheckedAccount<'info>,
    pub ghost_mint: InterfaceAccount<'info, Mint>,
    #[account(mut, token::mint = ghost_mint, token::token_program = token_program)]
    pub vault_token_account: InterfaceAccount<'info, TokenAccount>,
    /// CHECK: validated against beneficiary list inside instruction
    pub recipient: UncheckedAccount<'info>,
    #[account(mut, token::mint = ghost_mint, token::token_program = token_program)]
    pub recipient_token_account: InterfaceAccount<'info, TokenAccount>,
    pub token_program: Interface<'info, TokenInterface>,
    pub caller: Signer<'info>,
}

#[derive(Accounts)]
pub struct DepositToVault<'info> {
    #[account(seeds = [GHOST_SEED, signer.key().as_ref()], bump = ghost.bump, constraint = ghost.owner == signer.key() @ GhostError::Unauthorized)]
    pub ghost: Account<'info, GhostAccount>,
    #[account(mut)]
    pub signer: Signer<'info>,
    pub ghost_mint: InterfaceAccount<'info, Mint>,
    #[account(mut, token::mint = ghost_mint, token::token_program = token_program)]
    pub owner_token_account: InterfaceAccount<'info, TokenAccount>,
    #[account(mut, token::mint = ghost_mint, token::token_program = token_program)]
    pub vault_token_account: InterfaceAccount<'info, TokenAccount>,
    pub token_program: Interface<'info, TokenInterface>,
}

#[derive(Accounts)]
pub struct WithdrawFromVault<'info> {
    #[account(seeds = [GHOST_SEED, signer.key().as_ref()], bump = ghost.bump, constraint = ghost.owner == signer.key() @ GhostError::Unauthorized)]
    pub ghost: Account<'info, GhostAccount>,
    /// CHECK: Vault PDA authority
    #[account(seeds = [VAULT_SEED, signer.key().as_ref()], bump = ghost.vault_bump)]
    pub vault: UncheckedAccount<'info>,
    #[account(mut)]
    pub signer: Signer<'info>,
    pub ghost_mint: InterfaceAccount<'info, Mint>,
    #[account(mut, token::mint = ghost_mint, token::token_program = token_program)]
    pub owner_token_account: InterfaceAccount<'info, TokenAccount>,
    #[account(mut, token::mint = ghost_mint, token::token_program = token_program)]
    pub vault_token_account: InterfaceAccount<'info, TokenAccount>,
    pub token_program: Interface<'info, TokenInterface>,
}

#[derive(Accounts)]
pub struct RecoveryWithdraw<'info> {
    #[account(mut, seeds = [GHOST_SEED, owner.key().as_ref()], bump = ghost.bump)]
    pub ghost: Account<'info, GhostAccount>,
    /// CHECK: Owner pubkey — used for PDA derivation, not a signer
    pub owner: UncheckedAccount<'info>,
    /// CHECK: Vault PDA — derived from owner
    #[account(seeds = [VAULT_SEED, owner.key().as_ref()], bump = ghost.vault_bump)]
    pub vault: UncheckedAccount<'info>,
    #[account(mut)]
    pub recovery_wallet: Signer<'info>,
    pub ghost_mint: InterfaceAccount<'info, Mint>,
    #[account(mut, token::mint = ghost_mint, token::token_program = token_program)]
    pub vault_token_account: InterfaceAccount<'info, TokenAccount>,
    #[account(mut, token::mint = ghost_mint, token::token_program = token_program)]
    pub recipient_token_account: InterfaceAccount<'info, TokenAccount>,
    pub token_program: Interface<'info, TokenInterface>,
}

#[derive(Accounts)]
pub struct UpdateSettings<'info> {
    #[account(mut, seeds = [GHOST_SEED, signer.key().as_ref()], bump = ghost.bump, constraint = ghost.owner == signer.key() @ GhostError::Unauthorized)]
    pub ghost: Account<'info, GhostAccount>,
    #[account(mut)]
    pub signer: Signer<'info>,
}

#[derive(Accounts)]
pub struct AbandonGhost<'info> {
    #[account(mut, seeds = [GHOST_SEED, signer.key().as_ref()], bump = ghost.bump, constraint = ghost.owner == signer.key() @ GhostError::Unauthorized, close = signer)]
    pub ghost: Account<'info, GhostAccount>,
    #[account(mut)]
    pub signer: Signer<'info>,
    pub ghost_mint: InterfaceAccount<'info, Mint>,
    #[account(mut, token::mint = ghost_mint, token::token_program = token_program)]
    pub ghost_stake_vault: InterfaceAccount<'info, TokenAccount>,
    #[account(mut, token::mint = ghost_mint, token::token_program = token_program)]
    pub owner_token_account: InterfaceAccount<'info, TokenAccount>,
    pub token_program: Interface<'info, TokenInterface>,
}

// ─── EVENTS ───────────────────────────────────────────────────

#[event] pub struct GhostRegistered { pub soul: Pubkey, pub interval: i64, pub grace_period: i64, pub recovery_wallet: Option<Pubkey>, pub staked: u64, pub timestamp: i64 }
#[event] pub struct HeartbeatReceived { pub soul: Pubkey, pub timestamp: i64, pub ping_number: u64 }
#[event] pub struct GhostAwakened { pub soul: Pubkey, pub silence_duration: i64, pub awakened_at: i64, pub grace_period_ends: i64, pub bounty_paid: u64, pub caller: Pubkey }
#[event] pub struct AwakeningCancelled { pub soul: Pubkey, pub cancelled_by: Pubkey, pub timestamp: i64 }
#[event] pub struct LegacyExecuted { pub soul: Pubkey, pub executed_at: i64, pub beneficiary_count: u8 }
#[event] pub struct TransferExecuted { pub soul: Pubkey, pub recipient: Pubkey, pub amount: u64 }
#[event] pub struct BeneficiaryAdded { pub soul: Pubkey, pub recipient: Pubkey, pub amount: u64, pub action: u8 }
#[event] pub struct VaultDeposit { pub soul: Pubkey, pub amount: u64 }
#[event] pub struct VaultWithdrawal { pub soul: Pubkey, pub amount: u64 }
#[event] pub struct GhostAbandoned { pub soul: Pubkey, pub burned: u64, pub returned: u64 }
#[event] pub struct WholeVaultRecipientSet { pub soul: Pubkey, pub recipient: Option<Pubkey>, pub cleared: bool, pub previous: Option<Pubkey> }
#[event] pub struct RecoveryWithdrawal { pub soul: Pubkey, pub recovery_wallet: Pubkey, pub amount: u64 }
// v1.4 new events
#[event] pub struct BeneficiaryUpdated { pub soul: Pubkey, pub index: u8, pub old_recipient: Pubkey, pub new_recipient: Pubkey, pub old_amount: u64, pub new_amount: u64, pub action: u8 }
#[event] pub struct BeneficiariesCleared { pub soul: Pubkey, pub cleared_by: Pubkey, pub count: u8 }
#[event] pub struct GhostPaused { pub soul: Pubkey, pub timestamp: i64 }
#[event] pub struct GhostResumed { pub soul: Pubkey, pub timestamp: i64 }
#[event] pub struct OwnershipTransferInitiated { pub soul: Pubkey, pub pending_owner: Pubkey, pub timestamp: i64 }
#[event] pub struct OwnershipTransferAccepted { pub old_owner: Pubkey, pub new_owner: Pubkey, pub timestamp: i64 }

// ─── ERRORS ───────────────────────────────────────────────────

#[error_code]
pub enum GhostError {
    #[msg("Insufficient $GHOST staked. Minimum 10,000 $GHOST required.")] InsufficientStake,
    #[msg("Heartbeat interval too short. Minimum 7 days.")] IntervalTooShort,
    #[msg("Grace period too short. Minimum 24 hours.")] GracePeriodTooShort,
    #[msg("This ghost has already awakened.")] GhostAlreadyAwakened,
    #[msg("This ghost has not yet awakened.")] GhostNotAwakened,
    #[msg("This ghost has already been executed.")] GhostAlreadyExecuted,
    #[msg("This ghost has not been executed yet.")] GhostNotExecuted,
    #[msg("Soul is still alive. Heartbeat detected within interval.")] SoulStillAlive,
    #[msg("Grace period is still active. Cannot execute yet.")] GracePeriodActive,
    #[msg("Grace period has expired. Cannot cancel.")] GracePeriodExpired,
    #[msg("Unauthorized.")] Unauthorized,
    #[msg("Too many beneficiaries. Maximum 10.")] TooManyBeneficiaries,
    #[msg("Invalid beneficiary index.")] InvalidBeneficiary,
    #[msg("Beneficiary already paid.")] BeneficiaryAlreadyPaid,
    #[msg("Wrong recipient account.")] WrongRecipient,
    #[msg("Arithmetic overflow.")] Overflow,
    // v1.4 new errors
    #[msg("Ghost is paused. Resume before modifying beneficiaries.")] GhostPausedError,
    #[msg("Ghost is not paused.")] GhostNotPaused,
    #[msg("No pending ownership transfer. Call transfer_ownership first.")] NoPendingOwnerTransfer,
}