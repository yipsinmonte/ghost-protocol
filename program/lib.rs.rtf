use anchor_lang::prelude::*;
use anchor_spl::token_interface::{self, Burn, TokenAccount, TokenInterface, TransferChecked, Mint};

declare_id!("3Es13GXc4qwttE6uSgAAfi1zvBD3qzLkZpY21KfT3sZ3");

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  GHOST Protocol v1.2 â€” Token-2022 compatible
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

pub const GHOST_SEED: &[u8] = b"ghost";
pub const VAULT_SEED: &[u8] = b"vault";
pub const MIN_STAKE: u64 = 10_000 * 1_000_000;
pub const MIN_INTERVAL: i64 = 7 * 24 * 60 * 60;
pub const MIN_GRACE_PERIOD: i64 = 24 * 60 * 60;
pub const MAX_BENEFICIARIES: usize = 10;
pub const SILENCE_BOUNTY_BPS: u64 = 500;
pub const BURN_ON_ABANDON_BPS: u64 = 5_000;
pub const GHOST_ACCOUNT_SPACE: usize = 8 + 900;

#[program]
pub mod ghost_protocol {
    use super::*;

    pub fn initialize_ghost(
        ctx: Context<InitializeGhost>,
        interval_seconds: i64,
        grace_period_seconds: i64,
        recovery_wallet: Option<Pubkey>,
        stake_amount: u64,
    ) -> Result<()> {
        require!(stake_amount >= MIN_STAKE, GhostError::InsufficientStake);
        require!(interval_seconds >= MIN_INTERVAL, GhostError::IntervalTooShort);
        require!(grace_period_seconds >= MIN_GRACE_PERIOD, GhostError::GracePeriodTooShort);

        let ghost = &mut ctx.accounts.ghost;
        let clock = Clock::get()?;

        ghost.owner = ctx.accounts.signer.key();
        ghost.recovery_wallet = recovery_wallet;
        ghost.last_heartbeat = clock.unix_timestamp;
        ghost.interval_seconds = interval_seconds;
        ghost.grace_period_seconds = grace_period_seconds;
        ghost.awakened = false;
        ghost.awakened_at = None;
        ghost.executed = false;
        ghost.executed_at = None;
        ghost.staked_ghost = stake_amount;
        ghost.bump = ctx.bumps.ghost;
        ghost.vault_bump = ctx.bumps.vault;
        ghost.registered_at = clock.unix_timestamp;
        ghost.ping_count = 0;
        ghost.beneficiary_count = 0;
        for i in 0..10 {
            ghost.beneficiaries[i] = Beneficiary::default();
        }

        let cpi_ctx = CpiContext::new(
            ctx.accounts.token_program.to_account_info(),
            TransferChecked {
                from: ctx.accounts.signer_token_account.to_account_info(),
                to: ctx.accounts.ghost_stake_vault.to_account_info(),
                authority: ctx.accounts.signer.to_account_info(),
                mint: ctx.accounts.ghost_mint.to_account_info(),
            },
        );
        token_interface::transfer_checked(cpi_ctx, stake_amount, ctx.accounts.ghost_mint.decimals)?;

        emit!(GhostRegistered {
            soul: ghost.owner,
            interval: interval_seconds,
            grace_period: grace_period_seconds,
            recovery_wallet,
            staked: stake_amount,
            timestamp: clock.unix_timestamp,
        });

        msg!("ğŸ‘» Ghost initialized for {}", ghost.owner);
        Ok(())
    }

    pub fn ping(ctx: Context<Ping>) -> Result<()> {
        let ghost = &mut ctx.accounts.ghost;
        require!(!ghost.executed, GhostError::GhostAlreadyExecuted);

        let clock = Clock::get()?;
        ghost.last_heartbeat = clock.unix_timestamp;
        ghost.ping_count += 1;

        if ghost.awakened {
            ghost.awakened = false;
            ghost.awakened_at = None;
            msg!("ğŸ’“ Ping received â€” awakening cancelled");
        } else {
            msg!("ğŸ’“ Heartbeat #{} recorded", ghost.ping_count);
        }

        emit!(HeartbeatReceived {
            soul: ghost.owner,
            timestamp: clock.unix_timestamp,
            ping_number: ghost.ping_count,
        });

        Ok(())
    }

    pub fn add_beneficiary(
        ctx: Context<ManageBeneficiaries>,
        recipient: Pubkey,
        amount: u64,
        token_mint: Option<Pubkey>,
        action: u8,
    ) -> Result<()> {
        let ghost = &mut ctx.accounts.ghost;
        require!(!ghost.awakened, GhostError::GhostAlreadyAwakened);
        require!(
            (ghost.beneficiary_count as usize) < MAX_BENEFICIARIES,
            GhostError::TooManyBeneficiaries
        );

        let idx = ghost.beneficiary_count as usize;
        ghost.beneficiaries[idx] = Beneficiary { recipient, amount, token_mint, action, executed: false };
        ghost.beneficiary_count += 1;

        emit!(BeneficiaryAdded { soul: ghost.owner, recipient, amount, action });
        msg!("ğŸ“‹ Beneficiary added: {} receives {}", recipient, amount);
        Ok(())
    }

    pub fn remove_beneficiary(ctx: Context<ManageBeneficiaries>, index: u8) -> Result<()> {
        let ghost = &mut ctx.accounts.ghost;
        require!(!ghost.awakened, GhostError::GhostAlreadyAwakened);
        require!((index as usize) < ghost.beneficiary_count as usize, GhostError::InvalidBeneficiary);

        let count = ghost.beneficiary_count as usize;
        for i in (index as usize)..(count - 1) {
            ghost.beneficiaries[i] = ghost.beneficiaries[i + 1];
        }
        ghost.beneficiary_count -= 1;
        msg!("ğŸ“‹ Beneficiary at index {} removed", index);
        Ok(())
    }

    pub fn check_silence(ctx: Context<CheckSilence>) -> Result<()> {
        let clock = Clock::get()?;
        let owner = ctx.accounts.ghost.owner;
        let awakened = ctx.accounts.ghost.awakened;
        let executed = ctx.accounts.ghost.executed;
        let last_heartbeat = ctx.accounts.ghost.last_heartbeat;
        let interval_seconds = ctx.accounts.ghost.interval_seconds;
        let grace_period_seconds = ctx.accounts.ghost.grace_period_seconds;
        let staked_ghost = ctx.accounts.ghost.staked_ghost;
        let bump = ctx.accounts.ghost.bump;
        let caller_key = ctx.accounts.caller.key();

        require!(!awakened, GhostError::GhostAlreadyAwakened);
        require!(!executed, GhostError::GhostAlreadyExecuted);

        let silence = clock.unix_timestamp - last_heartbeat;
        require!(silence > interval_seconds, GhostError::SoulStillAlive);

        let bounty = staked_ghost.checked_mul(SILENCE_BOUNTY_BPS).unwrap().checked_div(10_000).unwrap();

        ctx.accounts.ghost.awakened = true;
        ctx.accounts.ghost.awakened_at = Some(clock.unix_timestamp);

        let seeds = &[GHOST_SEED, owner.as_ref(), &[bump]];
        let signer_seeds = &[&seeds[..]];

        let cpi_ctx = CpiContext::new_with_signer(
            ctx.accounts.token_program.to_account_info(),
            TransferChecked {
                from: ctx.accounts.ghost_stake_vault.to_account_info(),
                to: ctx.accounts.caller_token_account.to_account_info(),
                authority: ctx.accounts.ghost.to_account_info(),
                mint: ctx.accounts.ghost_mint.to_account_info(),
            },
            signer_seeds,
        );
        token_interface::transfer_checked(cpi_ctx, bounty, ctx.accounts.ghost_mint.decimals)?;

        emit!(GhostAwakened {
            soul: owner,
            silence_duration: silence,
            awakened_at: clock.unix_timestamp,
            grace_period_ends: clock.unix_timestamp + grace_period_seconds,
            bounty_paid: bounty,
            caller: caller_key,
        });

        msg!("ğŸ‘» Ghost awakened! Grace period: {}s", grace_period_seconds);
        Ok(())
    }

    pub fn cancel_awakening(ctx: Context<CancelAwakening>) -> Result<()> {
        let ghost = &mut ctx.accounts.ghost;
        require!(ghost.awakened, GhostError::GhostNotAwakened);
        require!(!ghost.executed, GhostError::GhostAlreadyExecuted);

        let clock = Clock::get()?;
        let grace_end = ghost.awakened_at.unwrap() + ghost.grace_period_seconds;
        require!(clock.unix_timestamp <= grace_end, GhostError::GracePeriodExpired);

        let caller = ctx.accounts.signer.key();
        require!(
            caller == ghost.owner || ghost.recovery_wallet.map_or(false, |r| r == caller),
            GhostError::Unauthorized
        );

        ghost.awakened = false;
        ghost.awakened_at = None;
        ghost.last_heartbeat = clock.unix_timestamp;

        emit!(AwakeningCancelled { soul: ghost.owner, cancelled_by: caller, timestamp: clock.unix_timestamp });
        msg!("âœ… Awakening cancelled by {}", caller);
        Ok(())
    }

    pub fn execute_legacy(ctx: Context<ExecuteLegacy>) -> Result<()> {
        let ghost = &mut ctx.accounts.ghost;
        require!(ghost.awakened, GhostError::GhostNotAwakened);
        require!(!ghost.executed, GhostError::GhostAlreadyExecuted);

        let clock = Clock::get()?;
        let grace_end = ghost.awakened_at.unwrap() + ghost.grace_period_seconds;
        require!(clock.unix_timestamp > grace_end, GhostError::GracePeriodActive);

        ghost.executed = true;
        ghost.executed_at = Some(clock.unix_timestamp);

        emit!(LegacyExecuted { soul: ghost.owner, executed_at: clock.unix_timestamp, beneficiary_count: ghost.beneficiary_count });
        msg!("ğŸ’€ Ghost executed. {} beneficiaries to distribute.", ghost.beneficiary_count);
        Ok(())
    }

    pub fn execute_transfer(ctx: Context<ExecuteTransfer>, beneficiary_index: u8) -> Result<()> {
        require!(ctx.accounts.ghost.executed, GhostError::GhostNotExecuted);
        require!((beneficiary_index as usize) < ctx.accounts.ghost.beneficiary_count as usize, GhostError::InvalidBeneficiary);

        let beneficiary = ctx.accounts.ghost.beneficiaries[beneficiary_index as usize];
        require!(!beneficiary.executed, GhostError::BeneficiaryAlreadyPaid);
        require!(beneficiary.recipient == ctx.accounts.recipient.key(), GhostError::WrongRecipient);

        let owner = ctx.accounts.ghost.owner;
        let vault_bump = ctx.accounts.ghost.vault_bump;
        let seeds = &[VAULT_SEED, owner.as_ref(), &[vault_bump]];
        let signer_seeds = &[&seeds[..]];

        let cpi_ctx = CpiContext::new_with_signer(
            ctx.accounts.token_program.to_account_info(),
            TransferChecked {
                from: ctx.accounts.vault_token_account.to_account_info(),
                to: ctx.accounts.recipient_token_account.to_account_info(),
                authority: ctx.accounts.vault.to_account_info(),
                mint: ctx.accounts.ghost_mint.to_account_info(),
            },
            signer_seeds,
        );
        token_interface::transfer_checked(cpi_ctx, beneficiary.amount, ctx.accounts.ghost_mint.decimals)?;

        ctx.accounts.ghost.beneficiaries[beneficiary_index as usize].executed = true;
        emit!(TransferExecuted { soul: owner, recipient: beneficiary.recipient, amount: beneficiary.amount });
        msg!("âœ… Transferred {} to {}", beneficiary.amount, beneficiary.recipient);
        Ok(())
    }

    pub fn deposit_to_vault(ctx: Context<DepositToVault>, amount: u64) -> Result<()> {
        let cpi_ctx = CpiContext::new(
            ctx.accounts.token_program.to_account_info(),
            TransferChecked {
                from: ctx.accounts.owner_token_account.to_account_info(),
                to: ctx.accounts.vault_token_account.to_account_info(),
                authority: ctx.accounts.signer.to_account_info(),
                mint: ctx.accounts.ghost_mint.to_account_info(),
            },
        );
        token_interface::transfer_checked(cpi_ctx, amount, ctx.accounts.ghost_mint.decimals)?;
        emit!(VaultDeposit { soul: ctx.accounts.ghost.owner, amount });
        msg!("ğŸ“¥ Deposited {} to vault", amount);
        Ok(())
    }

    pub fn withdraw_from_vault(ctx: Context<WithdrawFromVault>, amount: u64) -> Result<()> {
        require!(!ctx.accounts.ghost.awakened, GhostError::GhostAlreadyAwakened);

        let owner = ctx.accounts.ghost.owner;
        let vault_bump = ctx.accounts.ghost.vault_bump;
        let seeds = &[VAULT_SEED, owner.as_ref(), &[vault_bump]];
        let signer_seeds = &[&seeds[..]];

        let cpi_ctx = CpiContext::new_with_signer(
            ctx.accounts.token_program.to_account_info(),
            TransferChecked {
                from: ctx.accounts.vault_token_account.to_account_info(),
                to: ctx.accounts.owner_token_account.to_account_info(),
                authority: ctx.accounts.vault.to_account_info(),
                mint: ctx.accounts.ghost_mint.to_account_info(),
            },
            signer_seeds,
        );
        token_interface::transfer_checked(cpi_ctx, amount, ctx.accounts.ghost_mint.decimals)?;
        emit!(VaultWithdrawal { soul: owner, amount });
        msg!("ğŸ“¤ Withdrew {} from vault", amount);
        Ok(())
    }

    pub fn update_interval(ctx: Context<UpdateSettings>, interval_seconds: i64) -> Result<()> {
        require!(interval_seconds >= MIN_INTERVAL, GhostError::IntervalTooShort);
        ctx.accounts.ghost.interval_seconds = interval_seconds;
        msg!("â±ï¸ Interval updated to {}s", interval_seconds);
        Ok(())
    }

    pub fn update_grace_period(ctx: Context<UpdateSettings>, grace_period_seconds: i64) -> Result<()> {
        require!(grace_period_seconds >= MIN_GRACE_PERIOD, GhostError::GracePeriodTooShort);
        ctx.accounts.ghost.grace_period_seconds = grace_period_seconds;
        msg!("â³ Grace period updated to {}s", grace_period_seconds);
        Ok(())
    }

    pub fn update_recovery_wallet(ctx: Context<UpdateSettings>, recovery_wallet: Option<Pubkey>) -> Result<()> {
        ctx.accounts.ghost.recovery_wallet = recovery_wallet;
        msg!("ğŸ”‘ Recovery wallet updated");
        Ok(())
    }

    pub fn abandon_ghost(ctx: Context<AbandonGhost>) -> Result<()> {
        let owner = ctx.accounts.ghost.owner;
        let staked = ctx.accounts.ghost.staked_ghost;
        let bump = ctx.accounts.ghost.bump;

        let burn_amount = staked.checked_mul(BURN_ON_ABANDON_BPS).unwrap().checked_div(10_000).unwrap();
        let return_amount = staked.checked_sub(burn_amount).unwrap();

        let seeds = &[GHOST_SEED, owner.as_ref(), &[bump]];
        let signer_seeds = &[&seeds[..]];

        let burn_ctx = CpiContext::new_with_signer(
            ctx.accounts.token_program.to_account_info(),
            Burn {
                mint: ctx.accounts.ghost_mint.to_account_info(),
                from: ctx.accounts.ghost_stake_vault.to_account_info(),
                authority: ctx.accounts.ghost.to_account_info(),
            },
            signer_seeds,
        );
        token_interface::burn(burn_ctx, burn_amount)?;

        let return_ctx = CpiContext::new_with_signer(
            ctx.accounts.token_program.to_account_info(),
            TransferChecked {
                from: ctx.accounts.ghost_stake_vault.to_account_info(),
                to: ctx.accounts.owner_token_account.to_account_info(),
                authority: ctx.accounts.ghost.to_account_info(),
                mint: ctx.accounts.ghost_mint.to_account_info(),
            },
            signer_seeds,
        );
        token_interface::transfer_checked(return_ctx, return_amount, ctx.accounts.ghost_mint.decimals)?;

        emit!(GhostAbandoned { soul: owner, burned: burn_amount, returned: return_amount });
        msg!("ğŸ’€ Ghost abandoned. Burned: {}, Returned: {}", burn_amount, return_amount);
        Ok(())
    }
}

// â”€â”€â”€ STRUCTS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

#[derive(AnchorSerialize, AnchorDeserialize, Clone, Copy, PartialEq)]
pub struct Beneficiary {
    pub recipient: Pubkey,
    pub amount: u64,
    pub token_mint: Option<Pubkey>,
    pub action: u8,
    pub executed: bool,
}

impl Default for Beneficiary {
    fn default() -> Self {
        Self { recipient: Pubkey::default(), amount: 0, token_mint: None, action: 0, executed: false }
    }
}

#[account]
pub struct GhostAccount {
    pub owner: Pubkey,
    pub recovery_wallet: Option<Pubkey>,
    pub last_heartbeat: i64,
    pub interval_seconds: i64,
    pub grace_period_seconds: i64,
    pub awakened: bool,
    pub awakened_at: Option<i64>,
    pub executed: bool,
    pub executed_at: Option<i64>,
    pub staked_ghost: u64,
    pub bump: u8,
    pub vault_bump: u8,
    pub registered_at: i64,
    pub ping_count: u64,
    pub beneficiary_count: u8,
    pub beneficiaries: [Beneficiary; 10],
}

// â”€â”€â”€ CONTEXTS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

#[derive(Accounts)]
pub struct InitializeGhost<'info> {
    #[account(
        init,
        payer = signer,
        space = GHOST_ACCOUNT_SPACE,
        seeds = [GHOST_SEED, signer.key().as_ref()],
        bump,
    )]
    pub ghost: Box<Account<'info, GhostAccount>>,

    /// CHECK: Vault PDA
    #[account(seeds = [VAULT_SEED, signer.key().as_ref()], bump)]
    pub vault: UncheckedAccount<'info>,

    pub ghost_mint: InterfaceAccount<'info, Mint>,

    #[account(
        init,
        payer = signer,
        seeds = [b"stake_vault", signer.key().as_ref()],
        bump,
        token::mint = ghost_mint,
        token::authority = ghost,
        token::token_program = token_program,
    )]
    pub ghost_stake_vault: InterfaceAccount<'info, TokenAccount>,

    #[account(mut, token::mint = ghost_mint, token::authority = signer, token::token_program = token_program)]
    pub signer_token_account: InterfaceAccount<'info, TokenAccount>,

    #[account(mut)]
    pub signer: Signer<'info>,

    pub token_program: Interface<'info, TokenInterface>,
    pub system_program: Program<'info, System>,
}

#[derive(Accounts)]
pub struct Ping<'info> {
    #[account(mut, seeds = [GHOST_SEED, signer.key().as_ref()], bump = ghost.bump, constraint = ghost.owner == signer.key() @ GhostError::Unauthorized)]
    pub ghost: Account<'info, GhostAccount>,
    #[account(mut)]
    pub signer: Signer<'info>,
}

#[derive(Accounts)]
pub struct ManageBeneficiaries<'info> {
    #[account(mut, seeds = [GHOST_SEED, signer.key().as_ref()], bump = ghost.bump, constraint = ghost.owner == signer.key() @ GhostError::Unauthorized)]
    pub ghost: Account<'info, GhostAccount>,
    #[account(mut)]
    pub signer: Signer<'info>,
}

#[derive(Accounts)]
pub struct CheckSilence<'info> {
    #[account(mut, seeds = [GHOST_SEED, ghost.owner.as_ref()], bump = ghost.bump)]
    pub ghost: Account<'info, GhostAccount>,
    #[account(mut)]
    pub caller: Signer<'info>,
    pub ghost_mint: InterfaceAccount<'info, Mint>,
    #[account(mut, token::mint = ghost_mint, token::token_program = token_program)]
    pub ghost_stake_vault: InterfaceAccount<'info, TokenAccount>,
    #[account(mut, token::mint = ghost_mint, token::token_program = token_program)]
    pub caller_token_account: InterfaceAccount<'info, TokenAccount>,
    pub token_program: Interface<'info, TokenInterface>,
}

#[derive(Accounts)]
pub struct CancelAwakening<'info> {
    #[account(mut, seeds = [GHOST_SEED, ghost.owner.as_ref()], bump = ghost.bump)]
    pub ghost: Account<'info, GhostAccount>,
    #[account(mut)]
    pub signer: Signer<'info>,
}

#[derive(Accounts)]
pub struct ExecuteLegacy<'info> {
    #[account(mut, seeds = [GHOST_SEED, ghost.owner.as_ref()], bump = ghost.bump)]
    pub ghost: Account<'info, GhostAccount>,
    pub caller: Signer<'info>,
}

#[derive(Accounts)]
pub struct ExecuteTransfer<'info> {
    #[account(mut, seeds = [GHOST_SEED, ghost.owner.as_ref()], bump = ghost.bump)]
    pub ghost: Account<'info, GhostAccount>,
    /// CHECK: Vault PDA authority
    #[account(seeds = [VAULT_SEED, ghost.owner.as_ref()], bump = ghost.vault_bump)]
    pub vault: UncheckedAccount<'info>,
    pub ghost_mint: InterfaceAccount<'info, Mint>,
    #[account(mut, token::mint = ghost_mint, token::token_program = token_program)]
    pub vault_token_account: InterfaceAccount<'info, TokenAccount>,
    /// CHECK: validated against beneficiary list
    pub recipient: UncheckedAccount<'info>,
    #[account(mut, token::mint = ghost_mint, token::token_program = token_program)]
    pub recipient_token_account: InterfaceAccount<'info, TokenAccount>,
    pub token_program: Interface<'info, TokenInterface>,
    pub caller: Signer<'info>,
}

#[derive(Accounts)]
pub struct DepositToVault<'info> {
    #[account(seeds = [GHOST_SEED, signer.key().as_ref()], bump = ghost.bump, constraint = ghost.owner == signer.key() @ GhostError::Unauthorized)]
    pub ghost: Account<'info, GhostAccount>,
    #[account(mut)]
    pub signer: Signer<'info>,
    pub ghost_mint: InterfaceAccount<'info, Mint>,
    #[account(mut, token::mint = ghost_mint, token::token_program = token_program)]
    pub owner_token_account: InterfaceAccount<'info, TokenAccount>,
    #[account(mut, token::mint = ghost_mint, token::token_program = token_program)]
    pub vault_token_account: InterfaceAccount<'info, TokenAccount>,
    pub token_program: Interface<'info, TokenInterface>,
}

#[derive(Accounts)]
pub struct WithdrawFromVault<'info> {
    #[account(seeds = [GHOST_SEED, signer.key().as_ref()], bump = ghost.bump, constraint = ghost.owner == signer.key() @ GhostError::Unauthorized)]
    pub ghost: Account<'info, GhostAccount>,
    /// CHECK: Vault PDA authority
    #[account(seeds = [VAULT_SEED, signer.key().as_ref()], bump = ghost.vault_bump)]
    pub vault: UncheckedAccount<'info>,
    #[account(mut)]
    pub signer: Signer<'info>,
    pub ghost_mint: InterfaceAccount<'info, Mint>,
    #[account(mut, token::mint = ghost_mint, token::token_program = token_program)]
    pub owner_token_account: InterfaceAccount<'info, TokenAccount>,
    #[account(mut, token::mint = ghost_mint, token::token_program = token_program)]
    pub vault_token_account: InterfaceAccount<'info, TokenAccount>,
    pub token_program: Interface<'info, TokenInterface>,
}

#[derive(Accounts)]
pub struct UpdateSettings<'info> {
    #[account(mut, seeds = [GHOST_SEED, signer.key().as_ref()], bump = ghost.bump, constraint = ghost.owner == signer.key() @ GhostError::Unauthorized)]
    pub ghost: Account<'info, GhostAccount>,
    #[account(mut)]
    pub signer: Signer<'info>,
}

#[derive(Accounts)]
pub struct AbandonGhost<'info> {
    #[account(mut, seeds = [GHOST_SEED, signer.key().as_ref()], bump = ghost.bump, constraint = ghost.owner == signer.key() @ GhostError::Unauthorized, close = signer)]
    pub ghost: Account<'info, GhostAccount>,
    #[account(mut)]
    pub signer: Signer<'info>,
    pub ghost_mint: InterfaceAccount<'info, Mint>,
    #[account(mut, token::mint = ghost_mint, token::token_program = token_program)]
    pub ghost_stake_vault: InterfaceAccount<'info, TokenAccount>,
    #[account(mut, token::mint = ghost_mint, token::token_program = token_program)]
    pub owner_token_account: InterfaceAccount<'info, TokenAccount>,
    pub token_program: Interface<'info, TokenInterface>,
}

// â”€â”€â”€ EVENTS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

#[event] pub struct GhostRegistered { pub soul: Pubkey, pub interval: i64, pub grace_period: i64, pub recovery_wallet: Option<Pubkey>, pub staked: u64, pub timestamp: i64 }
#[event] pub struct HeartbeatReceived { pub soul: Pubkey, pub timestamp: i64, pub ping_number: u64 }
#[event] pub struct GhostAwakened { pub soul: Pubkey, pub silence_duration: i64, pub awakened_at: i64, pub grace_period_ends: i64, pub bounty_paid: u64, pub caller: Pubkey }
#[event] pub struct AwakeningCancelled { pub soul: Pubkey, pub cancelled_by: Pubkey, pub timestamp: i64 }
#[event] pub struct LegacyExecuted { pub soul: Pubkey, pub executed_at: i64, pub beneficiary_count: u8 }
#[event] pub struct TransferExecuted { pub soul: Pubkey, pub recipient: Pubkey, pub amount: u64 }
#[event] pub struct BeneficiaryAdded { pub soul: Pubkey, pub recipient: Pubkey, pub amount: u64, pub action: u8 }
#[event] pub struct VaultDeposit { pub soul: Pubkey, pub amount: u64 }
#[event] pub struct VaultWithdrawal { pub soul: Pubkey, pub amount: u64 }
#[event] pub struct GhostAbandoned { pub soul: Pubkey, pub burned: u64, pub returned: u64 }

// â”€â”€â”€ ERRORS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

#[error_code]
pub enum GhostError {
    #[msg("Insufficient $GHOST staked. Minimum 10,000 $GHOST required.")] InsufficientStake,
    #[msg("Heartbeat interval too short. Minimum 7 days.")] IntervalTooShort,
    #[msg("Grace period too short. Minimum 24 hours.")] GracePeriodTooShort,
    #[msg("This ghost has already awakened.")] GhostAlreadyAwakened,
    #[msg("This ghost has not yet awakened.")] GhostNotAwakened,
    #[msg("This ghost has already been executed.")] GhostAlreadyExecuted,
    #[msg("This ghost has not been executed yet.")] GhostNotExecuted,
    #[msg("Soul is still alive. Heartbeat detected within interval.")] SoulStillAlive,
    #[msg("Grace period is still active. Cannot execute yet.")] GracePeriodActive,
    #[msg("Grace period has expired. Cannot cancel.")] GracePeriodExpired,
    #[msg("Unauthorized.")] Unauthorized,
    #[msg("Too many beneficiaries. Maximum 10.")] TooManyBeneficiaries,
    #[msg("Invalid beneficiary index.")] InvalidBeneficiary,
    #[msg("Beneficiary already paid.")] BeneficiaryAlreadyPaid,
    #[msg("Wrong recipient account.")] WrongRecipient,
    #[msg("Arithmetic overflow.")] Overflow,
}