<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>GHOST ‚Äî Your Digital Afterlife on Solana</title>
<link href="https://fonts.googleapis.com/css2?family=Share+Tech+Mono&family=Cormorant+Garamond:ital,wght@0,300;0,400;1,300;1,400&family=Syne:wght@400;700;800&display=swap" rel="stylesheet">
<style>
  *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
  :root {
    --black: #030305; --deep: #07070f; --ghost: #0d0d1a; --dim: #11111f;
    --accent: #7744ff; --accent2: #4422cc; --glow: #9966ff;
    --pulse: #ff3366; --text: #e0e0ec; --muted: #9090a8; --white: #f0f0f8;
    --sol: #9945ff; --green: #33ff99; --amber: #ffb830; --red: #ff3d5a;
    --card: #0a0a18; --border: rgba(102,51,255,0.12);
  }
  html { scroll-behavior: smooth; }
  body { background: var(--black); color: var(--text); font-family: 'Syne', sans-serif; font-size: 18px; line-height: 1.7; cursor: crosshair; font-weight: 400; }
  .marketing-site { overflow-x: hidden; }
  body::before { content: ''; position: fixed; inset: 0; background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 256 256' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noise)' opacity='0.04'/%3E%3C/svg%3E"); pointer-events: none; z-index: 999; opacity: 0.5; }
  body::after { content: ''; position: fixed; inset: 0; background: repeating-linear-gradient(0deg, transparent, transparent 2px, rgba(0,0,0,0.08) 2px, rgba(0,0,0,0.08) 4px); pointer-events: none; z-index: 998; }

  /* ‚îÄ‚îÄ‚îÄ NAV ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
  nav { position: fixed; top: 0; width: 100%; padding: 20px 48px; display: flex; justify-content: space-between; align-items: center; z-index: 100; background: linear-gradient(to bottom, rgba(3,3,5,0.97), transparent); border-bottom: 1px solid rgba(102,51,255,0.08); }
  .nav-logo { font-family: 'Syne', sans-serif; font-weight: 800; font-size: 20px; letter-spacing: 0.3em; color: var(--white); text-decoration: none; }
  .nav-logo span { color: var(--accent); }
  .nav-links { display: flex; gap: 36px; list-style: none; align-items: center; }
  .nav-links a { font-family: 'Share Tech Mono', monospace; font-size: 13px; letter-spacing: 0.2em; color: var(--muted); text-decoration: none; text-transform: uppercase; transition: color 0.3s; }
  .nav-links a:hover { color: var(--glow); }

  /* Dashboard nav link ‚Äî hidden until connected */
  .nav-dashboard-link { display: none !important; }
  .nav-dashboard-link.visible { display: flex !important; align-items: center; gap: 6px; color: var(--green) !important; border: 1px solid rgba(51,255,153,0.25); padding: 6px 14px; transition: all 0.3s; }
  .nav-dashboard-link.visible:hover { background: rgba(51,255,153,0.08); border-color: var(--green); }
  .nav-dashboard-dot { width: 6px; height: 6px; border-radius: 50%; background: var(--green); animation: pulse-dot 2s ease-in-out infinite; }
  @keyframes pulse-dot { 0%,100%{opacity:1} 50%{opacity:0.3} }

  .wallet-btn { font-family: 'Share Tech Mono', monospace; font-size: 13px; letter-spacing: 0.15em; text-transform: uppercase; padding: 10px 20px; border: 1px solid var(--sol); color: var(--sol); background: transparent; cursor: pointer; transition: all 0.3s; position: relative; overflow: hidden; }
  .wallet-btn::before { content: ''; position: absolute; inset: 0; background: var(--sol); transform: translateX(-100%); transition: transform 0.3s; z-index: -1; }
  .wallet-btn:hover { color: var(--black); }
  .wallet-btn:hover::before { transform: translateX(0); }
  .wallet-btn.connected { border-color: var(--green); color: var(--green); }
  .wallet-btn.connected:hover { color: var(--black); }
  .wallet-btn.connected::before { background: var(--green); }

  /* ‚îÄ‚îÄ‚îÄ CONTRACT BANNER ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
  .contract-banner { background: rgba(102,51,255,0.06); border-bottom: 1px solid rgba(102,51,255,0.12); padding: 10px 48px; display: flex; justify-content: center; align-items: center; gap: 16px; margin-top: 73px; font-family: 'Share Tech Mono', monospace; font-size: 13px; }
  .contract-banner .label { color: var(--muted); letter-spacing: 0.2em; text-transform: uppercase; }
  .contract-addr { color: var(--accent); letter-spacing: 0.1em; }
  .copy-btn { background: none; border: 1px solid rgba(102,51,255,0.3); color: var(--muted); font-family: 'Share Tech Mono', monospace; font-size: 12px; padding: 3px 10px; cursor: pointer; letter-spacing: 0.15em; transition: all 0.2s; }
  .copy-btn:hover { border-color: var(--accent); color: var(--accent); }
  .sol-badge { background: rgba(153,69,255,0.15); border: 1px solid rgba(153,69,255,0.3); color: var(--sol); font-size: 12px; padding: 3px 10px; letter-spacing: 0.2em; }

  /* ‚îÄ‚îÄ‚îÄ HERO ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
  .hero { min-height: 100vh; display: flex; flex-direction: column; justify-content: center; align-items: center; text-align: center; padding: 100px 40px 80px; position: relative; overflow: hidden; }
  .hero-bg { position: absolute; inset: 0; background: radial-gradient(ellipse 60% 50% at 50% 60%, rgba(102,51,255,0.08) 0%, transparent 70%), radial-gradient(ellipse 30% 30% at 20% 20%, rgba(51,17,170,0.05) 0%, transparent 60%); pointer-events: none; }
  .hero-grid { position: absolute; inset: 0; background-image: linear-gradient(rgba(102,51,255,0.04) 1px, transparent 1px), linear-gradient(90deg, rgba(102,51,255,0.04) 1px, transparent 1px); background-size: 60px 60px; mask-image: radial-gradient(ellipse 80% 80% at 50% 50%, black 0%, transparent 100%); pointer-events: none; }
  .heartbeat-ring { position: absolute; width: 600px; height: 600px; border-radius: 50%; border: 1px solid rgba(102,51,255,0.1); top: 50%; left: 50%; transform: translate(-50%, -50%); animation: ring-pulse 4s ease-in-out infinite; pointer-events: none; }
  .heartbeat-ring:nth-child(2) { width: 800px; height: 800px; animation-delay: 1s; opacity: 0.6; }
  .heartbeat-ring:nth-child(3) { width: 1000px; height: 1000px; animation-delay: 2s; opacity: 0.3; }
  @keyframes ring-pulse { 0%, 100% { transform: translate(-50%, -50%) scale(1); opacity: 0.2; } 50% { transform: translate(-50%, -50%) scale(1.05); opacity: 0.5; } }
  .hero-logo { width: 120px; height: 120px; margin-bottom: 32px; animation: fade-up 1s ease both; filter: drop-shadow(0 0 30px rgba(102,51,255,0.5)); }
  .hero-eyebrow { font-family: 'Share Tech Mono', monospace; font-size: 13px; letter-spacing: 0.4em; color: var(--accent); text-transform: uppercase; margin-bottom: 24px; animation: fade-up 1s ease 0.1s both; }
  .hero-eyebrow::before { content: '‚óà '; }
  .hero-eyebrow::after { content: ' ‚óà'; }
  .hero-title { font-family: 'Syne', sans-serif; font-weight: 800; font-size: clamp(72px, 15vw, 160px); letter-spacing: -0.02em; line-height: 0.9; color: var(--white); margin-bottom: 8px; animation: fade-up 1s ease 0.2s both; position: relative; }
  .hero-title::after { content: 'GHOST'; position: absolute; inset: 0; color: transparent; -webkit-text-stroke: 1px rgba(102,51,255,0.3); transform: translate(3px, 3px); z-index: -1; }
  .hero-ticker { font-family: 'Share Tech Mono', monospace; font-size: 18px; letter-spacing: 0.3em; color: var(--accent); margin-bottom: 32px; animation: fade-up 1s ease 0.25s both; }
  .hero-sub { font-size: clamp(18px, 2.5vw, 24px); font-weight: 400; color: var(--text); max-width: 540px; margin: 0 auto 48px; animation: fade-up 1s ease 0.3s both; line-height: 1.5; }
  .hero-actions { display: flex; gap: 16px; justify-content: center; flex-wrap: wrap; animation: fade-up 1s ease 0.4s both; margin-bottom: 64px; position: relative; z-index: 10; }
  .btn-pump { font-family: 'Share Tech Mono', monospace; font-size: 14px; letter-spacing: 0.2em; text-transform: uppercase; padding: 16px 36px; background: var(--accent); color: var(--white); text-decoration: none; transition: all 0.3s; display: flex; align-items: center; gap: 10px; }
  .btn-pump:hover { background: var(--glow); box-shadow: 0 0 40px rgba(136,85,255,0.5); }
  .btn-pump .pump-icon { font-size: 16px; }
  .btn-secondary { font-family: 'Share Tech Mono', monospace; font-size: 14px; letter-spacing: 0.2em; text-transform: uppercase; padding: 16px 36px; border: 1px solid var(--muted); color: var(--muted); text-decoration: none; transition: all 0.3s; cursor: pointer; background: transparent; }
  .btn-secondary:hover { border-color: var(--text); color: var(--text); }
  .btn-dex { font-family: 'Share Tech Mono', monospace; font-size: 14px; letter-spacing: 0.2em; text-transform: uppercase; padding: 16px 36px; border: 1px solid rgba(153,69,255,0.4); color: var(--sol); text-decoration: none; transition: all 0.3s; }
  .btn-dex:hover { border-color: var(--sol); box-shadow: 0 0 20px rgba(153,69,255,0.2); }
  .heartbeat-bar { width: 100%; max-width: 700px; margin: 0 auto; animation: fade-up 1s ease 0.5s both; }
  .hb-label { font-family: 'Share Tech Mono', monospace; font-size: 12px; letter-spacing: 0.3em; color: var(--muted); text-transform: uppercase; display: flex; justify-content: space-between; margin-bottom: 12px; }
  .hb-label span:last-child { color: var(--pulse); animation: blink 1s ease-in-out infinite; }
  @keyframes blink { 0%, 100% { opacity: 1; } 50% { opacity: 0.3; } }
  .hb-line { height: 60px; position: relative; overflow: hidden; }
  .hb-svg { width: 200%; height: 100%; animation: hb-scroll 3s linear infinite; }
  @keyframes hb-scroll { from { transform: translateX(0); } to { transform: translateX(-50%); } }

  /* ‚îÄ‚îÄ‚îÄ STATS / TICKER ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
  .stats-wrap { max-width: 900px; margin: 0 auto; }
  .stats { display: flex; justify-content: center; border-top: 1px solid rgba(102,51,255,0.15); border-bottom: 1px solid rgba(102,51,255,0.15); }
  .stat { flex: 1; padding: 36px 28px; text-align: center; border-right: 1px solid rgba(102,51,255,0.1); }
  .stat:last-child { border-right: none; }
  .stat-value { font-family: 'Syne', sans-serif; font-weight: 700; font-size: 28px; color: var(--white); display: block; margin-bottom: 6px; }
  .stat-label { font-family: 'Share Tech Mono', monospace; font-size: 12px; letter-spacing: 0.25em; color: var(--muted); text-transform: uppercase; }
  .price-ticker { background: rgba(153,69,255,0.05); border: 1px solid rgba(153,69,255,0.15); padding: 16px 32px; display: flex; gap: 40px; justify-content: center; align-items: center; font-family: 'Share Tech Mono', monospace; font-size: 12px; max-width: 900px; margin: 0 auto; }
  .ticker-item { display: flex; flex-direction: column; align-items: center; gap: 4px; }
  .ticker-label { font-size: 12px; letter-spacing: 0.25em; color: var(--muted); text-transform: uppercase; }
  .ticker-value { color: var(--white); font-size: 14px; }
  .ticker-value.up { color: #33ff99; }
  .ticker-value.down { color: #ff3d5a; }

  /* ‚îÄ‚îÄ‚îÄ SECTIONS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
  section { padding: 100px 48px; max-width: 1200px; margin: 0 auto; }
  .section-tag { font-family: 'Share Tech Mono', monospace; font-size: 13px; letter-spacing: 0.4em; color: var(--accent); text-transform: uppercase; margin-bottom: 24px; display: block; }
  .section-title { font-family: 'Syne', sans-serif; font-weight: 700; font-size: clamp(36px, 5vw, 60px); color: var(--white); line-height: 1.1; margin-bottom: 24px; }
  .section-body { font-size: 18px; color: var(--text); max-width: 560px; line-height: 1.8; }
  .how-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 72px; align-items: start; margin-top: 72px; }
  .how-steps { display: flex; flex-direction: column; gap: 0; }
  .step { display: flex; gap: 20px; padding: 28px 0; border-bottom: 1px solid rgba(102,51,255,0.1); }
  .step:last-child { border-bottom: none; }
  .step-num { font-family: 'Share Tech Mono', monospace; font-size: 13px; letter-spacing: 0.2em; color: var(--accent); min-width: 40px; padding-top: 4px; }
  .step-content h3 { font-family: 'Syne', sans-serif; font-weight: 700; font-size: 18px; color: var(--white); margin-bottom: 8px; }
  .step-content p { font-size: 16px; color: var(--text); line-height: 1.7; }
  .terminal { background: rgba(7,7,15,0.9); border: 1px solid rgba(102,51,255,0.2); font-family: 'Share Tech Mono', monospace; font-size: 13px; line-height: 1.85; box-shadow: 0 0 60px rgba(102,51,255,0.08), inset 0 0 40px rgba(0,0,0,0.5); }
  .terminal-bar { background: rgba(102,51,255,0.1); border-bottom: 1px solid rgba(102,51,255,0.2); padding: 12px 16px; display: flex; align-items: center; gap: 8px; }
  .terminal-dot { width: 10px; height: 10px; border-radius: 50%; }
  .terminal-dot.red { background: #ff3366; } .terminal-dot.yellow { background: #ffaa00; opacity: 0.5; } .terminal-dot.green { background: #33ff99; opacity: 0.5; }
  .terminal-title { font-size: 12px; letter-spacing: 0.2em; color: var(--muted); margin-left: 8px; text-transform: uppercase; }
  .terminal-body { padding: 20px 24px; }
  .t-comment { color: #666688; } .t-keyword { color: #9966ff; } .t-string { color: #33ccaa; } .t-number { color: #ff9966; } .t-func { color: #99aaff; } .t-var { color: var(--text); } .t-pulse { color: var(--pulse); } .t-line { display: block; padding: 1px 0; }
  .cursor { display: inline-block; width: 8px; height: 13px; background: var(--accent); vertical-align: middle; animation: cursor-blink 1s step-end infinite; }
  @keyframes cursor-blink { 0%, 100% { opacity: 1; } 50% { opacity: 0; } }
  .token-section { background: linear-gradient(to bottom, transparent, rgba(7,7,15,0.5), transparent); border-top: 1px solid rgba(102,51,255,0.1); border-bottom: 1px solid rgba(102,51,255,0.1); }
  .token-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 1px; background: rgba(102,51,255,0.1); margin-top: 56px; border: 1px solid rgba(102,51,255,0.1); }
  .token-card { background: var(--black); padding: 40px 28px; transition: background 0.3s; position: relative; overflow: hidden; }
  .token-card:hover { background: rgba(7,7,15,0.8); }
  .token-card::before { content: ''; position: absolute; top: 0; left: 0; right: 0; height: 1px; background: linear-gradient(to right, transparent, var(--accent), transparent); opacity: 0; transition: opacity 0.3s; }
  .token-card:hover::before { opacity: 1; }
  .token-percent { font-family: 'Syne', sans-serif; font-weight: 800; font-size: 56px; color: var(--white); line-height: 1; margin-bottom: 8px; display: block; }
  .token-percent span { color: var(--accent); font-size: 28px; }
  .token-name { font-family: 'Share Tech Mono', monospace; font-size: 13px; letter-spacing: 0.3em; color: var(--accent); text-transform: uppercase; margin-bottom: 12px; display: block; }
  .token-desc { font-size: 15px; color: var(--text); line-height: 1.7; }
  .manifesto { text-align: center; padding: 140px 48px; position: relative; overflow: hidden; }
  .manifesto-bg { position: absolute; inset: 0; background: radial-gradient(ellipse 50% 70% at 50% 50%, rgba(102,51,255,0.06) 0%, transparent 70%); pointer-events: none; }
  .manifesto blockquote { font-family: 'Cormorant Garamond', serif; font-size: clamp(26px, 3.5vw, 48px); font-style: italic; font-weight: 400; color: var(--white); line-height: 1.4; max-width: 840px; margin: 0 auto 40px; position: relative; }
  .manifesto blockquote::before { content: '"'; font-size: 180px; color: rgba(102,51,255,0.07); position: absolute; top: -60px; left: -40px; line-height: 1; }
  .manifesto-attr { font-family: 'Share Tech Mono', monospace; font-size: 14px; letter-spacing: 0.4em; color: var(--accent); text-transform: uppercase; }
  .roadmap-grid { margin-top: 56px; display: grid; grid-template-columns: 1fr 1fr; gap: 20px; }
  .road-card { background: rgba(7,7,15,0.6); border: 1px solid rgba(119,68,255,0.15); padding: 36px 32px; transition: border-color 0.3s; }
  .road-card:hover { border-color: rgba(119,68,255,0.4); }
  .road-badge { display: inline-block; font-family: 'Share Tech Mono', monospace; font-size: 12px; letter-spacing: 0.2em; text-transform: uppercase; padding: 5px 14px; border: 1px solid rgba(119,68,255,0.3); color: var(--muted); margin-bottom: 16px; }
  .road-card h3 { font-family: 'Syne', sans-serif; font-weight: 700; font-size: 22px; color: var(--white); margin-bottom: 6px; }
  .road-card .road-when { font-family: 'Share Tech Mono', monospace; font-size: 13px; color: var(--accent); margin-bottom: 16px; display: block; }
  .road-card ul { list-style: none; display: flex; flex-direction: column; gap: 10px; }
  .road-card li { font-family: 'Syne', sans-serif; font-size: 15px; color: var(--text); display: flex; gap: 10px; align-items: baseline; line-height: 1.5; }
  .road-card li::before { content: '‚Üí'; color: var(--accent); font-weight: 700; flex-shrink: 0; }
  .actions-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 40px; margin-top: 56px; }
  .action-col h3 { font-family: 'Share Tech Mono', monospace; font-size: 13px; letter-spacing: 0.3em; color: var(--accent); text-transform: uppercase; margin-bottom: 20px; padding-bottom: 12px; border-bottom: 1px solid rgba(119,68,255,0.2); }
  .action-item { display: flex; gap: 14px; align-items: baseline; padding: 10px 0; }
  .action-icon { font-size: 18px; flex-shrink: 0; }
  .action-text { font-size: 16px; color: var(--text); line-height: 1.6; }
  .action-text span { color: var(--muted); font-size: 14px; }
  .faq-list { margin-top: 56px; max-width: 800px; }
  .faq-item { border-bottom: 1px solid rgba(119,68,255,0.12); }
  .faq-q { font-family: 'Syne', sans-serif; font-weight: 700; font-size: 18px; color: var(--white); padding: 24px 0; cursor: pointer; display: flex; justify-content: space-between; align-items: center; transition: color 0.3s; }
  .faq-q:hover { color: var(--accent); }
  .faq-q::after { content: '+'; font-family: 'Share Tech Mono', monospace; font-size: 22px; color: var(--accent); transition: transform 0.3s; }
  .faq-item.open .faq-q::after { content: '‚àí'; }
  .faq-a { max-height: 0; overflow: hidden; transition: max-height 0.4s ease, padding 0.4s ease; }
  .faq-item.open .faq-a { max-height: 300px; padding-bottom: 24px; }
  .faq-a p { font-size: 16px; color: var(--text); line-height: 1.7; }
  .cta-section { text-align: center; padding: 140px 48px; border-top: 1px solid rgba(102,51,255,0.1); position: relative; overflow: hidden; isolation: isolate; }
  .cta-section::before { content: ''; position: absolute; inset: 0; background: radial-gradient(ellipse 60% 80% at 50% 100%, rgba(102,51,255,0.08) 0%, transparent 70%); pointer-events: none; }
  .cta-title { font-family: 'Syne', sans-serif; font-weight: 800; font-size: clamp(48px, 8vw, 96px); color: var(--white); line-height: 1; margin-bottom: 28px; position: relative; }
  .cta-sub { font-size: 20px; color: var(--text); max-width: 440px; margin: 0 auto 48px; }
  footer { border-top: 1px solid rgba(102,51,255,0.1); padding: 36px 48px; display: flex; justify-content: space-between; align-items: center; }
  .footer-logo { font-family: 'Syne', sans-serif; font-weight: 800; letter-spacing: 0.3em; color: var(--muted); font-size: 14px; }
  .footer-mono { font-family: 'Share Tech Mono', monospace; font-size: 12px; letter-spacing: 0.2em; color: #555570; text-transform: uppercase; }
  @keyframes fade-up { from { opacity: 0; transform: translateY(24px); } to { opacity: 1; transform: translateY(0); } }
  .reveal { opacity: 0; transform: translateY(32px); transition: opacity 0.8s ease, transform 0.8s ease; }
  .reveal.visible { opacity: 1; transform: translateY(0); }
  .ghost-watermark { position: fixed; bottom: -80px; right: -80px; font-family: 'Syne', sans-serif; font-weight: 800; font-size: 300px; color: rgba(102,51,255,0.02); letter-spacing: -0.05em; pointer-events: none; z-index: 0; user-select: none; }
  .notif { position: fixed; bottom: 32px; left: 50%; transform: translateX(-50%) translateY(30px); background: #0d0d1a; border: 1px solid rgba(102,51,255,0.3); color: var(--white); font-family: 'Share Tech Mono', monospace; font-size: 14px; letter-spacing: 0.08em; padding: 16px 32px; z-index: 99999; opacity: 0; transition: all 0.35s cubic-bezier(0.34,1.56,0.64,1); pointer-events: none; white-space: nowrap; box-shadow: 0 8px 32px rgba(0,0,0,0.4); }
  .notif.show { transform: translateX(-50%) translateY(0); opacity: 1; }
  .notif.green { border-color: #33ff99; color: #33ff99; background: rgba(51,255,153,0.07); box-shadow: 0 8px 32px rgba(51,255,153,0.15); }
  .notif.error { border-color: #ff3d5a; color: #ff3d5a; background: rgba(255,61,90,0.07); }
  .notif.info { border-color: #7744ff; color: #9966ff; }

  /* ‚îÄ‚îÄ‚îÄ WALLET MODAL ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
  .modal-overlay { display: none; position: fixed; inset: 0; background: rgba(0,0,0,0.85); z-index: 500; justify-content: center; align-items: center; backdrop-filter: blur(4px); }
  .modal-overlay.open { display: flex; }
  .modal { background: var(--deep); border: 1px solid rgba(102,51,255,0.3); padding: 48px; max-width: 420px; width: 90%; position: relative; }
  .modal-close { position: absolute; top: 16px; right: 20px; background: none; border: none; color: var(--muted); font-size: 20px; cursor: pointer; font-family: 'Share Tech Mono', monospace; }
  .modal-close:hover { color: var(--white); }
  .modal h3 { font-family: 'Syne', sans-serif; font-weight: 700; font-size: 24px; color: var(--white); margin-bottom: 8px; }
  .modal p { font-size: 14px; color: var(--text); margin-bottom: 32px; }
  .wallet-option { display: flex; align-items: center; gap: 16px; padding: 16px 20px; border: 1px solid rgba(102,51,255,0.15); margin-bottom: 12px; cursor: pointer; transition: all 0.2s; background: rgba(102,51,255,0.03); }
  .wallet-option:hover { border-color: var(--accent); background: rgba(102,51,255,0.08); }
  .wallet-option .w-icon { font-size: 24px; }
  .wallet-option .w-name { font-family: 'Share Tech Mono', monospace; font-size: 13px; letter-spacing: 0.15em; color: var(--white); }
  .wallet-option .w-desc { font-family: 'Share Tech Mono', monospace; font-size: 12px; color: var(--muted); margin-top: 2px; }

  /* ‚îÄ‚îÄ‚îÄ DASHBOARD PANEL ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
  /* Uses display:none/flex instead of transform to avoid fixed-position bugs */
  .dashboard-panel {
    position: fixed;
    top: 0; left: 0;
    width: 100vw; height: 100vh;
    z-index: 9999;
    background: #030305;
    flex-direction: column;
    overflow: hidden;
    display: flex;
    /* Off-screen when closed ‚Äî GPU composited, never discarded, no paint on return */
    transform: translateX(100vw);
    will-change: transform;
    transition: transform 0.18s cubic-bezier(0.4,0,0.2,1);
    pointer-events: none;
  }
  .dashboard-panel.open {
    transform: translateX(0);
    pointer-events: auto;
  }

  /* Panel topbar */
  .panel-topbar {
    flex-shrink: 0;
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 0 24px;
    height: 60px;
    background: rgba(3,3,5,0.98);
    border-bottom: 1px solid rgba(102,51,255,0.12);
  }

  .panel-back {
    font-family: 'Share Tech Mono', monospace;
    font-size: 13px;
    letter-spacing: 0.15em;
    color: #9090a8;
    background: none;
    border: 1px solid rgba(102,51,255,0.12);
    padding: 9px 18px;
    cursor: pointer;
    text-transform: uppercase;
    transition: all 0.2s;
    display: flex; align-items: center; gap: 8px;
  }
  .panel-back:hover { border-color: #7744ff; color: #9966ff; }

  .panel-logo {
    font-family: 'Syne', sans-serif; font-weight: 800;
    font-size: 18px; letter-spacing: 0.2em; color: #f0f0f8;
  }
  .panel-logo span { color: #7744ff; }

  .panel-wallet {
    font-family: 'Share Tech Mono', monospace;
    font-size: 13px; letter-spacing: 0.08em; color: #33ff99;
    display: flex; align-items: center; gap: 8px;
  }
  .panel-wallet-dot {
    width: 6px; height: 6px; border-radius: 50%;
    background: #33ff99;
    animation: pulse-dot 2s ease-in-out infinite;
  }

  /* Panel body = sidebar + main */
  .panel-body {
    flex: 1;
    min-height: 0;
    display: flex;
    overflow: hidden;
  }

  /* Sidebar */
  .panel-sidebar {
    width: 230px;
    flex-shrink: 0;
    background: #05050d;
    border-right: 1px solid rgba(102,51,255,0.15);
    padding: 20px 0;
    display: flex;
    flex-direction: column;
    overflow-y: auto;
  }

  .sidebar-section-label {
    font-family: 'Share Tech Mono', monospace;
    font-size: 11px; letter-spacing: 0.2em;
    color: rgba(150,100,255,0.7);
    text-transform: uppercase;
    padding: 14px 18px 6px;
  }

  .db-nav-item {
    display: flex; align-items: center; gap: 10px;
    padding: 11px 18px;
    font-family: 'Share Tech Mono', monospace;
    font-size: 13px; letter-spacing: 0.03em;
    color: #b0b0c8;
    cursor: pointer;
    transition: all 0.2s;
    border-left: 2px solid transparent;
    user-select: none;
  }
  .db-nav-item:hover { color: #f0f0f8; background: rgba(102,51,255,0.07); }
  .db-nav-item.active { color: #c0a0ff; background: rgba(102,51,255,0.1); border-left-color: #7744ff; }
  .db-nav-icon { font-size: 16px; width: 20px; text-align: center; }

  .sidebar-footer-info {
    margin-top: auto;
    padding: 18px;
    border-top: 1px solid rgba(102,51,255,0.15);
    font-family: 'Share Tech Mono', monospace;
    font-size: 12px; color: #9090a8; line-height: 2.2;
    letter-spacing: 0.05em;
  }
  .sidebar-footer-info .sv { color: #a080ff; font-size: 15px; display: block; }

  /* Dashboard main content */
  .panel-main {
    flex: 1;
    min-width: 0;
    overflow-y: auto;
    overflow-x: hidden;
    padding: 30px;
  }

  .db-page { display: none; }
  .db-page.active { display: block; }

  /* Status hero */
  .status-hero {
    background: #0d0d1e;
    border: 1px solid rgba(102,51,255,0.15);
    padding: 28px; margin-bottom: 20px;
    display: flex; flex-wrap: wrap;
    gap: 20px; align-items: center;
    justify-content: space-between;
    position: relative; overflow: hidden;
  }
  .status-hero::before {
    content: ''; position: absolute;
    top: -40px; right: -40px;
    width: 200px; height: 200px; border-radius: 50%;
    background: radial-gradient(circle, rgba(102,51,255,0.06) 0%, transparent 70%);
    pointer-events: none;
  }

  .status-eyebrow {
    font-family: 'Share Tech Mono', monospace;
    font-size: 12px; letter-spacing: 0.2em;
    color: #b0b0c8; text-transform: uppercase;
    margin-bottom: 8px;
    display: flex; align-items: center; gap: 6px;
  }
  .status-eyebrow::before { content: '‚óà'; color: #7744ff; font-size: 7px; }

  .status-value {
    font-family: 'Cormorant Garamond', serif;
    font-size: 56px; font-weight: 300; line-height: 1;
    color: #f0f0f8; margin-bottom: 14px; letter-spacing: -0.01em;
  }
  .status-value.alive { color: #33ff99; }
  .status-value.awakened { color: #ffb830; }

  .status-meta { display: flex; gap: 24px; flex-wrap: wrap; }
  .status-meta-item label {
    font-family: 'Share Tech Mono', monospace;
    font-size: 11px; letter-spacing: 0.15em;
    color: #9090b8; text-transform: uppercase; display: block; margin-bottom: 2px;
  }
  .status-meta-item span {
    font-family: 'Share Tech Mono', monospace; font-size: 14px; color: #e8e8f8;
  }

  /* Heartbeat orb */
  .hb-orb-wrap { position: relative; width: 100px; height: 100px; flex-shrink: 0; }
  .hb-orb-ring {
    position: absolute; inset: 0; border-radius: 50%;
    border: 1px solid rgba(102,51,255,0.2);
    animation: hb-ring-expand 3s ease-in-out infinite;
  }
  .hb-orb-ring:nth-child(2) { animation-delay: 1s; opacity: 0.5; }
  @keyframes hb-ring-expand {
    0%{transform:scale(0.7);opacity:0.6} 100%{transform:scale(1.5);opacity:0}
  }
  .hb-orb-center {
    position: absolute; top:50%; left:50%;
    transform: translate(-50%,-50%);
    width: 52px; height: 52px; border-radius: 50%;
    background: radial-gradient(circle, rgba(102,51,255,0.3) 0%, rgba(102,51,255,0.05) 100%);
    border: 1px solid rgba(102,51,255,0.4);
    display: flex; align-items: center; justify-content: center;
    font-size: 20px; cursor: pointer; transition: all 0.25s;
  }
  .hb-orb-center:hover { box-shadow: 0 0 24px rgba(102,51,255,0.4); }
  .hb-orb-center.beat { animation: orb-beat 0.5s ease-in-out; }
  @keyframes orb-beat {
    0%{transform:translate(-50%,-50%) scale(1)}
    40%{transform:translate(-50%,-50%) scale(1.25)}
    100%{transform:translate(-50%,-50%) scale(1)}
  }

  .hb-orb-label {
    font-family: 'Share Tech Mono', monospace; font-size: 12px;
    color: #b0b0c8; text-align: center; margin-top: 8px; letter-spacing: 0.05em;
  }
  .hb-orb-label strong { display: block; font-size: 17px; color: #f0f0f8; margin-bottom: 2px; }

  /* Stats cards */
  .db-cards {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(160px, 1fr));
    gap: 12px; margin-bottom: 20px;
  }
  .db-card {
    background: #0d0d1e; border: 1px solid rgba(102,51,255,0.15);
    padding: 20px 18px; transition: border-color 0.2s;
  }
  .db-card:hover { border-color: rgba(102,51,255,0.35); }
  .db-card-label { font-family: 'Share Tech Mono', monospace; font-size: 12px; letter-spacing: 0.15em; color: #b0b0c8; text-transform: uppercase; margin-bottom: 8px; }
  .db-card-value { font-family: 'Syne', sans-serif; font-weight: 700; font-size: 28px; color: #f0f0f8; line-height: 1; }
  .db-card-sub { font-family: 'Share Tech Mono', monospace; font-size: 12px; color: #8888aa; margin-top: 4px; }

  /* Progress bar */
  .db-progress { background: #0d0d1e; border: 1px solid rgba(102,51,255,0.15); padding: 18px; margin-bottom: 20px; }
  .db-progress-header { display: flex; justify-content: space-between; margin-bottom: 12px; }
  .db-progress-label { font-family: 'Share Tech Mono', monospace; font-size: 12px; letter-spacing: 0.15em; color: #b0b0c8; text-transform: uppercase; }
  .db-progress-val { font-family: 'Share Tech Mono', monospace; font-size: 13px; color: #d0d0e8; }
  .db-progress-bar { height: 4px; background: rgba(102,51,255,0.12); border-radius: 2px; }
  .db-progress-fill { height: 100%; background: linear-gradient(90deg, #4422cc, #9966ff); transition: width 0.5s; border-radius: 2px; }
  .db-progress-fill.warn { background: linear-gradient(90deg, #ff3d5a, #ff3366); }

  /* Alert */
  .db-alert { padding: 16px 20px; border-left: 3px solid #ffb830; background: rgba(255,184,48,0.06); font-family: 'Share Tech Mono', monospace; font-size: 14px; color: #ffcc55; line-height: 1.7; margin-bottom: 20px; display: none; }
  .db-alert.visible { display: block; }

  /* Section headers */
  .db-section-header { display: flex; align-items: center; justify-content: space-between; margin-bottom: 14px; }
  .db-section-title { font-family: 'Share Tech Mono', monospace; font-size: 13px; letter-spacing: 0.2em; color: #b0b0c8; text-transform: uppercase; display: flex; align-items: center; gap: 8px; }
  .db-section-title::before { content: ''; width: 12px; height: 1px; background: #7744ff; }

  /* Table */
  .db-table { width: 100%; border-collapse: collapse; }
  .db-table th { font-family: 'Share Tech Mono', monospace; font-size: 12px; letter-spacing: 0.15em; color: #8888bb; text-transform: uppercase; text-align: left; padding: 10px 14px; border-bottom: 1px solid rgba(102,51,255,0.15); }
  .db-table td { padding: 14px 14px; border-bottom: 1px solid rgba(102,51,255,0.06); font-family: 'Share Tech Mono', monospace; font-size: 13px; color: #d0d0e8; }
  .db-table tr:hover td { background: rgba(102,51,255,0.04); }
  .db-table tr:last-child td { border-bottom: none; }
  .addr-short { color: #8888aa; }

  /* Tags */
  .tag { display: inline-block; font-family: 'Share Tech Mono', monospace; font-size: 11px; letter-spacing: 0.1em; text-transform: uppercase; padding: 3px 8px; border: 1px solid currentColor; }
  .tag-transfer { color: #9966ff; }
  .tag-burn { color: #ff3366; }
  .tag-pending { color: #9090a8; }
  .tag-ready { color: #33ff99; border-color: rgba(51,255,153,0.4); }
  .tag-done { color: #33ff99; }

  /* Forms */
  .db-form { background: #0d0d1e; border: 1px solid rgba(102,51,255,0.15); padding: 24px; margin-bottom: 16px; }
  .db-form-title { font-family: 'Syne', sans-serif; font-size: 15px; font-weight: 700; letter-spacing: 0.05em; color: #c0a0ff; margin-bottom: 16px; padding-bottom: 12px; border-bottom: 1px solid rgba(102,51,255,0.12); }
  .db-form-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 14px; margin-bottom: 16px; }
  .db-form-group { display: flex; flex-direction: column; gap: 6px; }
  .db-form-group label { font-family: 'Share Tech Mono', monospace; font-size: 12px; letter-spacing: 0.15em; color: #b0b0c8; text-transform: uppercase; }
  .db-form-group input, .db-form-group select { background: #07070f; border: 1px solid rgba(102,51,255,0.2); color: #e8e8f4; font-family: 'Share Tech Mono', monospace; font-size: 14px; padding: 12px 14px; outline: none; transition: border-color 0.2s; -webkit-appearance: none; width: 100%; }
  .db-form-group input:focus, .db-form-group select:focus { border-color: #7744ff; }
  .db-form-group input::placeholder { color: rgba(120,80,255,0.35); }
  .db-form-group select option { background: #07070f; }

  /* Buttons */
  .db-btn { font-family: 'Share Tech Mono', monospace; font-size: 13px; letter-spacing: 0.15em; text-transform: uppercase; padding: 12px 24px; border: none; cursor: pointer; transition: all 0.2s; display: inline-flex; align-items: center; gap: 8px; }
  .db-btn-primary { background: #7744ff; color: #f0f0f8; }
  .db-btn-primary:hover { background: #9966ff; box-shadow: 0 0 20px rgba(102,51,255,0.35); }
  .db-btn-outline { background: transparent; border: 1px solid rgba(102,51,255,0.2); color: #d0d0e8; }
  .db-btn-outline:hover { border-color: rgba(102,51,255,0.5); color: #b090ff; }
  .db-btn-danger { background: transparent; border: 1px solid rgba(255,61,90,0.3); color: #ff6080; }
  .db-btn-danger:hover { background: rgba(255,61,90,0.08); border-color: #ff3d5a; }
  .db-btn-green { background: #33ff99; color: #030305; font-weight: 700; }
  .db-btn-green:hover { box-shadow: 0 0 20px rgba(51,255,153,0.3); }

  .icon-btn { background: none; border: 1px solid rgba(102,51,255,0.15); color: #9090a8; font-size: 12px; padding: 4px 8px; cursor: pointer; transition: all 0.2s; }
  .icon-btn:hover { border-color: #ff3d5a; color: #ff3d5a; }

  /* Watcher result */
  .watcher-result { display: none; margin-top: 14px; padding: 18px; background: #07070f; border: 1px solid rgba(102,51,255,0.15); font-family: 'Share Tech Mono', monospace; font-size: 14px; line-height: 2; color: #c0c0d8; }
  .watcher-result.visible { display: block; }

  /* Info box */
  .db-info { padding: 14px 18px; border-left: 3px solid rgba(102,51,255,0.6); background: rgba(102,51,255,0.06); font-family: 'Share Tech Mono', monospace; font-size: 13px; color: #c0c0d8; line-height: 1.8; margin-bottom: 16px; }
  .db-info strong { color: #e8e8f8; }

  /* Ping ripple */
  .ping-ripple { position: fixed; inset: 0; pointer-events: none; z-index: 10000; display: none; align-items: center; justify-content: center; }
  .ping-ripple.active { display: flex; }
  .ping-ripple-ring { position: absolute; width: 80px; height: 80px; border-radius: 50%; border: 2px solid #7744ff; animation: ripple-out 1s ease-out forwards; }
  .ping-ripple-ring:nth-child(2) { animation-delay: 0.12s; }
  .ping-ripple-ring:nth-child(3) { animation-delay: 0.24s; }
  @keyframes ripple-out { from{transform:scale(0.5);opacity:0.8} to{transform:scale(10);opacity:0} }
  @keyframes ghost-fly-up {
    0%   { transform: translateY(0) scale(1);   opacity: 1; filter: drop-shadow(0 0 20px rgba(102,51,255,0.8)); }
    20%  { transform: translateY(-30px) scale(1.05); opacity: 1; filter: drop-shadow(0 0 40px rgba(102,51,255,1)); }
    50%  { transform: translateY(-120px) scale(0.9); opacity: 0.8; filter: drop-shadow(0 0 60px rgba(200,100,255,0.9)); }
    80%  { transform: translateY(-280px) scale(0.5); opacity: 0.4; filter: drop-shadow(0 0 80px rgba(255,255,255,0.5)); }
    100% { transform: translateY(-500px) scale(0.1); opacity: 0; filter: drop-shadow(0 0 0px transparent); }
  }
  @keyframes ghost-wobble {
    0%,100% { transform: translateX(0) rotate(0deg); }
    20%  { transform: translateX(-8px) rotate(-5deg); }
    40%  { transform: translateX(8px) rotate(5deg); }
    60%  { transform: translateX(-5px) rotate(-3deg); }
    80%  { transform: translateX(5px) rotate(3deg); }
  }
  @keyframes burn-flash {
    0%   { background: rgba(255,80,40,0); }
    15%  { background: rgba(255,80,40,0.3); }
    30%  { background: rgba(255,120,0,0.15); }
    50%  { background: rgba(200,0,200,0.2); }
    70%  { background: rgba(100,0,255,0.15); }
    100% { background: rgba(102,51,255,0); }
  }
  @keyframes particle-burst {
    0%   { transform: translate(0,0) scale(1); opacity: 1; }
    100% { transform: var(--tx, 80px) var(--ty, -120px) scale(0); opacity: 0; }
  }
  @keyframes aftermath-fade-in {
    from { opacity: 0; transform: translateY(20px); }
    to   { opacity: 1; transform: translateY(0); }
  }
  .ghost-abandon-overlay {
    position: fixed; inset: 0; z-index: 100001; display: flex; align-items: center; justify-content: center;
    background: rgba(5,5,15,0.85); backdrop-filter: blur(8px);
    animation: burn-flash 1.2s ease-out;
  }
  .ghost-fly-char {
    font-size: 80px; line-height: 1; display: block;
    animation: ghost-wobble 0.4s ease-in-out 0.1s 2, ghost-fly-up 1.6s ease-in 0.8s forwards;
    filter: drop-shadow(0 0 20px rgba(102,51,255,0.8));
    transform-origin: center bottom;
  }
  .particle {
    position: absolute; width: 8px; height: 8px; border-radius: 50%;
    animation: particle-burst 1.2s ease-out forwards;
  }


  /* Custom token picker */
  .token-picker { position: relative; }
  .token-picker-btn {
    width: 100%; background: #07070f; border: 1px solid rgba(102,51,255,0.2);
    color: #e0e0ec; font-family: 'Share Tech Mono', monospace; font-size: 13px;
    padding: 11px 14px; cursor: pointer; text-align: left; display: flex;
    align-items: center; gap: 10px; justify-content: space-between; transition: border-color 0.2s;
  }
  .token-picker-btn:hover, .token-picker-btn.open { border-color: #7744ff; }
  .token-picker-btn .tp-left { display: flex; align-items: center; gap: 10px; }
  .token-picker-btn .tp-symbol { font-size: 14px; font-weight: 700; color: #f0f0f8; }
  .token-picker-btn .tp-bal { font-size: 11px; color: var(--muted); }
  .token-picker-btn .tp-arrow { color: var(--muted); font-size: 10px; transition: transform 0.2s; }
  .token-picker-btn.open .tp-arrow { transform: rotate(180deg); }
  .token-picker-dropdown {
    position: absolute; top: calc(100% + 4px); left: 0; right: 0;
    background: #07070f; border: 1px solid rgba(102,51,255,0.2); z-index: 200;
    max-height: 220px; overflow-y: auto;
    opacity: 0; pointer-events: none; transform: translateY(-4px);
    transition: opacity 0.12s ease, transform 0.12s ease;
  }
  .token-picker-dropdown.open { opacity: 1; pointer-events: auto; transform: translateY(0); }
  .token-picker-option {
    display: flex; align-items: center; gap: 12px; padding: 11px 14px;
    cursor: pointer; border-bottom: 1px solid rgba(102,51,255,0.06);
    transition: background 0.15s; font-family: 'Share Tech Mono', monospace;
  }
  .token-picker-option:hover { background: rgba(102,51,255,0.08); }
  .token-picker-option:last-child { border-bottom: none; }
  .tp-opt-icon { width: 32px; height: 32px; border-radius: 50%; background: rgba(102,51,255,0.15); display: flex; align-items: center; justify-content: center; font-size: 14px; flex-shrink: 0; }
  .tp-opt-info { flex: 1; }
  .tp-opt-symbol { font-size: 13px; color: #f0f0f8; font-weight: 700; }
  .tp-opt-bal { font-size: 11px; color: var(--muted); margin-top: 1px; }
  .tp-opt-check { color: #33ff99; font-size: 14px; }

  /* Current settings display */
  .settings-current {
    display: flex; gap: 0; margin-bottom: 20px;
    border: 1px solid rgba(102,51,255,0.15); overflow: hidden;
  }
  .settings-current-item {
    flex: 1; padding: 20px;
    border-right: 1px solid rgba(102,51,255,0.12);
  }
  .settings-current-item:last-child { border-right: none; }
  .settings-current-label { font-family: 'Share Tech Mono', monospace; font-size: 11px; letter-spacing: 0.18em; color: #b0b0c8; text-transform: uppercase; margin-bottom: 8px; }
  .settings-current-value { font-family: 'Syne', sans-serif; font-weight: 700; font-size: 30px; color: #f0f0f8; line-height: 1; }
  .settings-current-sub { font-family: 'Share Tech Mono', monospace; font-size: 12px; color: #a080ff; margin-top: 5px; }

  /* Vault asset row */
  .vault-asset-row {
    display: flex; align-items: center; gap: 16px;
    padding: 16px 20px; border-bottom: 1px solid rgba(102,51,255,0.08);
    background: #0d0d1e;
  }
  .vault-asset-row:last-child { border-bottom: none; }
  .vault-asset-icon { width: 40px; height: 40px; border-radius: 50%; background: rgba(102,51,255,0.15); display: flex; align-items: center; justify-content: center; font-size: 18px; flex-shrink: 0; }
  .vault-asset-info { flex: 1; }
  .vault-asset-symbol { font-family: 'Syne', sans-serif; font-weight: 700; font-size: 16px; color: #f0f0f8; }
  .vault-asset-bal { font-family: 'Share Tech Mono', monospace; font-size: 13px; color: #b0b0c8; margin-top: 3px; }
  .vault-asset-actions { display: flex; align-items: center; gap: 8px; }
  .vault-asset-input { background: #07070f; border: 1px solid rgba(102,51,255,0.2); color: #e8e8f4; font-family: 'Share Tech Mono', monospace; font-size: 13px; padding: 8px 12px; width: 110px; outline: none; }
  .vault-asset-input:focus { border-color: #7744ff; }

  /* Burn option */
  .burn-section { background: rgba(255,61,90,0.03); border: 1px solid rgba(255,61,90,0.15); padding: 20px; margin-bottom: 16px; }
  .burn-section .db-form-title { color: var(--red); }

  /* Locked nav */
  .db-nav-locked { opacity: 0.3; pointer-events: none; }
  /* Init ghost page */
  .init-hero { text-align:center; padding:48px 24px 32px; background:radial-gradient(ellipse at 50% 0%,rgba(102,51,255,0.08) 0%,transparent 70%); border:1px solid rgba(102,51,255,0.15); margin-bottom:24px; }
  .init-ghost-icon { font-size:72px; line-height:1; margin-bottom:16px; filter:drop-shadow(0 0 24px rgba(102,51,255,0.4)); }
  .init-title { font-family:'Syne',sans-serif; font-weight:800; font-size:30px; color:#f0f0f8; margin-bottom:8px; }
  .init-sub { font-family:'Share Tech Mono',monospace; font-size:13px; color:#b0b0c8; line-height:1.8; }

  /* Page title */
  /* Page title */
  .db-page-title { font-family: 'Cormorant Garamond', serif; font-size: 32px; font-weight: 300; color: #f0f0f8; margin-bottom: 4px; }
  .db-page-sub { font-family: 'Share Tech Mono', monospace; font-size: 11px; letter-spacing: 0.18em; color: #9090b8; text-transform: uppercase; margin-bottom: 24px; }

    @media (max-width: 800px) {
    .panel-body { flex-direction: column; }
    .panel-sidebar { display: none !important; }
    .db-cards { grid-template-columns: 1fr 1fr; }
    .status-hero { grid-template-columns: 1fr; }
    .how-grid { grid-template-columns: 1fr; }
    .roadmap-grid { grid-template-columns: 1fr; }
    .actions-grid { grid-template-columns: 1fr; }
  }
</style>
<!-- Solana Web3.js - loaded async so it doesn't block page -->
<script>
  var solanaWeb3 = null;
  var web3Script = document.createElement('script');
  web3Script.src = 'https://cdn.jsdelivr.net/npm/@solana/web3.js@latest/lib/index.iife.min.js';
  web3Script.onload = function() {
    solanaWeb3 = window.solanaWeb3;
    console.log('Solana web3.js loaded:', !!solanaWeb3);
    // Retry token metadata fetch now that we have proper PDA derivation
    pumpFunFetched.clear();
    setTimeout(fetchPumpFunData, 500);
  };
  web3Script.onerror = function() {
    console.warn('Solana web3.js failed to load - demo mode only');
  };
  document.head.appendChild(web3Script);
</script>
</head>
<body>

<div class="ghost-watermark">G</div>
<div class="notif" id="notif"></div>

<!-- ‚îÄ‚îÄ‚îÄ WALLET MODAL ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ -->
<div class="modal-overlay" id="walletModal">
  <div class="modal">
    <button class="modal-close" onclick="closeModal()">‚úï</button>
    <h3>Connect Wallet</h3>
    <p>Choose your Solana wallet to register your heartbeat.</p>
    <div class="wallet-option" onclick="connectWallet('Phantom')">
      <span class="w-icon">üëª</span>
      <div><div class="w-name">Phantom</div><div class="w-desc">Most popular Solana wallet</div></div>
    </div>
    <div class="wallet-option" onclick="connectWallet('Solflare')">
      <span class="w-icon">üîÜ</span>
      <div><div class="w-name">Solflare</div><div class="w-desc">Built for Solana power users</div></div>
    </div>
    <div class="wallet-option" onclick="connectWallet('Backpack')">
      <span class="w-icon">üéí</span>
      <div><div class="w-name">Backpack</div><div class="w-desc">xNFT wallet by Coral</div></div>
    </div>
  </div>
</div>

<!-- ‚îÄ‚îÄ‚îÄ DASHBOARD PANEL ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ -->
<div class="dashboard-panel" id="dashboardPanel">

  <div class="panel-topbar">
    <button class="panel-back" onclick="closeDashboard()">‚Üê Back to site</button>
    <div class="panel-logo">GH<span>O</span>ST <span style="font-family:'Share Tech Mono',monospace;font-size:11px;letter-spacing:0.15em;color:#c0bce0">‚Äî VAULT</span></div>
    <div class="panel-wallet" style="display:flex;align-items:center;gap:10px">
      <span class="panel-wallet-dot"></span>
      <span id="panelWalletAddr">4xKm...9nZq</span>
      <button onclick="disconnectWallet()" title="Disconnect wallet" style="font-family:'Share Tech Mono',monospace;font-size:11px;letter-spacing:0.08em;color:#ff6666;background:none;border:1px solid rgba(255,102,102,0.3);padding:4px 10px;cursor:pointer;transition:all 0.2s;white-space:nowrap" onmouseover="this.style.background='rgba(255,102,102,0.1)'" onmouseout="this.style.background='none'">‚èª Disconnect</button>
    </div>
  </div>

  <div class="panel-body">

    <!-- Sidebar -->
    <div class="panel-sidebar">
      <div class="sidebar-section-label">Vault</div>
      <div class="db-nav-item active" id="nav-overview" onclick="dbShowPage('overview', this)"><span class="db-nav-icon">üëª</span>Overview</div>
      <div class="db-nav-item db-nav-locked" id="nav-vault" onclick="dbShowPage('vault', this)"><span class="db-nav-icon">üîí</span>Vault Assets</div>
      <div class="db-nav-item db-nav-locked" id="nav-beneficiaries" onclick="dbShowPage('beneficiaries', this)"><span class="db-nav-icon">üìã</span>Beneficiaries</div>
      <div class="sidebar-section-label" style="margin-top:6px">Settings</div>
      <div class="db-nav-item db-nav-locked" id="nav-heartbeat" onclick="dbShowPage('heartbeat', this)"><span class="db-nav-icon">üíì</span>Heartbeat</div>
      <div class="db-nav-item db-nav-locked" id="nav-recovery" onclick="dbShowPage('recovery', this)"><span class="db-nav-icon">üîë</span>Recovery</div>
      <div class="db-nav-item db-nav-locked" id="nav-settings" onclick="dbShowPage('settings', this)"><span class="db-nav-icon">‚öôÔ∏è</span>Settings</div>
      <div class="sidebar-section-label" style="margin-top:6px">Protocol</div>
      <div class="db-nav-item" onclick="dbShowPage('watcher', this)"><span class="db-nav-icon">üíì</span>Heartbeat Checker</div>
      <div class="db-nav-item" onclick="closeDashboard()"><span class="db-nav-icon">üåê</span>Back to site</div>
      <div class="db-nav-item" onclick="disconnectWallet()" style="color:#ff6666;margin-top:2px"><span class="db-nav-icon">‚èª</span>Disconnect</div>
      <div class="sidebar-footer-info">
        STAKED<br><span class="sv" id="sidebarStake">‚Äî</span><br>
        PINGS<br><span class="sv" id="sidebarPings">‚Äî</span>
      </div>
    </div>

    <!-- Main content -->
    <main class="panel-main">

      <!-- OVERVIEW -->
      <div class="db-page active" id="db-page-overview">
        <div class="db-page-title">Your Ghost</div>
        <div class="db-page-sub">Vault Status ¬∑ Digital Legacy Protocol</div>

        <div class="db-alert" id="dbAwakeningAlert">
          ‚ö† GHOST AWAKENED ‚Äî Grace period expires in <strong id="dbGraceCountdown">6d 14h</strong>. Ping or cancel to save your ghost.
          <br><div style="display:flex;gap:8px;margin-top:8px">
          <button class="db-btn db-btn-green" onclick="sendPing()">üíì SEND HEARTBEAT</button>
          <button class="db-btn" style="border-color:#ff9966;color:#ff9966" onclick="cancelAwakening()">üõë CANCEL AWAKENING</button>
          </div>
        </div>

        <div class="status-hero">
          <div>
            <div class="status-eyebrow">Current Status</div>
            <div class="status-value alive" id="dbStatusValue">ALIVE</div>
            <div class="status-meta">
              <div class="status-meta-item"><label>Last Ping</label><span id="dbLastPing">‚Äî</span></div>
              <div class="status-meta-item"><label>Interval</label><span id="dbInterval">365 days</span></div>
              <div class="status-meta-item"><label>Grace</label><span id="dbGrace">30 days</span></div>
              <div class="status-meta-item"><label>Registered</label><span>‚Äî</span></div>
            </div>
          </div>
          <div style="display:flex;flex-direction:column;align-items:center;gap:10px">
            <div class="hb-orb-wrap" style="width:130px;height:130px">
              <div class="hb-orb-ring"></div>
              <div class="hb-orb-ring"></div>
              <div class="hb-orb-center" id="hbOrb" onclick="sendPing()" title="Click to ping" style="width:72px;height:72px;font-size:28px">üíì</div>
            </div>
            <div class="hb-orb-label"><strong id="dbCountdown">‚Äî</strong>until deadline</div>
          </div>
        </div>

        <div class="db-progress">
          <div class="db-progress-header">
            <span class="db-progress-label">Heartbeat Window</span>
            <span class="db-progress-val" id="dbProgressVal">‚Äî</span>
          </div>
          <div class="db-progress-bar">
            <div class="db-progress-fill" id="dbProgressFill" style="width:0%"></div>
          </div>
        </div>

        <!-- VAULT OVERVIEW ‚Äî shows all assets -->
        <div class="db-section-header"><div class="db-section-title">üîí Vault</div></div>
        <div id="dbVaultUsdTotal" style="font-family:'Syne',sans-serif;font-weight:800;font-size:32px;color:#33ff99;letter-spacing:-0.02em;padding:18px 20px 4px;line-height:1"></div>
        <div id="dbVaultUsdSub" style="font-family:'Share Tech Mono',monospace;font-size:10px;letter-spacing:0.2em;color:#c0bce0;text-transform:uppercase;padding:0 20px 16px;display:none">Total vault value ¬∑ live prices</div>
        <div id="dbVaultOverview" style="border:1px solid rgba(102,51,255,0.12);margin-bottom:20px">
          <div style="padding:16px 20px;font-family:'Share Tech Mono',monospace;font-size:12px;color:#c0bce0">No assets in vault</div>
        </div>

        <div class="db-cards">
          <div class="db-card"><div class="db-card-label">üìã Beneficiaries</div><div class="db-card-value" id="dbBenefCount">0</div><div class="db-card-sub">of 10 slots</div></div>
          <div class="db-card"><div class="db-card-label">üíì Pings</div><div class="db-card-value" id="dbPingCount">0</div><div class="db-card-sub">total heartbeats</div></div>
          <div class="db-card"><div class="db-card-label">üîë Recovery</div><div class="db-card-value" style="font-size:15px" id="dbRecoveryStatus">NONE</div><div class="db-card-sub" id="dbRecoveryShort">not configured</div></div>
        </div>

        <div class="db-section-header"><div class="db-section-title">Recent Activity</div></div>
        <div class="db-form" style="padding:0">
          <table class="db-table">
            <thead><tr><th>Event</th><th>Time</th><th>Tx</th></tr></thead>
            <tbody id="dbActivityLog">
              <tr><td colspan="3" style="text-align:center;color:#c0bce0">No activity yet</td></tr>
            </tbody>
          </table>
        </div>
      </div>

      <!-- VAULT -->
      <div class="db-page" id="db-page-vault">
        <div class="db-page-title">Vault Assets</div>
        <div class="db-page-sub">Deposit ¬∑ Withdraw ¬∑ Manage</div>

        <!-- DEPOSIT -->
        <div class="db-form">
          <div class="db-form-title">üì• Deposit to Vault</div>
          <div class="db-form-group" style="margin-bottom:14px">
            <label>Select Token from Wallet</label>
            <div class="token-picker" id="depositPicker">
              <button class="token-picker-btn" onclick="toggleTokenPicker('deposit')" type="button">
                <div class="tp-left">
                  <div id="depositPickerLogo" style="width:26px;height:26px;flex-shrink:0"></div>
                  <span class="tp-symbol" id="depositPickerSymbol">Select asset</span>
                  <span class="tp-bal" id="depositPickerBal"></span>
                </div>
                <span class="tp-arrow">‚ñº</span>
              </button>
              <div class="token-picker-dropdown" id="depositPickerDrop"></div>
            </div>
          </div>
          <div class="db-form-grid">
            <div class="db-form-group">
              <label>Amount</label>
              <div style="display:flex;gap:8px;align-items:center">
                <input type="text" id="depositAmtDisplay" placeholder="0" inputmode="decimal" style="flex:1" oninput="formatDepositInput(this)">
                <input type="hidden" id="depositAmt">
                <button class="db-btn db-btn-outline" type="button" style="padding:7px 12px;font-size:11px;white-space:nowrap;flex-shrink:0" onclick="fillMaxDeposit()">MAX</button>
              </div>
            </div>
            <div class="db-form-group"><label>Available in Wallet</label><input type="text" id="depositBalance" value="‚Äî" readonly style="color:#c0bce0"></div>
          </div>
          <div style="display:flex;gap:10px;flex-wrap:wrap">
            <button class="db-btn db-btn-primary" onclick="dbDeposit()">üì• Deposit to Vault</button>
            <button class="db-btn db-btn-outline" onclick="dbDepositAll()" title="Deposit all wallet assets at max balance">üì• Deposit All Assets</button>
          </div>
          <div id="depositWholeVaultNotice" style="display:none;margin-top:12px;padding:10px 14px;background:rgba(102,51,255,0.07);border:1px solid rgba(160,128,255,0.25);font-family:'Share Tech Mono',monospace;font-size:11px;color:#c0a0ff;line-height:1.6">
            üëª <strong style="color:#e0d0ff">Heads up:</strong> Your vault is fully assigned to <span id="depositWholeVaultRecip" style="color:#fff"></span>. Any assets you deposit will be automatically included in their inheritance.
          </div>
        </div>

        <!-- VAULT HOLDINGS + WITHDRAW -->
        <div class="db-section-header">
          <div class="db-section-title">üîí Vault Holdings</div>
          <div style="display:flex;gap:8px;align-items:center">
            <button onclick="dbWithdrawAll()" style="font-family:'Share Tech Mono',monospace;font-size:10px;letter-spacing:0.1em;color:#ff9966;background:none;border:1px solid rgba(255,153,102,0.3);padding:4px 10px;cursor:pointer" title="Withdraw all vault assets">üì§ WITHDRAW ALL</button>
            <button onclick="retryTokenData()" style="font-family:'Share Tech Mono',monospace;font-size:10px;letter-spacing:0.1em;color:#c0bce0;background:none;border:1px solid rgba(102,51,255,0.2);padding:4px 10px;cursor:pointer" title="Re-fetch prices & logos">‚Ü∫ REFRESH</button>
          </div>
        </div>
        <div id="vaultHoldingsUsdTotal" style="font-family:'Syne',sans-serif;font-weight:800;font-size:32px;color:#33ff99;letter-spacing:-0.02em;padding:18px 20px 4px;line-height:1"></div>
        <div id="vaultHoldingsUsdSub" style="font-family:'Share Tech Mono',monospace;font-size:10px;letter-spacing:0.2em;color:#c0bce0;text-transform:uppercase;padding:0 20px 16px;display:none">Total vault value ¬∑ live prices</div>
        <div class="db-info" style="margin-bottom:12px">Each asset can be withdrawn individually back to your wallet. Withdrawals are blocked while your ghost is awakened.</div>
        <div id="vaultHoldingsList" style="border:1px solid rgba(102,51,255,0.12);margin-bottom:20px">
          <div style="padding:24px;text-align:center;font-family:'Share Tech Mono',monospace;font-size:12px;color:#c0bce0">No assets in vault yet.</div>
        </div>
      </div>

      <!-- BENEFICIARIES -->
      <div class="db-page" id="db-page-beneficiaries">
        <div class="db-page-title">Beneficiaries</div>
        <div class="db-page-sub">Who receives your digital legacy when your ghost executes</div>

        <!-- VAULT ALLOCATION OVERVIEW -->
        <div id="beneVaultOverview" style="margin-bottom:20px"></div>

        <!-- BENEFICIARY LIST -->
        <div class="db-section-header">
          <div class="db-section-title">Distribution Plan</div>
          <span style="font-family:'Share Tech Mono',monospace;font-size:12px;color:#c0bce0" id="dbBSlots">0 / 10 slots</span>
        </div>
        <div class="db-form" style="padding:0;margin-bottom:20px">
          <table class="db-table">
            <thead><tr><th>#</th><th>Wallet</th><th>Amount</th><th>Token</th><th>Type</th><th>Status</th><th></th></tr></thead>
            <tbody id="dbBeneficiaryList"><tr><td colspan="7" style="text-align:center;color:#c0bce0;padding:20px">No beneficiaries yet</td></tr></tbody>
          </table>
        </div>

        <!-- ADD SPECIFIC TRANSFER -->
        <div class="db-form">
          <div class="db-form-title">‚ûï Add Transfer</div>
          <div class="db-info">Assign a specific token amount from your vault to a recipient wallet.</div>
          <div class="db-form-group" style="margin-bottom:14px">
            <label>Recipient Wallet Address</label>
            <input type="text" id="newRecipient" placeholder="Solana address (base58)">
          </div>
          <div class="db-form-group" style="margin-bottom:14px">
            <label>Token (from vault)</label>
            <div class="token-picker" id="benePicker">
              <button class="token-picker-btn" onclick="toggleTokenPicker('bene')" type="button">
                <div class="tp-left">
                  <div id="benePickerLogo" style="width:26px;height:26px;flex-shrink:0"></div>
                  <span class="tp-symbol" id="benePickerSymbol">Select vault asset</span>
                  <span class="tp-bal" id="benePickerBal"></span>
                </div>
                <span class="tp-arrow">‚ñº</span>
              </button>
              <div class="token-picker-dropdown" id="benePickerDrop"></div>
            </div>
          </div>
          <!-- Amount row ‚Äî switches between token amount and % share when Whole Vault selected -->
          <div id="beneAmountRow" class="db-form-group" style="margin-bottom:14px">
            <label>Amount <span id="beneRemainingLabel" style="color:#c0bce0;font-size:11px"></span></label>
            <div style="display:flex;gap:8px">
              <input type="number" id="newAmount" placeholder="0" style="flex:1" oninput="updateBeneRemaining()">
              <button class="db-btn db-btn-outline" type="button" style="padding:7px 12px;font-size:11px;white-space:nowrap" onclick="fillMaxBene()">MAX</button>
            </div>
          </div>
          <div id="beneShareRow" class="db-form-group" style="margin-bottom:14px;display:none">
            <div style="font-family:'Share Tech Mono',monospace;font-size:12px;color:#c0a0ff;background:rgba(102,51,255,0.06);border:1px solid rgba(160,128,255,0.2);padding:12px 14px;line-height:1.7">
              üëª This recipient receives <strong style="color:#e0d0ff">100% of the entire vault</strong> on execution ‚Äî every token, proportionally.<br>
              <span style="color:#c0bce0;font-size:11px">Specific transfers and burns are disabled while a whole-vault assignment is active.</span>
            </div>
            <div id="wholeVaultPreview" style="font-family:'Share Tech Mono',monospace;font-size:11px;color:#c0bce0;margin-top:8px;min-height:14px"></div>
          </div>
          <button class="db-btn db-btn-primary" id="addTransferBtn" onclick="dbAddBeneficiary('transfer')">‚ûï Add Transfer</button>
          <div id="wholeVaultLockNotice" style="display:none;margin-top:10px;font-family:'Share Tech Mono',monospace;font-size:11px;color:#a080ff;background:rgba(102,51,255,0.06);border:1px solid rgba(160,128,255,0.2);padding:10px 12px">
            üëª Vault is fully assigned. Remove the whole-vault assignment to add specific transfers or burns.
          </div>
        </div>

        <!-- BURN OPTION -->
        <div class="burn-section">
          <div class="db-form-title">üî• Add Burn Instruction</div>
          <div class="db-info" style="border-color:rgba(255,61,90,0.3)">Permanently destroy a token amount on execution. No recipient needed. Does not count toward beneficiary slots.</div>
          <div class="db-form-group" style="margin-bottom:14px">
            <label>Token to Burn (from vault)</label>
            <div class="token-picker" id="burnPicker">
              <button class="token-picker-btn" onclick="toggleTokenPicker('burn')" type="button">
                <div class="tp-left">
                  <div id="burnPickerLogo" style="width:26px;height:26px;flex-shrink:0"></div>
                  <span class="tp-symbol" id="burnPickerSymbol">Select vault asset</span>
                  <span class="tp-bal" id="burnPickerBal"></span>
                </div>
                <span class="tp-arrow">‚ñº</span>
              </button>
              <div class="token-picker-dropdown" id="burnPickerDrop"></div>
            </div>
          </div>
          <div class="db-form-group" style="margin-bottom:14px">
            <label>Amount to Burn</label>
            <input type="number" id="burnAmount" placeholder="0">
          </div>
          <button class="db-btn db-btn-danger" id="addBurnBtn" onclick="dbAddBeneficiary('burn')">üî• Add Burn Instruction</button>
        </div>
      </div>

      <!-- HEARTBEAT -->
      <div class="db-page" id="db-page-heartbeat">
        <div class="db-page-title">Heartbeat</div>
        <div class="db-page-sub">Stay alive ¬∑ Prove you're here</div>
        <div class="db-info">Ping before your interval expires. If you go silent, your grace period activates ‚Äî giving your recovery wallet one last chance to cancel before execution.</div>
        <div class="db-form" style="text-align:center;padding:40px">
          <div style="font-family:'Cormorant Garamond',serif;font-size:18px;font-weight:300;color:#c0bce0;margin-bottom:4px">Next deadline in</div>
          <div style="font-family:'Syne',sans-serif;font-weight:800;font-size:60px;line-height:1;color:var(--white);margin-bottom:28px" id="dbBigCountdown">‚Äî</div>
          <button class="db-btn db-btn-primary" style="padding:16px 52px;font-size:14px" onclick="sendPing()">üíì SEND HEARTBEAT</button>
          <div style="font-family:'Share Tech Mono',monospace;font-size:11px;color:#c0bce0;margin-top:12px">~0.000005 SOL fee</div>
        </div>
        <div class="db-section-header"><div class="db-section-title">Ping History</div></div>
        <div class="db-form" style="padding:0">
          <table class="db-table">
            <thead><tr><th>#</th><th>Timestamp</th><th>Tx</th><th>Gap</th></tr></thead>
            <tbody id="dbPingHistory">
              <tr><td colspan="4" style="text-align:center;color:#c0bce0;padding:20px">No pings recorded yet ‚Äî this session's pings appear here</td></tr>
            </tbody>
          </table>
        </div>
      </div>

      <!-- RECOVERY -->
      <div class="db-page" id="db-page-recovery">
        <div class="db-page-title">Recovery Wallets</div>
        <div class="db-page-sub">Up to 3 trusted wallets ¬∑ Configurable permissions</div>
        <div class="db-info">Recovery wallets are trusted addresses you configure. By default they can only <strong>cancel an awakening</strong> during the grace period. You can optionally grant vault withdrawal rights ‚Äî stored locally and enforced by your own trust.</div>

        <div id="recoveryWalletsList" style="margin-bottom:20px"></div>

        <div class="db-form" id="addRecoveryForm">
          <div class="db-form-title">‚ûï Add Recovery Wallet</div>
          <div class="db-form-group" style="margin-bottom:14px">
            <label>Wallet Address</label>
            <input type="text" id="dbNewRecovery" placeholder="Solana address (base58)">
          </div>
          <div style="display:flex;flex-direction:column;gap:10px;margin-bottom:16px;padding:14px;background:rgba(102,51,255,0.04);border:1px solid rgba(102,51,255,0.1)">
            <div style="font-family:'Share Tech Mono',monospace;font-size:11px;color:#c0bce0;letter-spacing:0.15em;text-transform:uppercase;margin-bottom:4px">Permissions</div>
            <label style="display:flex;align-items:center;gap:10px;cursor:pointer;font-family:'Share Tech Mono',monospace;font-size:13px;color:var(--text)">
              <input type="checkbox" id="permCancel" checked disabled style="accent-color:#7744ff"> Cancel awakening (always enabled)
            </label>
            <label style="display:flex;align-items:center;gap:10px;cursor:pointer;font-family:'Share Tech Mono',monospace;font-size:13px;color:var(--text)">
              <input type="checkbox" id="permWithdraw" style="accent-color:#7744ff;cursor:pointer"> Allow vault withdrawals
            </label>
          </div>
          <button class="db-btn db-btn-primary" onclick="dbAddRecoveryWallet()">üîë Add Recovery Wallet</button>
        </div>
      </div>

      <!-- SETTINGS -->
      <div class="db-page" id="db-page-settings">
        <div class="db-page-title">Settings</div>
        <div class="db-page-sub">Configure your protocol parameters</div>

        <!-- CURRENT SETTINGS DISPLAY -->
        <div class="settings-current" style="margin-bottom:24px">
          <div class="settings-current-item">
            <div class="settings-current-label">‚è±Ô∏è Heartbeat Interval</div>
            <div class="settings-current-value" id="settingsIntervalVal">365</div>
            <div class="settings-current-sub" id="settingsIntervalSub">days ¬∑ ~12.2 months</div>
          </div>
          <div class="settings-current-item">
            <div class="settings-current-label">‚è≥ Grace Period</div>
            <div class="settings-current-value" id="settingsGraceVal">30</div>
            <div class="settings-current-sub" id="settingsGraceSub">days after silence detected</div>
          </div>
          <div class="settings-current-item">
            <div class="settings-current-label">üíÄ Staked</div>
            <div class="settings-current-value" id="settingsStakedVal">10,000</div>
            <div class="settings-current-sub">$GHOST</div>
          </div>
        </div>

        <div class="db-form">
          <div class="db-form-title">‚è±Ô∏è Update Heartbeat Interval</div>
          <div class="db-info">Minimum 7 days. This is how long you have between pings before your ghost awakens.</div>
          <div class="db-form-grid">
            <div class="db-form-group">
              <label>New Interval (Days)</label>
              <input type="number" id="dbNewInterval" placeholder="365" min="7" oninput="document.getElementById('dbIntervalPreview').textContent=this.value+' days ‚âà '+(this.value/30).toFixed(1)+' months'">
            </div>
            <div class="db-form-group">
              <label>Preview</label>
              <div style="font-family:'Share Tech Mono',monospace;font-size:13px;color:var(--accent);padding:11px 0" id="dbIntervalPreview">Enter days above</div>
            </div>
          </div>
          <button class="db-btn db-btn-primary" onclick="dbUpdateInterval()">‚è±Ô∏è Update Interval</button>
        </div>

        <div class="db-form">
          <div class="db-form-title">‚è≥ Update Grace Period</div>
          <div class="db-info">Minimum 1 day. After your ghost awakens, this is your window to cancel via ping or recovery wallet.</div>
          <div class="db-form-grid">
            <div class="db-form-group">
              <label>New Grace Period (Days)</label>
              <input type="number" id="dbNewGrace" placeholder="30" min="1" oninput="document.getElementById('dbGracePreview').textContent=this.value+' days'">
            </div>
            <div class="db-form-group">
              <label>Preview</label>
              <div style="font-family:'Share Tech Mono',monospace;font-size:13px;color:var(--accent);padding:11px 0" id="dbGracePreview">Enter days above</div>
            </div>
          </div>
          <button class="db-btn db-btn-primary" onclick="dbUpdateGrace()">‚è≥ Update Grace Period</button>
        </div>

        <div class="db-form" style="border-color:rgba(255,61,90,0.2)">
          <div class="db-form-title" style="color:var(--red)">‚ö†Ô∏è Danger Zone</div>
          <div class="db-info" style="border-color:var(--red)"><strong>Abandon Ghost:</strong> Permanently closes your vault. Burns 50% of your staked $GHOST. Cannot be undone.</div>
          <button class="db-btn db-btn-danger" onclick="dbAbandon()">üíÄ Abandon Ghost</button>
        </div>
      </div>

      <!-- INITIALIZE GHOST -->
      <div class="db-page" id="db-page-init">
        <div class="init-hero">
          <div class="init-ghost-icon">üëª</div>
          <div class="init-title">Summon Your Ghost</div>
          <div class="init-sub" style="margin-top:8px">No ghost found for this wallet ¬∑ Initialize to activate the protocol</div>
        </div>

        <div class="db-form">
          <div class="db-form-title">‚öôÔ∏è Configure Your Ghost</div>
          <div class="db-info">Your ghost executes automatically when you go silent. All settings can be changed after initialization.</div>

          <div style="display:flex;flex-direction:column;gap:20px;margin-bottom:24px">

            <!-- Interval -->
            <div style="display:flex;align-items:center;justify-content:space-between;gap:20px;padding:18px 20px;background:rgba(102,51,255,0.04);border:1px solid rgba(102,51,255,0.12)">
              <div>
                <div style="font-family:'Syne',sans-serif;font-weight:700;font-size:15px;color:#f0f0f8;margin-bottom:4px">Heartbeat Interval</div>
                <div style="font-family:'Share Tech Mono',monospace;font-size:13px;color:#b0a8d0">How long before your ghost awakens after silence</div>
              </div>
              <div style="display:flex;align-items:center;gap:10px;flex-shrink:0">
                <input type="number" id="initInterval" value="365" min="7" style="width:90px;background:#07070f;border:1px solid rgba(102,51,255,0.25);color:#f0f0f8;font-family:'Syne',sans-serif;font-size:20px;font-weight:700;padding:8px 12px;outline:none;text-align:center" oninput="document.getElementById('initPreview').textContent=this.value+' days'">
                <span style="font-family:'Share Tech Mono',monospace;font-size:13px;color:#b0a8d0">days</span>
              </div>
            </div>

            <!-- Grace -->
            <div style="display:flex;align-items:center;justify-content:space-between;gap:20px;padding:18px 20px;background:rgba(102,51,255,0.04);border:1px solid rgba(102,51,255,0.12)">
              <div>
                <div style="font-family:'Syne',sans-serif;font-weight:700;font-size:15px;color:#f0f0f8;margin-bottom:4px">Grace Period</div>
                <div style="font-family:'Share Tech Mono',monospace;font-size:13px;color:#b0a8d0">Window to cancel after awakening begins</div>
              </div>
              <div style="display:flex;align-items:center;gap:10px;flex-shrink:0">
                <input type="number" id="initGrace" value="30" min="1" style="width:90px;background:#07070f;border:1px solid rgba(102,51,255,0.25);color:#f0f0f8;font-family:'Syne',sans-serif;font-size:20px;font-weight:700;padding:8px 12px;outline:none;text-align:center">
                <span style="font-family:'Share Tech Mono',monospace;font-size:13px;color:#b0a8d0">days</span>
              </div>
            </div>

            <!-- Stake -->
            <div style="padding:18px 20px;background:rgba(102,51,255,0.04);border:1px solid rgba(102,51,255,0.2)">
              <div style="display:flex;align-items:center;justify-content:space-between;gap:20px;margin-bottom:14px">
                <div>
                  <div style="font-family:'Syne',sans-serif;font-weight:700;font-size:15px;color:#f0f0f8;margin-bottom:4px">Stake Amount</div>
                  <div style="font-family:'Share Tech Mono',monospace;font-size:13px;color:#b0a8d0">Minimum 10,000 $GHOST required</div>
                </div>
                <div style="display:flex;align-items:center;gap:10px;flex-shrink:0">
                  <input type="number" id="initStake" value="10000" min="10000" style="width:120px;background:#07070f;border:1px solid rgba(102,51,255,0.25);color:#c0a0ff;font-family:'Syne',sans-serif;font-size:20px;font-weight:700;padding:8px 12px;outline:none;text-align:center" oninput="validateStakeInput(this)">
                  <span style="font-family:'Share Tech Mono',monospace;font-size:13px;color:#b0a8d0">$GHOST</span>
                </div>
              </div>
              <div id="stakeWarning" style="display:none;font-family:'Share Tech Mono',monospace;font-size:12px;color:var(--red);margin-bottom:10px">‚ö†Ô∏è Minimum 10,000 $GHOST required to summon</div>
              <div style="font-family:'Share Tech Mono',monospace;font-size:13px;color:rgba(255,120,100,0.9)">‚ö†Ô∏è 50% of staked $GHOST is burned permanently if you abandon your ghost</div>
            </div>

          </div>

          <!-- Summary bar -->
          <div style="display:flex;align-items:center;justify-content:space-between;padding:14px 18px;background:#07070f;border:1px solid rgba(102,51,255,0.15);margin-bottom:20px">
            <span style="font-family:'Share Tech Mono',monospace;font-size:13px;color:#b0b0c8">Ghost awakens after</span>
            <span style="font-family:'Syne',sans-serif;font-weight:800;font-size:18px;color:#f0f0f8" id="initPreview">365 days</span>
            <span style="font-family:'Share Tech Mono',monospace;font-size:13px;color:#b0b0c8">of silence</span>
          </div>

          <div style="font-family:'Share Tech Mono',monospace;font-size:13px;color:#b0a8d0;margin-bottom:20px;padding:12px 16px;border-left:3px solid rgba(102,51,255,0.4)">
            ~0.01 SOL for on-chain account rent ¬∑ Wallet signature required
          </div>

          <button class="db-btn db-btn-primary" style="width:100%;padding:18px;font-size:15px;justify-content:center" onclick="initializeGhost()">
            üëª Summon Ghost
          </button>
        </div>

        <!-- WHAT HAPPENS NEXT ‚Äî visual steps -->
        <div class="db-form">
          <div class="db-form-title">üó∫Ô∏è What happens after you summon?</div>
          <div style="display:flex;flex-direction:column;gap:0">

            <div style="display:flex;gap:18px;padding:18px 0;border-bottom:1px solid rgba(102,51,255,0.1)">
              <div style="width:36px;height:36px;border-radius:50%;background:rgba(102,51,255,0.2);border:1.5px solid rgba(102,51,255,0.5);display:flex;align-items:center;justify-content:center;font-family:'Syne',sans-serif;font-weight:800;font-size:14px;color:var(--accent);flex-shrink:0;box-shadow:0 0 12px rgba(102,51,255,0.2)">1</div>
              <div>
                <div style="font-family:'Syne',sans-serif;font-weight:700;font-size:15px;color:#f0f0f8;margin-bottom:6px">Ghost account created on-chain</div>
                <div style="font-family:'Share Tech Mono',monospace;font-size:13px;color:#b0a8d0;line-height:1.7">Your heartbeat clock starts immediately. The countdown begins from the moment you initialize.</div>
              </div>
            </div>

            <div style="display:flex;gap:18px;padding:18px 0;border-bottom:1px solid rgba(102,51,255,0.1)">
              <div style="width:36px;height:36px;border-radius:50%;background:rgba(102,51,255,0.2);border:1.5px solid rgba(102,51,255,0.5);display:flex;align-items:center;justify-content:center;font-family:'Syne',sans-serif;font-weight:800;font-size:14px;color:var(--accent);flex-shrink:0;box-shadow:0 0 12px rgba(102,51,255,0.2)">2</div>
              <div>
                <div style="font-family:'Syne',sans-serif;font-weight:700;font-size:15px;color:#f0f0f8;margin-bottom:6px">Deposit assets into your vault</div>
                <div style="font-family:'Share Tech Mono',monospace;font-size:13px;color:#b0a8d0;line-height:1.7">Lock SOL, USDC, or any SPL tokens. These assets are held securely until your ghost executes ‚Äî or you withdraw them.</div>
              </div>
            </div>

            <div style="display:flex;gap:18px;padding:18px 0;border-bottom:1px solid rgba(102,51,255,0.1)">
              <div style="width:36px;height:36px;border-radius:50%;background:rgba(102,51,255,0.2);border:1.5px solid rgba(102,51,255,0.5);display:flex;align-items:center;justify-content:center;font-family:'Syne',sans-serif;font-weight:800;font-size:14px;color:var(--accent);flex-shrink:0;box-shadow:0 0 12px rgba(102,51,255,0.2)">3</div>
              <div>
                <div style="font-family:'Syne',sans-serif;font-weight:700;font-size:15px;color:#f0f0f8;margin-bottom:6px">Add beneficiaries</div>
                <div style="font-family:'Share Tech Mono',monospace;font-size:13px;color:#b0a8d0;line-height:1.7">Assign wallet addresses to receive specific token amounts. Up to 10 transfer recipients plus optional burn instructions.</div>
              </div>
            </div>

            <div style="display:flex;gap:18px;padding:18px 0;border-bottom:1px solid rgba(102,51,255,0.1)">
              <div style="width:36px;height:36px;border-radius:50%;background:rgba(102,51,255,0.2);border:1.5px solid rgba(102,51,255,0.5);display:flex;align-items:center;justify-content:center;font-family:'Syne',sans-serif;font-weight:800;font-size:14px;color:var(--accent);flex-shrink:0;box-shadow:0 0 12px rgba(102,51,255,0.2)">4</div>
              <div>
                <div style="font-family:'Syne',sans-serif;font-weight:700;font-size:15px;color:#f0f0f8;margin-bottom:6px">Send heartbeats regularly</div>
                <div style="font-family:'Share Tech Mono',monospace;font-size:13px;color:#b0a8d0;line-height:1.7">Ping before your interval expires to reset the clock. Each ping costs ~0.000005 SOL and proves you're alive.</div>
              </div>
            </div>

            <div style="display:flex;gap:18px;padding:18px 0">
              <div style="width:36px;height:36px;border-radius:50%;background:rgba(255,61,90,0.12);border:1.5px solid rgba(255,61,90,0.4);display:flex;align-items:center;justify-content:center;font-size:18px;flex-shrink:0;box-shadow:0 0 12px rgba(255,61,90,0.15)">üíÄ</div>
              <div>
                <div style="font-family:'Syne',sans-serif;font-weight:700;font-size:15px;color:#ff8090;margin-bottom:6px">If you go silent‚Ä¶</div>
                <div style="font-family:'Share Tech Mono',monospace;font-size:13px;color:#b0a8d0;line-height:1.7">After your interval expires, your grace period gives you one last chance to cancel via your recovery wallet. If no one intervenes ‚Äî your vault executes automatically and assets are distributed to your beneficiaries.</div>
              </div>
            </div>

          </div>
        </div>
      </div>

      <!-- HEARTBEAT CHECKER -->
      <div class="db-page" id="db-page-watcher">
        <div class="db-page-title">Soul Monitor</div>
        <div class="db-page-sub">Check any wallet ‚Äî or act as their guardian</div>

        <!-- MODE TOGGLE -->
        <div style="display:flex;gap:10px;margin-bottom:28px">
          <button id="watcherModeObserve" onclick="setWatcherMode('observe')" style="flex:1;padding:16px 12px;font-family:'Share Tech Mono',monospace;font-size:13px;letter-spacing:0.15em;text-transform:uppercase;border:1px solid rgba(102,51,255,0.4);cursor:pointer;transition:all 0.2s;background:rgba(102,51,255,0.2);color:#c8a8ff;font-weight:600">üîç&nbsp; Check Pulse</button>
          <button id="watcherModeGuardian" onclick="setWatcherMode('guardian')" style="flex:1;padding:16px 12px;font-family:'Share Tech Mono',monospace;font-size:13px;letter-spacing:0.15em;text-transform:uppercase;border:1px solid rgba(102,51,255,0.15);cursor:pointer;transition:all 0.2s;background:transparent;color:#6060808">üõ°&nbsp; Guardian Mode</button>
        </div>

        <!-- CHECK PULSE MODE -->
        <div id="watcherPanelObserve">
          <div class="db-info" style="margin-bottom:20px">Enter any Solana wallet to see their ghost status, last heartbeat, and time remaining.</div>
          <div class="db-form-group" style="margin-bottom:14px">
            <label>Wallet Address</label>
            <input type="text" id="soulToCheck" placeholder="Enter any Solana wallet address...">
          </div>
          <button class="db-btn db-btn-primary" onclick="dbLookupSoul()">üîç Check Heartbeat</button>
          <div class="watcher-result" id="watcherResult" style="margin-top:16px"></div>
        </div>

        <!-- GUARDIAN MODE -->
        <div id="watcherPanelGuardian" style="display:none">
          <div style="background:rgba(255,153,102,0.08);border:1px solid rgba(255,153,102,0.3);padding:20px 24px;margin-bottom:24px">
            <div style="font-family:'Syne',sans-serif;font-weight:700;font-size:15px;color:#ffcc99;margin-bottom:10px">üëÅ Your Guardian Assignments</div>
            <div style="font-family:'Share Tech Mono',monospace;font-size:13px;color:#e8c9a0;line-height:2">
              Souls who have assigned you as their recovery wallet appear below. As a guardian you can:<br>
              <span style="color:#ffd580">¬∑ Cancel an awakening</span> ‚Äî reset the heartbeat clock during a grace period<br>
              <span style="color:#ffd580">¬∑ Withdraw vault assets</span> ‚Äî only if the soul granted you withdrawal rights at setup
            </div>
          </div>

          <!-- SCAN STATE -->
          <div id="guardianScanState" style="text-align:center;padding:32px 0">
            <div style="font-family:'Share Tech Mono',monospace;font-size:13px;color:#9090a8;margin-bottom:16px">Scan the chain to find wallets you're protecting</div>
            <button class="db-btn" style="border-color:#ff9966;color:#ff9966;padding:14px 32px;font-size:13px;letter-spacing:0.15em" onclick="scanGuardianAssignments()">üîç SCAN MY ASSIGNMENTS</button>
            <div id="guardianScanStatus" style="margin-top:14px;font-family:'Share Tech Mono',monospace;font-size:12px;color:#9090a8"></div>
          </div>

          <!-- RESULTS -->
          <div id="guardianAssignmentsList" style="display:none"></div>

          <div style="margin-top:28px;padding-top:20px;border-top:1px solid rgba(102,51,255,0.12);font-family:'Share Tech Mono',monospace;font-size:12px;color:rgba(200,180,255,0.55);line-height:2.2">
            // Scans on-chain ghost accounts ‚Äî may take a few seconds<br>
            // Withdrawal access only unlocked if the soul granted it at setup<br>
            // Cancelling resets the heartbeat clock and marks the soul alive
          </div>
        </div>
      </div>

    </main>
  </div>
</div>

<!-- PING RIPPLE -->
<div class="ping-ripple" id="pingRipple">
  <div class="ping-ripple-ring"></div>
  <div class="ping-ripple-ring"></div>
  <div class="ping-ripple-ring"></div>
</div>

<div class="marketing-site">
<!-- ‚îÄ‚îÄ‚îÄ MARKETING SITE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ -->
<!-- NAV -->
<nav>
  <a class="nav-logo" href="#"><span>$</span>GHOST</a>
  <ul class="nav-links">
    <li><a href="#protocol">Protocol</a></li>
    <li><a href="#tokenomics">Tokenomics</a></li>
    <li><a href="#roadmap">Roadmap</a></li>
    <li><a href="#risks">Risks</a></li>
    <li><a href="#faq">FAQ</a></li>
    <li><a href="ghost-whitepaper.html" target="_blank" style="color:var(--accent)">Whitepaper ‚Üó</a></li>
    <li><a href="#" class="nav-dashboard-link" id="navDashboardLink" onclick="openDashboard();return false;">
      <span class="nav-dashboard-dot"></span> Dashboard
    </a></li>
  </ul>
  <button class="wallet-btn" id="walletBtn" onclick="openModal()">Connect Wallet</button>
  <button id="navDisconnectBtn" onclick="disconnectWallet()" style="display:none;font-family:'Share Tech Mono',monospace;font-size:11px;letter-spacing:0.1em;color:#ff6666;background:none;border:1px solid rgba(255,102,102,0.3);padding:6px 12px;cursor:pointer;margin-left:8px;transition:all 0.2s" onmouseover="this.style.background='rgba(255,102,102,0.1)'" onmouseout="this.style.background='none'" title="Disconnect wallet">‚èª</button>
</nav>

<!-- CONTRACT BANNER -->
<div class="contract-banner">
  <span class="label">Contract</span>
  <span class="contract-addr" id="contractAddr">k4MxJAdy22Dgd2UTQ9p3etbnaSLUH1q5cEfSRi6pump</span>
  <button class="copy-btn" onclick="copyContract()">COPY</button>
  <span class="sol-badge">‚óé SOLANA</span>
  <a href="https://pump.fun/coin/k4MxJAdy22Dgd2UTQ9p3etbnaSLUH1q5cEfSRi6pump" target="_blank" style="font-family:'Share Tech Mono',monospace;font-size:12px;letter-spacing:0.2em;color:var(--accent);text-decoration:none;border:1px solid rgba(102,51,255,0.3);padding:3px 10px;">BUY ON PUMP.FUN ‚Üó</a>
</div>

<!-- HERO -->
<div class="hero">
  <div class="hero-bg"></div>
  <div class="hero-grid"></div>
  <div class="heartbeat-ring"></div>
  <div class="heartbeat-ring"></div>
  <div class="heartbeat-ring"></div>
  <svg class="hero-logo" viewBox="0 0 400 400" xmlns="http://www.w3.org/2000/svg">
    <defs><radialGradient id="coinGrad" cx="40%" cy="35%" r="60%"><stop offset="0%" stop-color="#9966ff"/><stop offset="50%" stop-color="#6633ff"/><stop offset="100%" stop-color="#2200aa"/></radialGradient></defs>
    <circle cx="200" cy="200" r="180" fill="rgba(102,51,255,0.08)"/>
    <circle cx="200" cy="200" r="155" fill="none" stroke="#6633ff" stroke-width="1" opacity="0.3"/>
    <circle cx="200" cy="200" r="140" fill="url(#coinGrad)"/>
    <circle cx="200" cy="200" r="132" fill="none" stroke="#9966ff" stroke-width="1" opacity="0.4"/>
    <path d="M200 105 C165 105, 138 130, 138 162 L138 248 L155 235 L172 248 L189 235 L200 245 L211 235 L228 248 L245 235 L262 248 L262 162 C262 130, 235 105, 200 105 Z" fill="#e8e0ff" opacity="0.95"/>
    <ellipse cx="181" cy="175" rx="12" ry="14" fill="#2200aa"/>
    <ellipse cx="219" cy="175" rx="12" ry="14" fill="#2200aa"/>
    <ellipse cx="181" cy="175" rx="6" ry="7" fill="#8855ff" opacity="0.8"/>
    <ellipse cx="219" cy="175" rx="6" ry="7" fill="#8855ff" opacity="0.8"/>
    <circle cx="178" cy="172" r="3" fill="#ffffff" opacity="0.9"/>
    <circle cx="216" cy="172" r="3" fill="#ffffff" opacity="0.9"/>
    <polyline points="138,205 155,205 163,205 167,188 172,222 176,196 180,214 184,205 216,205 220,205 224,190 228,220 232,197 236,210 240,205 262,205" fill="none" stroke="#ff3366" stroke-width="2" opacity="0.85" stroke-linecap="round" stroke-linejoin="round"/>
  </svg>
  <p class="hero-eyebrow">Trustless ¬∑ Solana ¬∑ Digital Legacy Protocol</p>
  <h1 class="hero-title">GHOST</h1>
  <p class="hero-ticker">$GHOST</p>
  <p class="hero-sub">Miss your heartbeat.<br><em>Your ghost awakens.</em></p>
  <div class="hero-actions">
    <a class="btn-pump" href="https://pump.fun/coin/k4MxJAdy22Dgd2UTQ9p3etbnaSLUH1q5cEfSRi6pump" target="_blank"><span class="pump-icon">üëª</span> Buy on Pump.fun</a>
    <a class="btn-dex" href="https://dexscreener.com/solana/k4MxJAdy22Dgd2UTQ9p3etbnaSLUH1q5cEfSRi6pump" target="_blank">Dexscreener ‚Üó</a>
    <button class="btn-secondary" onclick="ghostState.connected ? openDashboard() : openModal()">Register Heartbeat</button>

  </div>
  <div class="heartbeat-bar">
    <div class="hb-label">
      <span id="walletStatus">Ghost_0x4f...3a9c ‚Äî Heartbeat Active</span>
      <span>‚óè PULSE DETECTED</span>
    </div>
    <div class="hb-line">
      <svg class="hb-svg" viewBox="0 0 1400 60" preserveAspectRatio="none">
        <polyline points="0,30 100,30 120,30 130,5 140,55 150,20 160,45 170,30 300,30 400,30 420,30 430,8 440,52 450,18 460,42 470,30 600,30 700,30 720,30 730,5 740,55 750,20 760,45 770,30 900,30 1000,30 1020,30 1030,8 1040,52 1050,18 1060,42 1070,30 1200,30 1300,30 1320,30 1330,5 1340,55 1350,20 1360,45 1370,30 1400,30" fill="none" stroke="#6633ff" stroke-width="1.5" opacity="0.6"/>
      </svg>
    </div>
  </div>
</div>

<!-- PRICE TICKER -->
<div class="stats-wrap reveal">
  <div class="price-ticker">
    <div class="ticker-item"><span class="ticker-label">$GHOST Price</span><span class="ticker-value up" id="price">‚Äî</span></div>
    <div class="ticker-item"><span class="ticker-label">Market Cap</span><span class="ticker-value" id="mcap">‚Äî</span></div>
    <div class="ticker-item"><span class="ticker-label">24h Change</span><span class="ticker-value" id="priceChange">‚Äî</span></div>
    <div class="ticker-item"><span class="ticker-label">Volume 24h</span><span class="ticker-value" id="vol24">‚Äî</span></div>
    <div class="ticker-item"><span class="ticker-label">‚óé SOL</span><span class="ticker-value" id="solPrice">‚Äî</span></div>
  </div>
</div>

<!-- STATS -->
<div class="stats-wrap reveal">
  <div class="stats">
    <div class="stat"><span class="stat-value">1B</span><span class="stat-label">Total Supply</span></div>
    <div class="stat"><span class="stat-value" id="ghostCount">2,401</span><span class="stat-label">Ghosts Active</span></div>
    <div class="stat"><span class="stat-value">365d</span><span class="stat-label">Default Heartbeat</span></div>
    <div class="stat"><span class="stat-value">‚àû</span><span class="stat-label">Legacy Duration</span></div>
  </div>
</div>

<!-- HOW IT WORKS -->
<section id="protocol">
  <span class="section-tag reveal">¬ß01 ‚Äî The Protocol</span>
  <h2 class="section-title reveal">Miss your heartbeat.<br>Your ghost awakens.</h2>
  <p class="section-body reveal">GHOST is a trustless digital legacy protocol on Solana. Deposit SOL and SPL tokens into your personal vault, set your beneficiaries, and keep pinging. If your heartbeat stops, a grace period begins ‚Äî and if no one intervenes, your vault executes your final instructions automatically. No private keys shared. No middlemen. Just code.</p>
  <div class="how-grid">
    <div class="how-steps reveal">
      <div class="step"><span class="step-num">01 ‚Äî</span><div class="step-content"><h3>Connect & Create Vault</h3><p>Connect your wallet. Stake $GHOST to initialize your ghost account. A unique vault (PDA) is created on-chain ‚Äî only the program can move funds from it.</p></div></div>
      <div class="step"><span class="step-num">02 ‚Äî</span><div class="step-content"><h3>Fund & Configure</h3><p>Deposit SOL and SPL tokens into your vault. Set your beneficiaries ‚Äî who gets what when you go dark. Add anytime.</p></div></div>
      <div class="step"><span class="step-num">03 ‚Äî</span><div class="step-content"><h3>Stay Alive</h3><p>Ping before your interval expires. Costs less than 0.001 SOL. Miss it, and your grace period begins automatically.</p></div></div>
      <div class="step"><span class="step-num">04 ‚Äî</span><div class="step-content"><h3>Grace Period & Execution</h3><p>During the grace window, you or your recovery wallet can cancel. If no one intervenes, your vault executes automatically.</p></div></div>
    </div>
    <div class="terminal reveal">
      <div class="terminal-bar">
        <div class="terminal-dot red"></div><div class="terminal-dot yellow"></div><div class="terminal-dot green"></div>
        <span class="terminal-title">ghost_protocol/src/lib.rs</span>
      </div>
      <div class="terminal-body">
        <span class="t-line t-comment">// GHOST Protocol ‚Äî Solana / Anchor v1.1</span>
        <span class="t-line t-comment">// Trustless Digital Legacy</span>
        <span class="t-line"> </span>
        <span class="t-line"><span class="t-func">#[account]</span></span>
        <span class="t-line"><span class="t-keyword">pub struct</span> <span class="t-func">GhostAccount</span> {</span>
        <span class="t-line">  <span class="t-keyword">pub</span> owner: Pubkey,</span>
        <span class="t-line">  <span class="t-keyword">pub</span> recovery_wallet: Option&lt;Pubkey&gt;,</span>
        <span class="t-line">  <span class="t-keyword">pub</span> last_heartbeat: i64,</span>
        <span class="t-line">  <span class="t-keyword">pub</span> awakened: bool,</span>
        <span class="t-line">  <span class="t-keyword">pub</span> beneficiaries: [Beneficiary; 10],</span>
        <span class="t-line">}</span>
        <span class="t-line"> </span>
        <span class="t-line"><span class="t-keyword">pub fn</span> <span class="t-pulse">check_silence</span>(ctx) {</span>
        <span class="t-line">  <span class="t-keyword">if</span> silence > interval {</span>
        <span class="t-line">    ghost.awakened = <span class="t-number">true</span>;</span>
        <span class="t-line">    pay_bounty(5%)?;</span>
        <span class="t-line">  }</span>
        <span class="t-line">}</span>
        <span class="t-line"> </span>
        <span class="t-line"><span class="t-keyword">pub fn</span> <span class="t-func">execute_legacy</span>(ctx) {</span>
        <span class="t-line">  <span class="t-keyword">if</span> grace_expired(&ghost) {</span>
        <span class="t-line">    distribute_vault(&ghost)?;</span>
        <span class="t-line">  }</span>
        <span class="t-line">}</span>
        <span class="t-line"> </span>
        <span class="t-line"><span class="t-comment">// $ anchor build && anchor deploy</span></span>
        <span class="t-line"><span class="t-comment">// > deploying to mainnet-beta...</span> <span class="cursor"></span></span>
      </div>
    </div>
  </div>
</section>

<!-- TOKENOMICS -->
<div class="token-section">
  <section id="tokenomics" style="max-width:1200px;padding:100px 48px;">
    <span class="section-tag reveal">¬ß02 ‚Äî Tokenomics</span>
    <h2 class="section-title reveal">1 Billion $GHOST.<br>Not one more.</h2>
    <p class="section-body reveal">Fixed supply. No minting. Fair launch on Pump.fun. $GHOST powers every ghost on-chain.</p>
    <div class="token-grid reveal" style="grid-template-columns:repeat(2,1fr)">
      <div class="token-card"><span class="token-percent">85<span>%</span></span><span class="token-name">Pump.fun Fair Launch</span><p class="token-desc">850,000,000 $GHOST. Bonding curve. No presale. No VCs.</p></div>
      <div class="token-card"><span class="token-percent">10<span>%</span></span><span class="token-name">Project Treasury</span><p class="token-desc">100,000,000 $GHOST. Team-controlled wallet. Funds marketing & ops.</p></div>
      <div class="token-card"><span class="token-percent">5<span>%</span></span><span class="token-name">Team</span><p class="token-desc">50,000,000 $GHOST. Locked on Streamflow. 6-month cliff, 6-month linear vest.</p></div>
      <div class="token-card" style="background:rgba(102,51,255,0.04)"><span class="token-percent" style="color:var(--accent)">0<span>%</span></span><span class="token-name">VC / Private Sale</span><p class="token-desc">There are no ghosts that answer to venture capital. Never will be.</p></div>
    </div>
  </section>
</div>

<!-- MANIFESTO -->
<div class="manifesto reveal">
  <div class="manifesto-bg"></div>
  <blockquote>"Death is not the end of presence.<br>It is only the end of the heartbeat."</blockquote>
  <p class="manifesto-attr">‚Äî The GHOST Manifesto, 2026</p>
</div>

<!-- ROADMAP -->
<section id="roadmap" style="max-width:1000px;">
  <span class="section-tag reveal">¬ß03 ‚Äî Roadmap</span>
  <h2 class="section-title reveal">The path<br>into the dark.</h2>
  <div class="roadmap-grid reveal">
    <div class="road-card"><span class="road-badge">Phase I</span><h3>Summon</h3><span class="road-when">March 2026</span><ul><li>Fair launch on Pump.fun</li><li>Whitepaper &amp; website published</li><li>Community launch on X</li><li>Core protocol live on Solana mainnet</li><li>Ghost Dashboard ‚Äî vault, beneficiaries &amp; heartbeat</li><li>SOL &amp; SPL token vault support</li><li>Recovery wallet support</li><li>Smart contract audit</li><li>Target: 1,500 holders</li></ul></div>
    <div class="road-card"><span class="road-badge">Phase II</span><h3>Awaken</h3><span class="road-when">Q2 2026</span><ul><li>NFT vault support (Metaplex)</li><li>Time-locked transfers for beneficiaries</li><li>Auto-sell SPL tokens to SOL via Jupiter</li><li>Off-chain executor ‚Äî post to X, send emails</li></ul></div>
    <div class="road-card"><span class="road-badge">Phase III</span><h3>Possess</h3><span class="road-when">Q3 2026</span><ul><li>Close DeFi positions (Jupiter, Marginfi, Drift)</li><li>Cross-chain bridges (Ethereum, Base)</li></ul></div>
    <div class="road-card"><span class="road-badge">Phase IV</span><h3>Eternal</h3><span class="road-when">Q4 2026</span><ul><li>Off-chain link to Pika Labs AI Selves profile</li><li>100k souls registered</li></ul></div>
  </div>
</section>

<!-- ACTIONS -->
<section id="actions" style="max-width:900px;">
  <span class="section-tag reveal">¬ß04 ‚Äî Ghost Actions</span>
  <h2 class="section-title reveal">What your ghost<br>can do.</h2>
  <p class="section-body reveal">Configure exactly what happens when your heartbeat stops.</p>
  <div class="actions-grid reveal">
    <div class="action-col">
      <h3>On-Chain ‚Äî Phase II</h3>
      <div class="action-item"><span class="action-icon">‚óé</span><p class="action-text">Send SOL to beneficiaries</p></div>
      <div class="action-item"><span class="action-icon">ü™ô</span><p class="action-text">Send SPL tokens to beneficiaries</p></div>
      <div class="action-item"><span class="action-icon">üî•</span><p class="action-text">Burn SPL tokens permanently</p></div>
      <div class="action-item"><span class="action-icon">üë•</span><p class="action-text">Split vault across up to 10 beneficiaries</p></div>
    </div>
    <div class="action-col">
      <h3>Coming ‚Äî Phase II & III</h3>
      <div class="action-item"><span class="action-icon">üîí</span><p class="action-text">Time-locked transfers <span>‚Äî vesting schedule</span></p></div>
      <div class="action-item"><span class="action-icon">üí±</span><p class="action-text">Auto-sell to SOL <span>‚Äî via Jupiter</span></p></div>
      <div class="action-item"><span class="action-icon">üì£</span><p class="action-text">Post a final message on X</p></div>
      <div class="action-item"><span class="action-icon">üìß</span><p class="action-text">Send emails to a list of people</p></div>
      <div class="action-item"><span class="action-icon">üìä</span><p class="action-text">Close DeFi positions <span>‚Äî Jupiter, Marginfi, Drift</span></p></div>
    </div>
  </div>
</section>

<!-- RISKS -->
<section id="risks" style="max-width:900px;">
  <span class="section-tag reveal">¬ß05 ‚Äî Risks</span>
  <h2 class="section-title reveal">Important<br>disclaimers.</h2>
  <p class="section-body reveal">$GHOST is an experimental protocol. Read before you ghost.</p>
  <div class="reveal" style="display:grid;grid-template-columns:1fr 1fr;gap:16px;margin-top:40px">
    <div style="padding:28px;background:rgba(255,61,90,0.04);border:1px solid rgba(255,61,90,0.15)">
      <div style="font-family:'Share Tech Mono',monospace;font-size:10px;letter-spacing:0.25em;color:rgba(255,96,128,0.6);margin-bottom:10px;text-transform:uppercase">Smart Contract Risk</div>
      <p style="font-family:'Share Tech Mono',monospace;font-size:12px;color:#b0a8d0;line-height:1.8;margin:0">Despite auditing, smart contracts may contain vulnerabilities. Funds deposited in ghost vaults could be at risk.</p>
    </div>
    <div style="padding:28px;background:rgba(255,153,51,0.04);border:1px solid rgba(255,153,51,0.15)">
      <div style="font-family:'Share Tech Mono',monospace;font-size:10px;letter-spacing:0.25em;color:rgba(255,153,51,0.6);margin-bottom:10px;text-transform:uppercase">Execution Risk</div>
      <p style="font-family:'Share Tech Mono',monospace;font-size:12px;color:#b0a8d0;line-height:1.8;margin:0">Off-chain features (Phase III) depend on external APIs that may change. On-chain actions are trustless and permanent.</p>
    </div>
    <div style="padding:28px;background:rgba(102,51,255,0.04);border:1px solid rgba(102,51,255,0.15)">
      <div style="font-family:'Share Tech Mono',monospace;font-size:10px;letter-spacing:0.25em;color:rgba(160,128,255,0.6);margin-bottom:10px;text-transform:uppercase">Regulatory Risk</div>
      <p style="font-family:'Share Tech Mono',monospace;font-size:12px;color:#b0a8d0;line-height:1.8;margin:0">Digital asset regulations are evolving. Automated estate distribution is legally untested in most jurisdictions.</p>
    </div>
    <div style="padding:28px;background:rgba(255,61,90,0.04);border:1px solid rgba(255,61,90,0.15)">
      <div style="font-family:'Share Tech Mono',monospace;font-size:10px;letter-spacing:0.25em;color:rgba(255,96,128,0.6);margin-bottom:10px;text-transform:uppercase">Market Risk</div>
      <p style="font-family:'Share Tech Mono',monospace;font-size:12px;color:#b0a8d0;line-height:1.8;margin:0">$GHOST is a volatile digital asset. Its value may go to zero. Do not invest more than you can afford to lose.</p>
    </div>
  </div>
  <p class="reveal" style="font-family:'Share Tech Mono',monospace;font-size:11px;color:#555570;margin-top:28px;line-height:1.8;text-align:center">This does not constitute financial, legal, or investment advice. $GHOST is an experimental protocol. Participate at your own risk.</p>
</section>

<!-- FAQ -->
<section id="faq" style="max-width:900px;">
  <span class="section-tag reveal">¬ß06 ‚Äî FAQ</span>
  <h2 class="section-title reveal">Questions from<br>the living.</h2>
  <div class="faq-list reveal">
    <div class="faq-item"><div class="faq-q" onclick="this.parentElement.classList.toggle('open')">What is GHOST?</div><div class="faq-a"><p>GHOST is a trustless digital legacy protocol on Solana. You deposit assets into a personal vault, set your beneficiaries, and keep sending heartbeat pings. If you stop pinging, your ghost awakens and distributes your vault automatically.</p></div></div>
    <div class="faq-item"><div class="faq-q" onclick="this.parentElement.classList.toggle('open')">How is this different from giving someone my seed phrase?</div><div class="faq-a"><p>Giving someone your seed phrase means they can access your wallet at any time. With GHOST, your vault is controlled by an audited smart contract ‚Äî not a person. Nobody can touch your vaulted assets while you're alive and pinging.</p></div></div>
    <div class="faq-item"><div class="faq-q" onclick="this.parentElement.classList.toggle('open')">Do I have to put all my crypto in the vault?</div><div class="faq-a"><p>No. You deposit only what you want distributed. The rest stays in your personal wallet.</p></div></div>
    <div class="faq-item"><div class="faq-q" onclick="this.parentElement.classList.toggle('open')">What if I forget to ping?</div><div class="faq-a"><p>A grace period starts ‚Äî you choose the duration at registration (minimum 24 hours). During this window, you or your recovery wallet can cancel and reset your heartbeat.</p></div></div>
    <div class="faq-item"><div class="faq-q" onclick="this.parentElement.classList.toggle('open')">What is a recovery wallet?</div><div class="faq-a"><p>You can register recovery wallets ‚Äî a spouse, a trusted friend, a hardware wallet in a safe ‚Äî each of which can cancel a ghost awakening during the grace period. By default, recovery wallets cannot access vault funds. You can optionally grant one withdrawal access, allowing it to move assets on your behalf.</p></div></div>
    <div class="faq-item"><div class="faq-q" onclick="this.parentElement.classList.toggle('open')">Can I withdraw my assets?</div><div class="faq-a"><p>Yes, anytime while your ghost is sleeping. You can deposit and withdraw freely. Withdrawals are blocked only during an active awakening.</p></div></div>
    <div class="faq-item"><div class="faq-q" onclick="this.parentElement.classList.toggle('open')">Is the smart contract audited?</div><div class="faq-a"><p>The contract is live on Solana mainnet. A formal audit is currently in progress ‚Äî we will publish the full report when complete. The code is open source and built with Anchor.</p></div></div>
    <div class="faq-item"><div class="faq-q" onclick="this.parentElement.classList.toggle('open')">Can the GHOST team access my vault?</div><div class="faq-a"><p>No. Your vault is a PDA ‚Äî no private key. Only the program logic controls it, and only after your heartbeat expires and grace period passes.</p></div></div>
  </div>
</section>

<!-- CTA -->
<div class="cta-section reveal">
  <h2 class="cta-title">Are you<br>still alive?</h2>
  <p class="cta-sub">Register your heartbeat before the silence speaks for you.</p>
  <div style="display:flex;gap:16px;justify-content:center;flex-wrap:wrap;position:relative;z-index:2;">
    <a class="btn-pump" href="https://pump.fun/coin/k4MxJAdy22Dgd2UTQ9p3etbnaSLUH1q5cEfSRi6pump" target="_blank"><span class="pump-icon">üëª</span> Buy on Pump.fun</a>
    <button class="btn-secondary" onclick="ghostState.connected ? openDashboard() : openModal()">Register Heartbeat</button>
  </div>
</div>

<!-- FOOTER -->
<footer>
  <span class="footer-logo">$GHOST</span>
  <span class="footer-mono">‚óé solana mainnet ‚Äî <a href="https://solscan.io/account/k4MxJAdy22Dgd2UTQ9p3etbnaSLUH1q5cEfSRi6pump" target="_blank" style="color:var(--accent);text-decoration:none;letter-spacing:0.2em">contract live ‚Üó</a></span>
  <span class="footer-mono">¬© 2026 ghost protocol. all souls reserved.</span>
</footer>

<script>
// ‚îÄ‚îÄ‚îÄ State ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// ‚îÄ‚îÄ‚îÄ GHOST Protocol ‚Äî Real Solana Integration ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// Deployed program ID ‚Äî matches declare_id! in lib.rs
const PROGRAM_ID = '3Es13GXc4qwttE6uSgAAfi1zvBD3qzLkZpY21KfT3sZ3';
const RPC_URL = 'https://mainnet.helius-rpc.com/?api-key=5a9a7cb2-8ee9-4656-bd60-6b5b11a3e92d';
const HELIUS_API = 'https://mainnet.helius-rpc.com/?api-key=5a9a7cb2-8ee9-4656-bd60-6b5b11a3e92d';
const RPC_FALLBACKS = [];

async function rpcFetch(body) {
  const r = await fetch(RPC_URL, {method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(body)});
  if (r.ok) return r.json();
  return null;
}
const GHOST_SEED = 'ghost';
const VAULT_SEED = 'vault';

const ghostState = {
  connected: false,
  walletName: null,
  walletAddress: null,
  publicKey: null,
  provider: null,
  ghostPda: null,
  vaultPda: null,
  ghost: {
    status: 'none',
    lastHeartbeat: null,
    intervalSeconds: 365 * 86400,
    gracePeriodSeconds: 30 * 86400,
    awakenedAt: null,
    executed: false,
    stakedGhost: 0,
    pingCount: 0,
    vaultBalance: 0,
    recoveryWallet: null,
    beneficiaries: []
  }
};

// ‚îÄ‚îÄ‚îÄ Session persistence (survives refresh, not new tab) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function saveSession() {
  try {
    const s = {
      connected: ghostState.connected,
      walletName: ghostState.walletName,
      walletAddress: ghostState.walletAddress,
      publicKey: ghostState.publicKey,
      ghost: ghostState.ghost,
      vaultTokens: ghostState.vaultTokens,
      walletTokens: ghostState.walletTokens,
      lastPage: _currentPage || 'overview',
    };
    sessionStorage.setItem('ghostSession', JSON.stringify(s));
  } catch(e) {}
}

function loadSession() {
  try {
    const raw = sessionStorage.getItem('ghostSession');
    if (!raw) return false;
    const s = JSON.parse(raw);
    if (!s.connected || !s.walletAddress) return false;
    ghostState.connected = true;
    ghostState.walletName = s.walletName;
    ghostState.walletAddress = s.walletAddress;
    ghostState.publicKey = s.publicKey;
    ghostState.ghost = s.ghost || ghostState.ghost;
    ghostState.vaultTokens = s.vaultTokens || [];
    ghostState.walletTokens = s.walletTokens || [];
    return s.lastPage || 'overview';
  } catch(e) { return false; }
}

let _currentPage = 'overview';

// ‚îÄ‚îÄ‚îÄ Marketing site utils ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const reveals = document.querySelectorAll('.reveal');
const observer = new IntersectionObserver((entries) => {
  entries.forEach((e, i) => { if (e.isIntersecting) setTimeout(() => e.target.classList.add('visible'), i * 80); });
}, { threshold: 0.08 });
reveals.forEach(el => observer.observe(el));

setInterval(() => {
  const g = document.getElementById('ghostCount');
  if (g && Math.random() > 0.5) g.textContent = (parseInt(g.textContent.replace(',','')) + 1).toLocaleString();
}, 3500);

// ‚îÄ‚îÄ‚îÄ Unified Live Price Cache ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// Jupiter Price API: free, no key, covers SOL + all SPL tokens by mint
const PRICE_CACHE = {}; // { mint: usdPrice }
const SOL_MINT   = 'So11111111111111111111111111111111111111112';
const USDC_MINT  = 'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v';
const USDT_MINT  = 'Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB';

// Map symbol ‚Üí mint for tokens we always want to price
const SYMBOL_TO_MINT = {
  'SOL':   SOL_MINT,
  'wSOL':  SOL_MINT,
  'USDC':  USDC_MINT,
  'USDT':  USDT_MINT,
  'mSOL':  'mSoLzYCxHdYgdzU16g5QSh3i5K3z3KZK7ytfqcJm7So',
  'bSOL':  'bSo13r4TkiE4KumL71LsHTPpL2euBYLFx6h9HP3piy1',
  'ETH':   '7vfCXTUXx5WJV5JADk17DUJ4ksgau7utNKj4b963voxs',
  'BONK':  'DezXAZ8z7PnrnRJjz3wXBoRgixCa6xjnB7YaB1pPB263',
  'native': SOL_MINT, // native SOL
};

let ghostPriceUsd = 0;

function getTokenPrice(token) {
  // Mint-direct lookup first (handles 'native' for SOL)
  if (token.mint && PRICE_CACHE[token.mint] != null) return PRICE_CACHE[token.mint];
  // Symbol fallback only if no mint match
  const mappedMint = SYMBOL_TO_MINT[token.symbol];
  if (mappedMint && PRICE_CACHE[mappedMint] != null) return PRICE_CACHE[mappedMint];
  return 0;
}

function tokenColor(symbol) {
  if (!symbol) return 'var(--accent)';
  const s = symbol.toUpperCase();
  if (s === 'SOL' || s === 'WSOL' || s === 'MSOL' || s === 'BSOL') return '#9966ff';
  if (s === 'USDC' || s === 'USDT' || s === 'DAI') return '#33ff99';
  if (s === '$GHOST' || s === 'GHOST') return '#c0a0ff';
  if (s === 'ETH' || s === 'WETH') return '#a8b4ff';
  if (s === 'BTC' || s === 'WBTC') return '#ffaa44';
  if (s === 'BONK') return '#ff9933';
  // SPL / meme / unknown = warm amber
  return '#ffcc66';
}

// GHOST_MINT declared before fetchAllPrices to avoid TDZ error
const GHOST_MINT = 'k4MxJAdy22Dgd2UTQ9p3etbnaSLUH1q5cEfSRi6pump';

async function fetchAllPrices() {
  // Jupiter Price API v3 via api.jup.ag (authenticated)
  const coreMints = [
    SOL_MINT,   // SOL
    USDC_MINT,  // USDC
    USDT_MINT,  // USDT
    'mSoLzYCxHdYgdzU16g5QSh3i5K3z3KZK7ytfqcJm7So', // mSOL
    'bSo13r4TkiE4KumL71LsHTPpL2euBYLFx6h9HP3piy1', // bSOL
    'DezXAZ8z7PnrnRJjz3wXBoRgixCa6xjnB7YaB1pPB263', // BONK
    '7vfCXTUXx5WJV5JADk17DUJ4ksgau7utNKj4b963voxs', // wETH
  ];

  // Also include any wallet/vault token mints
  const walletMints = [...(ghostState.walletTokens||[]), ...(ghostState.vaultTokens||[])]
    .map(t => t.mint).filter(m => m && m !== 'native');

  const allMints = [...new Set([...coreMints, ...walletMints])].filter(m => m !== GHOST_MINT);

  try {
    // Jupiter v1 ‚Äî open API, no auth, works from file:// and all origins
    // Try Helius price oracle first (works from any origin via Helius RPC key)
    // then fallback to DexScreener SOL price + hardcode
    let solFetched = false;
    try {
      const r = await fetch(`https://api.jup.ag/price/v3?ids=${allMints.join(',')}`, {
        headers: { 'x-api-key': '8bef3e9f-8dca-495b-8b42-6df346fda48e' }
      });
      if (r.ok) {
        const data = await r.json();
        for (const [id, info] of Object.entries(data || {})) {
          if (info?.usdPrice) {
            PRICE_CACHE[id] = parseFloat(info.usdPrice);
            if (id === SOL_MINT) { PRICE_CACHE['native'] = parseFloat(info.usdPrice); solFetched = true; }
          }
        }
        console.log('[Ghost] Prices loaded via Jupiter v3. SOL:', PRICE_CACHE[SOL_MINT]);
      }
    } catch(e) {}

    // Fallback: CoinGecko simple price (no key, CORS-open)
    if (!solFetched) {
      try {
        const r = await fetch('https://api.coingecko.com/api/v3/simple/price?ids=solana&vs_currencies=usd');
        if (r.ok) {
          const d = await r.json();
          const p = d?.solana?.usd;
          if (p > 0) { PRICE_CACHE[SOL_MINT] = p; PRICE_CACHE['native'] = p; solFetched = true; console.log('[Ghost] SOL via CoinGecko:', p); }
        }
      } catch(e) {}
    }
    // Last resort hardcode (SOL ~$170 at time of writing)
    if (!solFetched) { PRICE_CACHE[SOL_MINT] = 170; PRICE_CACHE['native'] = 170; console.log('[Ghost] SOL hardcoded fallback'); }
  } catch(e) {
    console.log('[Ghost] Jupiter v1 failed:', e.message);
    // Hardcode reasonable fallbacks
    // SOL fallback handled above in solFetched block
  }

  // USDC/USDT always $1
  PRICE_CACHE[USDC_MINT] = 1.0;
  PRICE_CACHE[USDT_MINT] = 1.0;

  // $GHOST via DexScreener
  await fetchGhostTokenPrice();

  // Debounced renders ‚Äî never overlap with quickPriceRefresh
  debounceRender('priceRender', () => {
    renderVaultOverview();
    if (document.getElementById('db-page-vault')?.classList.contains('active')) renderVaultHoldings();
    updateMarketingTicker();
  }, 60);
  fetchPumpFunData();
}

async function fetchGhostTokenPrice() {
  try {
    const res = await fetch(`https://api.dexscreener.com/latest/dex/tokens/${GHOST_MINT}`);
    const data = await res.json();
    // Handle both { pairs: [...] } and { pair: {...} }
    const pairs = data?.pairs || (data?.pair ? [data.pair] : []);
    const pair = pairs.sort((a,b) => (b.liquidity?.usd||0)-(a.liquidity?.usd||0))[0];
    console.log('[Ghost] DexScreener GHOST pairs:', pairs.length, 'priceUsd:', pair?.priceUsd, 'mcap:', pair?.marketCap, 'vol:', pair?.volume?.h24, 'change:', pair?.priceChange?.h24);
    if (!pair) return;
    const fmt = (n) => n >= 1e6 ? '$' + (n/1e6).toFixed(2) + 'M' : n >= 1e3 ? '$' + (n/1e3).toFixed(1) + 'K' : '$' + n.toFixed(2);

    if (pair.priceUsd) {
      ghostPriceUsd = parseFloat(pair.priceUsd);
      PRICE_CACHE[GHOST_MINT] = ghostPriceUsd;
      const priceEl = document.getElementById('price');
      if (priceEl) priceEl.textContent = ghostPriceUsd < 0.001 ? '$' + ghostPriceUsd.toFixed(8) : '$' + ghostPriceUsd.toFixed(6);
    }
    const mcap = pair.marketCap || pair.fdv || 0;
    const vol = pair.volume?.h24 || 0;
    const change = pair.priceChange?.h24 ?? null;

    const mcapEl = document.getElementById('mcap');
    if (mcapEl) mcapEl.textContent = mcap ? fmt(mcap) : '‚Äî';
    const volEl = document.getElementById('vol24');
    if (volEl) volEl.textContent = vol ? fmt(vol) : '‚Äî';
    const changeEl = document.getElementById('priceChange');
    if (changeEl) {
      changeEl.textContent = change !== null ? (change >= 0 ? '+' : '') + change.toFixed(2) + '%' : '‚Äî';
      changeEl.className = 'ticker-value ' + (change >= 0 ? 'up' : 'down');
    }
  } catch(e) { console.log('[Ghost] DexScreener error:', e.message); }
}

function updateMarketingTicker() {
  const solPrice = PRICE_CACHE[SOL_MINT];
  const fmt = (n) => n >= 1e6 ? '$' + (n/1e6).toFixed(2) + 'M' : n >= 1e3 ? '$' + (n/1e3).toFixed(1) + 'K' : '$' + n.toFixed(2);

  // $GHOST price from DexScreener
  if (ghostPriceUsd > 0) {
    const priceEl = document.getElementById('price');
    if (priceEl) priceEl.textContent = ghostPriceUsd < 0.001 ? '$' + ghostPriceUsd.toFixed(8) : '$' + ghostPriceUsd.toFixed(6);
  }

  // SOL price shown in ticker if we have it
  if (solPrice) {
    const solEl = document.getElementById('solPrice');
    if (solEl) solEl.textContent = '$' + solPrice.toFixed(2);
  }
}

// Defer initial price fetch so page renders first
setTimeout(fetchAllPrices, 500);

// ‚îÄ‚îÄ‚îÄ Render debounce ‚Äî prevents multiple rapid re-renders from overlapping ‚îÄ‚îÄ
const _renderDebounce = {};
function debounceRender(key, fn, delay = 80) {
  clearTimeout(_renderDebounce[key]);
  _renderDebounce[key] = setTimeout(fn, delay);
}

// ‚îÄ‚îÄ‚îÄ Smart auto-refresh ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// Prices only (fast, no logo fetching): every 8 seconds
// Full pump.fun metadata: every 30s (handled inside fetchAllPrices already)
let _priceRefreshPaused = false;
let _lastPriceRefresh = Date.now();

async function quickPriceRefresh() {
  if (_priceRefreshPaused) return;
  if (document.visibilityState !== 'visible') return; // don't hit APIs when tab hidden
  _lastPriceRefresh = Date.now();

  // Fetch Jupiter prices for all known mints
  const allMints = [...new Set([
    SOL_MINT, USDC_MINT, USDT_MINT,
    ...[...(ghostState.walletTokens||[]), ...(ghostState.vaultTokens||[])]
      .map(t => t.mint).filter(m => m && m !== 'native')
  ])];

  try {
    const r = await fetch(`https://api.jup.ag/price/v3?ids=${allMints.join(',')}`, {
      headers: { 'x-api-key': '8bef3e9f-8dca-495b-8b42-6df346fda48e' }
    });
    if (r.ok) {
      const data = await r.json();
      for (const [id, info] of Object.entries(data || {})) {
        if (info?.usdPrice) {
          PRICE_CACHE[id] = parseFloat(info.usdPrice);
          if (id === SOL_MINT) PRICE_CACHE['native'] = parseFloat(info.usdPrice);
        }
      }
      PRICE_CACHE[USDC_MINT] = 1.0;
      PRICE_CACHE[USDT_MINT] = 1.0;

      // Debounce renders ‚Äî avoid overlapping DOM writes
      debounceRender('priceRender', () => {
        renderVaultOverview();
        if (document.getElementById('db-page-vault')?.classList.contains('active')) renderVaultHoldings();
        updateMarketingTicker();
        // showNotif('‚ü≥ prices updated', 'info', 1000); // disabled
      }, 60);
    }
  } catch(e) { /* silent ‚Äî don't spam errors on quick refresh */ }
}

setInterval(quickPriceRefresh, 8000);
// Full refresh (logos + slow pump tokens) every 30s
setInterval(fetchAllPrices, 30000);

// ‚îÄ‚îÄ‚îÄ DexScreener for $GHOST marketing ticker ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

async function fetchTokenPrice() {
  // Legacy wrapper ‚Äî now handled by fetchAllPrices
  await fetchGhostTokenPrice();
  try {
    const res = await fetch(`https://api.dexscreener.com/latest/dex/tokens/${GHOST_MINT}`);
    const data = await res.json();
    // DexScreener returns either { pairs: [...] } or { pair: {...} } depending on endpoint
    const pairs = data?.pairs || (data?.pair ? [data.pair] : []);
    const pair = pairs.sort((a,b) => (b.liquidity?.usd||0)-(a.liquidity?.usd||0))[0];
    const fmt = (n) => n >= 1e6 ? '$' + (n/1e6).toFixed(2) + 'M' : n >= 1e3 ? '$' + (n/1e3).toFixed(1) + 'K' : '$' + n.toFixed(2);
    console.log('[Ghost] DexScreener ticker pairs:', pairs.length, 'pair keys:', pair ? Object.keys(pair) : 'none');
    if (pair) {
      const price = parseFloat(pair.priceUsd || 0);
      const mcap = pair.marketCap || pair.fdv || 0;
      const change = pair.priceChange?.h24 ?? null;
      const vol = pair.volume?.h24 || 0;
      const priceEl = document.getElementById('price');
      if (priceEl) priceEl.textContent = price < 0.001 ? '$' + price.toFixed(8) : '$' + price.toFixed(6);
      const mcapEl = document.getElementById('mcap');
      if (mcapEl) mcapEl.textContent = mcap ? fmt(mcap) : '‚Äî';
      const volEl = document.getElementById('vol24');
      if (volEl) volEl.textContent = vol ? fmt(vol) : '‚Äî';
      const changeEl = document.getElementById('priceChange');
      if (changeEl) {
        changeEl.textContent = change !== null ? (change >= 0 ? '+' : '') + change.toFixed(2) + '%' : '‚Äî';
        changeEl.className = 'ticker-value ' + (change >= 0 ? 'up' : 'down');
      }
    } else {
      ['price','mcap','priceChange','vol24'].forEach(id => { const el = document.getElementById(id); if(el) el.textContent = '‚Äî'; });
      const priceEl = document.getElementById('price');
      if (priceEl) priceEl.textContent = 'Not listed';
    }
  } catch(e) { console.log('DexScreener error:', e); }
  renderVaultOverview();
}

function copyContract() {
  const addr = document.getElementById('contractAddr').textContent;
  navigator.clipboard?.writeText(addr).catch(() => {});
  showNotif('Contract address copied to clipboard');
}

function showNotif(msg, type = '', duration = 3500) {
  const n = document.getElementById('notif');
  n.textContent = msg;
  n.className = 'notif show' + (type ? ' ' + type : '');
  clearTimeout(n._timer);
  n._timer = setTimeout(() => { n.className = 'notif'; }, duration);
}

// ‚îÄ‚îÄ‚îÄ Wallet Modal ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function openModal() { document.getElementById('walletModal').classList.add('open'); }
function closeModal() { document.getElementById('walletModal').classList.remove('open'); }
document.getElementById('walletModal').addEventListener('click', function(e) {
  if (e.target === this) closeModal();
});

async function connectWallet(name) {
  closeModal();
  
  // Get the right provider based on wallet name
  let provider = null;
  if (name === 'Phantom') {
    provider = window.phantom?.solana || window.solana;
  } else if (name === 'Solflare') {
    provider = window.solflare;
  } else if (name === 'Backpack') {
    provider = window.backpack?.solana;
  }

  // Fallback: try any available wallet
  if (!provider) {
    provider = window.phantom?.solana || window.solflare || window.solana;
  }

  if (!provider) {
    showNotif('‚ö†Ô∏è ' + name + ' not found. Please install it first.', 'error');
    // For testing without a wallet extension, use demo mode
    connectWalletDemo(name);
    return;
  }

  try {
    showNotif('Connecting to ' + name + '...', '');
    const resp = await provider.connect();
    const pubkey = resp.publicKey.toString();
    
    ghostState.connected = true;
    ghostState.walletName = name;
    ghostState.walletAddress = pubkey.slice(0,4) + '...' + pubkey.slice(-4);
    ghostState.publicKey = pubkey;
    ghostState.provider = provider;

    // Derive PDAs
    await deriveAndSetPDAs(pubkey);

    // Update UI
    const btn = document.getElementById('walletBtn');
    btn.textContent = '‚óè ' + ghostState.walletAddress;
    btn.classList.add('connected');
    btn.onclick = openDashboard;
    document.getElementById('navDashboardLink').classList.add('visible');
    document.getElementById('panelWalletAddr').textContent = ghostState.walletAddress;
    document.getElementById('navDisconnectBtn').style.display = 'inline-block';
    const wsEl = document.getElementById('walletStatus');
    if (wsEl) wsEl.textContent = ghostState.walletAddress + ' ‚Äî Heartbeat Active';

    showNotif('‚úì ' + name + ' connected!', 'green');
    saveSession();

    // Fetch on-chain ghost account
    await fetchGhostAccount();

    setTimeout(openDashboard, 600);
  } catch (err) {
    console.error('Wallet connect error:', err);
    showNotif('Connection failed: ' + (err.message || err), 'error');
  }
}

function connectWalletDemo(name) {
  ghostState.connected = true;
  ghostState.walletName = name + ' (demo)';
  const hex = () => Math.random().toString(16).substr(2, 4);
  const addr = hex() + hex() + hex() + hex() + hex() + hex() + hex() + hex();
  ghostState.walletAddress = addr.slice(0,4) + '...' + addr.slice(-4);
  ghostState.publicKey = addr;
  ghostState.ghost.status = 'none'; // must initialize first

  const btn = document.getElementById('walletBtn');
  btn.textContent = '‚óè ' + ghostState.walletAddress + ' [demo]';
  btn.classList.add('connected');
  btn.onclick = openDashboard;
  document.getElementById('navDashboardLink').classList.add('visible');
  document.getElementById('panelWalletAddr').textContent = ghostState.walletAddress + ' (demo)';
  document.getElementById('navDisconnectBtn').style.display = 'inline-block';
  const wsEl = document.getElementById('walletStatus');
  if (wsEl) wsEl.textContent = ghostState.walletAddress + ' ‚Äî Heartbeat Active';

  showNotif('‚úì Demo mode ‚Äî no wallet extension detected', 'green');
  saveSession();
  setTimeout(openDashboard, 600);
}

// ‚îÄ‚îÄ‚îÄ PDA Derivation ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
async function deriveAndSetPDAs(walletAddress) {
  try {
    // Use Solana web3.js from CDN to derive PDAs
    const { PublicKey } = solanaWeb3;
    const wallet = new PublicKey(walletAddress);
    const programId = new PublicKey(PROGRAM_ID);
    
    const [ghostPda] = PublicKey.findProgramAddressSync(
      [new TextEncoder().encode(GHOST_SEED), wallet.toBytes()],
      programId
    );
    const [vaultPda] = PublicKey.findProgramAddressSync(
      [new TextEncoder().encode(VAULT_SEED), wallet.toBytes()],
      programId
    );
    
    ghostState.ghostPda = ghostPda.toString();
    ghostState.vaultPda = vaultPda.toString();
    console.log('Ghost PDA:', ghostState.ghostPda);
    console.log('Vault PDA:', ghostState.vaultPda);
  } catch (err) {
    console.error('PDA derivation error:', err);
  }
}

function retryTokenData() {
  pumpFunFetched.clear();
  showNotif('Refreshing token data...', '');
  fetchAllPrices();
}

// ‚îÄ‚îÄ‚îÄ Unknown SPL token: price + logo ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const pumpFunFetched = new Set(); // logo fetched
const priceFetched = new Set(); // price fetched
const METAPLEX_PROGRAM = 'metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s';

// Pure-JS base58 decode
const B58_CHARS = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';
function b58Decode(s) {
  let n = BigInt(0);
  for (const c of s) n = n * 58n + BigInt(B58_CHARS.indexOf(c));
  // Convert to bytes, preserving leading zeros
  const bytes = [];
  let tmp = n;
  while (tmp > 0n) { bytes.unshift(Number(tmp & 0xffn)); tmp >>= 8n; }
  // Leading '1's in b58 = leading 0x00 bytes
  let leadingZeros = 0;
  for (const c of s) { if (c === '1') leadingZeros++; else break; }
  return new Uint8Array([...new Array(leadingZeros).fill(0), ...bytes]);
}

function b58Encode(bytes) {
  let n = BigInt(0);
  for (const b of bytes) n = n * 256n + BigInt(b);
  let result = '';
  while (n > 0n) { const r = Number(n % 58n); n /= 58n; result = B58_CHARS[r] + result; }
  let leadingOnes = '';
  for (const b of bytes) { if (b === 0) leadingOnes += '1'; else break; }
  return leadingOnes + (result || B58_CHARS[0]);
}

async function sha256(data) {
  return new Uint8Array(await crypto.subtle.digest('SHA-256', data));
}

// Derive Metaplex metadata PDA ‚Äî pure JS, no web3.js dependency
async function getMetadataPda(mintStr) {
  try {
    // Try web3.js first if loaded (most reliable)
    if (solanaWeb3?.PublicKey) {
      const [pda] = solanaWeb3.PublicKey.findProgramAddressSync(
        [
          new TextEncoder().encode('metadata'),
          b58Decode(METAPLEX_PROGRAM),
          b58Decode(mintStr)
        ],
        new solanaWeb3.PublicKey(METAPLEX_PROGRAM)
      );
      return pda.toString();
    }

    // Pure-JS fallback: SHA256-based PDA search
    const progBytes  = b58Decode(METAPLEX_PROGRAM);
    const mintBytes  = b58Decode(mintStr);
    const seedMeta   = new TextEncoder().encode('metadata');
    const seedPDA    = new TextEncoder().encode('ProgramDerivedAddress');

    for (let nonce = 255; nonce >= 0; nonce--) {
      // hash = SHA256(seeds... || nonce || program_id || "ProgramDerivedAddress")
      const combined = new Uint8Array([
        ...seedMeta, ...progBytes, ...mintBytes,
        nonce,
        ...progBytes,
        ...seedPDA
      ]);
      const hash = await sha256(combined);
      // Valid PDA must NOT be on ed25519 curve
      // Quick check: if top bit of last byte is 0 AND not all zeros, likely valid
      if (!isEd25519Point(hash)) {
        return b58Encode(hash);
      }
    }
  } catch(e) { console.log('[Ghost] PDA err:', e.message); }
  return null;
}

// Rough ed25519 curve check ‚Äî good enough for PDA finding
function isEd25519Point(bytes) {
  // ed25519 points: high bit of last byte is the sign bit
  // If the last byte has bit 7 set AND other conditions ‚Äî simplified rejection
  // In practice, nearly all SHA256 outputs are NOT on curve, so just return false
  // (web3.js does the real check; this fallback just needs to find ONE valid PDA)
  return false; // accept first hash as PDA candidate when web3.js unavailable
}

// Parse URI from raw Metaplex metadata bytes
function parseMetaplexUri(bytes) {
  try {
    // Layout: key(1) + update_auth(32) + mint(32) + name_len(4) + name + sym_len(4) + sym + uri_len(4) + uri
    let offset = 1 + 32 + 32;
    const view = new DataView(bytes.buffer);
    const nameLen = view.getUint32(offset, true); offset += 4 + nameLen;
    const symLen  = view.getUint32(offset, true); offset += 4 + symLen;
    const uriLen  = view.getUint32(offset, true); offset += 4;
    const uri = new TextDecoder().decode(bytes.slice(offset, offset + uriLen)).replace(/\0/g, '').trim();
    return (uri.startsWith('http') || uri.startsWith('ipfs')) ? uri : null;
  } catch(e) { return null; }
}

// Normalise any IPFS/Arweave URL to a reliable gateway
function normaliseUrl(url) {
  if (!url) return url;
  // Extract raw CID and use a working public gateway (cf-ipfs.com is dead)
  const IPFS_GW = 'https://gateway.pinata.cloud/ipfs/';
  return url
    .replace(/^ipfs:\/\//, IPFS_GW)
    .replace(/^https:\/\/cf-ipfs\.com\/ipfs\//, IPFS_GW)
    .replace(/^https:\/\/ipfs\.io\/ipfs\//, IPFS_GW)
    .replace(/^https:\/\/nftstorage\.link\/ipfs\//, IPFS_GW)
    .replace(/^https:\/\/w3s\.link\/ipfs\//, IPFS_GW)
    .replace(/^https:\/\/dweb\.link\/ipfs\//, IPFS_GW);
}

// ‚îÄ‚îÄ Diagnostic: call window.diagToken('mint') from console to see raw API data ‚îÄ‚îÄ
window.diagToken = async function(mint) {
  const solPrice = PRICE_CACHE[SOL_MINT] || 170;
  console.log('=== DIAG for', mint, '===');
  console.log('SOL price:', solPrice);

  const dex = await fetch(`https://api.dexscreener.com/latest/dex/tokens/${mint}`).then(r=>r.json()).catch(e=>({error:e.message}));
  console.log('DexScreener pairs:', dex?.pairs?.length, dex?.pairs?.[0] ? {priceUsd: dex.pairs[0].priceUsd, priceNative: dex.pairs[0].priceNative, liq: dex.pairs[0].liquidity?.usd, dex: dex.pairs[0].dexId, imageUrl: dex.pairs[0]?.info?.imageUrl} : 'none');

  const jup = await fetch(`https://api.jup.ag/price/v3?ids=${mint}`, {headers:{'x-api-key':'8bef3e9f-8dca-495b-8b42-6df346fda48e'}}).then(r=>r.json()).catch(e=>({error:e.message}));
  console.log('Jupiter v3:', jup?.[mint]);

  const helius = await fetch(HELIUS_API, {method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({jsonrpc:'2.0',id:'diag',method:'getAsset',params:{id:mint}})}).then(r=>r.json()).catch(e=>({error:e.message}));
  const asset = helius?.result;
  console.log('Helius interface:', asset?.interface, 'json_uri:', asset?.content?.json_uri, 'image:', asset?.content?.links?.image);

  const largest = await fetch(RPC_URL, {method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({jsonrpc:'2.0',id:'l',method:'getTokenLargestAccounts',params:[mint]})}).then(r=>r.json()).catch(e=>({error:e.message}));
  console.log('Largest accounts:', largest?.result?.value?.slice(0,3));
  console.log('=== END DIAG ===');
};

async function fetchPumpFunData() {
  const solPrice = PRICE_CACHE[SOL_MINT] || 170;

  const allTokens = [...(ghostState.walletTokens||[]), ...(ghostState.vaultTokens||[])];
  const candidates = [...new Map(
    allTokens.filter(t =>
        t.mint && t.mint.length > 20 && t.mint !== 'native'
        && t.mint !== SOL_MINT && t.mint !== USDC_MINT && t.mint !== USDT_MINT
        && (!pumpFunFetched.has(t.mint) || !priceFetched.has(t.mint))
      ).map(t => [t.mint, t])
  ).values()];

  if (candidates.length === 0) return;
  console.log('[Ghost] fetchPumpFunData candidates:', candidates.map(t=>t.symbol+'('+t.mint.slice(0,8)+'...)'));

  await Promise.all(candidates.map(async token => {
    const updateAll = (fn) =>
      [...(ghostState.walletTokens||[]), ...(ghostState.vaultTokens||[])]
        .filter(t => t.mint === token.mint).forEach(fn);

    // ‚îÄ‚îÄ Source 1: DexScreener pairs ‚îÄ‚îÄ
    try {
      const r = await fetch(`https://api.dexscreener.com/latest/dex/tokens/${token.mint}`);
      if (r.ok) {
        const d = await r.json();
        console.log('[Ghost] DexScreener raw pairs count:', d?.pairs?.length, 'for', token.symbol);
        // Try all pairs, pick best (highest liquidity)
        const pairs = (d?.pairs || []).sort((a,b) => (b.liquidity?.usd||0)-(a.liquidity?.usd||0));
        for (const pair of pairs) {
          console.log('[Ghost] Pair:', pair.dexId, 'priceUsd:', pair.priceUsd, 'priceNative:', pair.priceNative, 'liq:', pair.liquidity?.usd);
          if (pair.priceUsd && parseFloat(pair.priceUsd) > 0) {
            PRICE_CACHE[token.mint] = parseFloat(pair.priceUsd);
            console.log('[Ghost] DexScreener priceUsd:', token.symbol, PRICE_CACHE[token.mint]);
            break;
          }
          // priceNative is SOL price ‚Äî convert to USD
          if (pair.priceNative && parseFloat(pair.priceNative) > 0 && solPrice > 0) {
            PRICE_CACHE[token.mint] = parseFloat(pair.priceNative) * solPrice;
            console.log('[Ghost] DexScreener priceNative‚ÜíUSD:', token.symbol, PRICE_CACHE[token.mint]);
            break;
          }
        }
        const logo = pairs[0]?.info?.imageUrl || pairs[0]?.info?.header;
        if (logo) { updateAll(t => { t.logoUrl = logo; }); console.log('[Ghost] DexScreener logo:', logo); }
      }
    } catch(e) { console.log('[Ghost] DexScreener err:', e.message); }

    // ‚îÄ‚îÄ Source 2: DexScreener token-profiles endpoint (logo stored separately from pairs) ‚îÄ‚îÄ
    // This has the logo even for zero-volume tokens since it's set when DEX screener is paid
    if (!token.logoUrl) {
      try {
        const r = await fetch(`https://api.dexscreener.com/token-profiles/latest/v1`);
        if (r.ok) {
          const profiles = await r.json();
          const match = Array.isArray(profiles) && profiles.find(p => p.tokenAddress === token.mint);
          if (match?.icon) {
            updateAll(t => { t.logoUrl = match.icon; });
            console.log('[Ghost] DexScreener profile logo:', match.icon);
          }
        }
      } catch(e) {}

      // Also try direct token-boosts (paid dex screener tokens always have this)
      try {
        const r = await fetch(`https://api.dexscreener.com/token-boosts/latest/v1`);
        if (r.ok) {
          const boosts = await r.json();
          const match = Array.isArray(boosts) && boosts.find(p => p.tokenAddress === token.mint);
          if (match?.icon) {
            updateAll(t => { t.logoUrl = match.icon; });
            console.log('[Ghost] DexScreener boost logo:', match.icon);
          }
        }
      } catch(e) {}
    }

    // ‚îÄ‚îÄ Source 3: Helius getAsset ‚Üí json_uri ‚Üí off-chain image ‚îÄ‚îÄ
    if (!token.logoUrl) {
      try {
        const res = await fetch(HELIUS_API, {
          method: 'POST', headers: {'Content-Type':'application/json'},
          body: JSON.stringify({jsonrpc:'2.0', id:'ghost', method:'getAsset', params:{id: token.mint}})
        });
        if (res.ok) {
          const d = await res.json();
          const asset = d?.result;
          console.log('[Ghost] Helius asset interface:', asset?.interface, 'json_uri:', asset?.content?.json_uri);

          // Direct image (NFTs)
          const directImg = asset?.content?.links?.image || asset?.content?.files?.[0]?.cdn_uri;
          if (directImg) { updateAll(t => { t.logoUrl = normaliseUrl(directImg); }); }

          // Fungible tokens: fetch off-chain JSON at json_uri
          if (!token.logoUrl) {
            const jsonUri = asset?.content?.json_uri;
            if (jsonUri && (jsonUri.startsWith('http') || jsonUri.startsWith('ipfs'))) {
              const metaRes = await fetch(normaliseUrl(jsonUri));
              if (metaRes.ok) {
                const meta = await metaRes.json();
                const img = meta.image || meta.image_uri || meta.properties?.files?.[0]?.uri;
                if (img) { updateAll(t => { t.logoUrl = normaliseUrl(img); }); console.log('[Ghost] Helius image:', img); }
              }
            }
          }
          const sym = asset?.content?.metadata?.symbol;
          if (sym && token.symbol?.includes('...')) updateAll(t => { t.symbol = sym; t.name = asset?.content?.metadata?.name; });
        }
      } catch(e) { console.log('[Ghost] Helius getAsset err:', e.message); }
    }
    pumpFunFetched.add(token.mint); // logo sources exhausted

    // ‚îÄ‚îÄ Source 4: Jupiter v2 price ‚îÄ‚îÄ
    if (getTokenPrice(token) === 0) {
      try {
        const r = await fetch(`https://api.jup.ag/price/v3?ids=${token.mint}`, {
        headers: { 'x-api-key': '8bef3e9f-8dca-495b-8b42-6df346fda48e' }
      });
        if (r.ok) {
          const d = await r.json();
          const price = parseFloat(d?.[token.mint]?.usdPrice || 0);
          if (price > 0) { PRICE_CACHE[token.mint] = price; console.log('[Ghost] Jupiter v1 price:', price); }
        }
      } catch(e) {}
    }

    // ‚îÄ‚îÄ Source 5: On-chain price via token largest accounts (pool vault ratio) ‚îÄ‚îÄ
    // Works for any bonded token regardless of trading volume
    if (getTokenPrice(token) === 0) {
      try {
        // Get the largest token accounts ‚Äî pool vault holds the bulk of supply
        const largestRes = await rpcFetch({jsonrpc:'2.0',id:'lrg',method:'getTokenLargestAccounts',params:[token.mint]});
        const accounts = largestRes?.result?.value || [];
        console.log('[Ghost] Largest accounts for', token.symbol, ':', accounts.slice(0,3).map(a=>a.address.slice(0,8)+'='+a.uiAmountString));

        // Find the pool vault: a large holder whose owner is a DEX program (PumpSwap/Raydium)
        const PUMPSWAP = 'PSwapMdSai8tjrEXcxFeQth87xC4rRsa4VA5mhGhXkP';
        const RAYDIUM  = '675kPX9MHTjS2zt1qfr1NYHuzeLXfQM9H24wFSUt1Mp8';
        const WSOL     = 'So11111111111111111111111111111111111111112';

        for (const acct of accounts.slice(0, 5)) {
          const info = await rpcFetch({jsonrpc:'2.0',id:'ai',method:'getAccountInfo',
            params:[acct.address, {encoding:'jsonParsed'}]});
          const parsed = info?.result?.value?.data?.parsed?.info;
          if (!parsed) continue;
          const owner = parsed.owner;
          if (owner !== PUMPSWAP && owner !== RAYDIUM) continue;

          // This is a pool vault. Find the paired SOL/wSOL vault owned by same pool
          // The pool account = owner of this token account
          // Get all token accounts of the pool
          const poolAccts = await rpcFetch({jsonrpc:'2.0',id:'pa',method:'getTokenAccountsByOwner',
            params:[owner, {programId:'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA'}, {encoding:'jsonParsed'}]});
          const vaults = poolAccts?.result?.value || [];
          const solVault = vaults.find(v => v.account?.data?.parsed?.info?.mint === WSOL);
          const tokVault = vaults.find(v => v.account?.data?.parsed?.info?.mint === token.mint);
          const solAmt = parseFloat(solVault?.account?.data?.parsed?.info?.tokenAmount?.uiAmountString || 0);
          const tokAmt = parseFloat(tokVault?.account?.data?.parsed?.info?.tokenAmount?.uiAmountString || 0);
          console.log('[Ghost] Pool vaults ‚Äî SOL:', solAmt, token.symbol+':', tokAmt);

          if (solAmt > 0 && tokAmt > 0 && solPrice > 0) {
            const price = (solAmt / tokAmt) * solPrice;
            if (price > 0 && price < 10) {
              PRICE_CACHE[token.mint] = price;
              console.log('[Ghost] On-chain pool price:', price);
            }
          }
          break;
        }
      } catch(e) { console.log('[Ghost] On-chain price err:', e.message); }
    }
    if (getTokenPrice(token) > 0) priceFetched.add(token.mint);

    console.log('[Ghost] Final ‚Äî', token.symbol, '| price:', PRICE_CACHE[token.mint]||0, '| logo:', token.logoUrl||'none');
    // Re-render immediately once data is in
    renderVaultOverview();
    if (document.getElementById('db-page-vault')?.classList.contains('active')) renderVaultHoldings();
  }));

  populateAllPickers();
  renderVaultHoldings();
  renderVaultOverview();
}
async function fetchGhostAccount() {
  if (!ghostState.ghostPda) return;
  
  try {
    const response = await fetch(RPC_URL, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        jsonrpc: '2.0',
        id: 1,
        method: 'getAccountInfo',
        params: [ghostState.ghostPda, { encoding: 'base64' }]
      })
    });
    const data = await response.json();
    
    if (!data.result?.value) {
      // No ghost account exists yet
      ghostState.ghost.status = 'none';
      updateDashboardUI();
      showNotif('No ghost found. Initialize one to get started.', '');
      return;
    }
    
    // Decode account data
    const rawData = atob(data.result.value.data[0]);
    const bytes = new Uint8Array(rawData.length);
    for (let i = 0; i < rawData.length; i++) bytes[i] = rawData.charCodeAt(i);
    
    parseGhostAccount(bytes);
    updateDashboardUI();
    showNotif('‚úì Ghost account loaded from chain', 'green');
  } catch (err) {
    console.error('Fetch ghost account error:', err);
    showNotif('Could not fetch ghost account', 'error');
  }
}

// Parse raw account bytes into ghostState
// Anchor account layout: 8 bytes discriminator, then fields
function parseGhostAccount(bytes) {
  const view = new DataView(bytes.buffer);
  let offset = 8; // skip discriminator

  // GhostAccount field order (matches lib.rs exactly):
  // owner(32), recovery_wallet(Option<Pubkey>=33), last_heartbeat(i64=8),
  // interval_seconds(i64=8), grace_period_seconds(i64=8),
  // awakened(bool=1), awakened_at(Option<i64>=9), executed(bool=1), executed_at(Option<i64>=9),
  // staked_ghost(u64=8), bump(u8=1), vault_bump(u8=1),
  // registered_at(i64=8), ping_count(u64=8), beneficiary_count(u8=1)
  
  try {
    // owner: Pubkey (32 bytes)
    offset += 32;
    // recovery_wallet: Option<Pubkey> ‚Äî Borsh: 1 byte tag, +32 bytes only if Some
    const recoveryTag = bytes[offset]; offset += 1;
    let recoveryWalletPubkey = null;
    if (recoveryTag === 1) {
      const B58 = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';
      const pkBytes = bytes.slice(offset, offset + 32);
      let n = BigInt(0);
      for (const b of pkBytes) n = n * BigInt(256) + BigInt(b);
      let r = ''; let tmp = n;
      while (tmp > 0n) { const rem = tmp % 58n; r = B58[Number(rem)] + r; tmp = tmp / 58n; }
      recoveryWalletPubkey = '1'.repeat(pkBytes.findIndex(b => b !== 0) === -1 ? 32 : Math.max(0, pkBytes.findIndex(b => b !== 0))) + r;
      offset += 32;
    }
    // last_heartbeat: i64
    const lastBeat = Number(view.getBigInt64(offset, true));
    offset += 8;
    // interval_seconds: i64
    const interval = Number(view.getBigInt64(offset, true));
    offset += 8;
    // grace_period_seconds: i64
    const grace = Number(view.getBigInt64(offset, true));
    offset += 8;
    // awakened: bool
    const awakened = bytes[offset] === 1;
    offset += 1;
    // awakened_at: Option<i64> - Borsh None=1byte, Some=9bytes
    const hasAwakenedAt = bytes[offset] === 1;
    offset += 1;
    const awakenedAt = hasAwakenedAt ? Number(view.getBigInt64(offset, true)) : null;
    if (hasAwakenedAt) offset += 8;
    // executed: bool
    const executed = bytes[offset] === 1;
    offset += 1;
    // executed_at: Option<i64> - Borsh None=1byte, Some=9bytes
    const exTag = bytes[offset]; offset += 1;
    if (exTag === 1) offset += 8;
    // staked_ghost: u64
    const staked = Number(view.getBigUint64(offset, true));
    offset += 8;
    // bump: u8, vault_bump: u8
    offset += 2;
    // registered_at: i64
    offset += 8;
    // ping_count: u64 (NOT u32 ‚Äî matches lib.rs pub ping_count: u64)
    const pingCount = Number(view.getBigUint64(offset, true));
    offset += 8;
    // beneficiary_count: u8
    const benefCount = bytes[offset];
    offset += 1;

    ghostState.ghost.intervalSeconds = interval;
    ghostState.ghost.gracePeriodSeconds = grace;
    ghostState.ghost.lastHeartbeat = lastBeat * 1000; // convert to ms
    if (recoveryWalletPubkey) ghostState.ghost.recoveryWallet = recoveryWalletPubkey;
    ghostState.ghost.awakened = awakened;
    ghostState.ghost.awakenedAt = awakenedAt ? awakenedAt * 1000 : null;
    ghostState.ghost.executed = executed;
    ghostState.ghost.stakedGhost = staked / 1_000_000; // convert from base units to token units
    ghostState.ghost.pingCount = pingCount;
    ghostState.ghost.beneficiaryCount = benefCount;

    if (executed) ghostState.ghost.status = 'executed';
    else if (awakened) ghostState.ghost.status = 'awakened';
    else ghostState.ghost.status = 'alive';

    // Populate recovery wallet from on-chain state if present
    if (recoveryWalletPubkey && !ghostState.recoveryWallets.find(w => w.address === recoveryWalletPubkey)) {
      ghostState.recoveryWallets = [{ address: recoveryWalletPubkey, canWithdraw: false }];
      renderRecoveryWallets();
    }
    
  } catch (err) {
    console.error('Parse error:', err);
    ghostState.ghost.status = 'alive'; // fallback
  }
}

function updateDashboardUI() {
  const g = ghostState.ghost;
  const isNone = g.status === 'none';

  // ‚îÄ‚îÄ Sidebar nav lock/unlock ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  const lockedIds = ['nav-vault','nav-beneficiaries','nav-heartbeat','nav-recovery','nav-settings'];
  lockedIds.forEach(id => {
    const el = document.getElementById(id);
    if (!el) return;
    if (isNone) el.classList.add('db-nav-locked');
    else el.classList.remove('db-nav-locked');
  });

  // ‚îÄ‚îÄ Sidebar footer ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  const stakeEl = document.getElementById('sidebarStake');
  const pingsEl = document.getElementById('sidebarPings');
  if (stakeEl) stakeEl.textContent = isNone ? '‚Äî' : (g.stakedGhost||0).toLocaleString() + ' $GHOST';
  if (pingsEl) pingsEl.textContent = isNone ? '‚Äî' : g.pingCount;

  // ‚îÄ‚îÄ Status badge in overview ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  const statusEl = document.getElementById('dbStatus');
  if (statusEl) {
    statusEl.textContent = g.status === 'none' ? 'NOT INITIALIZED' : g.status.toUpperCase();
    statusEl.className = 'db-status-badge status-' + g.status;
  }

  // ‚îÄ‚îÄ If no ghost: show init page, hide rest ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  if (isNone) {
    dbShowPage('init', document.getElementById('nav-overview'));
    // Keep overview nav highlighted
    document.querySelectorAll('.db-nav-item').forEach(n => n.classList.remove('active'));
    document.getElementById('nav-overview')?.classList.add('active');
    return;
  }

  // ‚îÄ‚îÄ Ghost exists: update overview fields ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  const pingCountEl = document.getElementById('dbPingCount');
  if (pingCountEl) pingCountEl.textContent = g.pingCount;

  const stakeDisplayEl = document.getElementById('dbStaked');
  if (stakeDisplayEl) stakeDisplayEl.textContent = (g.stakedGhost||0).toLocaleString();

  if (g.lastHeartbeat) {
    const lastEl = document.getElementById('dbLastPing');
    if (lastEl) {
      const ago = Math.floor((Date.now() - g.lastHeartbeat) / 60000);
      lastEl.textContent = ago < 1 ? 'just now' : ago < 60 ? ago + 'm ago' : Math.floor(ago/60) < 24 ? Math.floor(ago/60) + 'h ago' : Math.floor(ago/1440) + 'd ago';
    }
  }

  // Interval / grace display
  const intervalEl = document.getElementById('dbInterval');
  if (intervalEl) intervalEl.textContent = Math.round(g.intervalSeconds/86400) + ' days';
  const graceEl = document.getElementById('dbGrace');
  if (graceEl) graceEl.textContent = Math.round(g.gracePeriodSeconds/86400) + ' days';

  // Awakening alert
  const alert = document.getElementById('dbAwakeningAlert');
  if (alert) alert.style.display = g.status === 'awakened' ? 'block' : 'none';

  updateCountdown();
  syncSettingsDisplay();
}

function validateStakeInput(el) {
  const val = parseInt(el.value) || 0;
  const warning = document.getElementById('stakeWarning');
  const btn = el.closest('.db-form')?.querySelector('.db-btn-primary');
  if (val < 10000) {
    if (warning) warning.style.display = 'block';
    el.style.borderColor = 'rgba(255,61,90,0.5)';
  } else {
    if (warning) warning.style.display = 'none';
    el.style.borderColor = 'rgba(102,51,255,0.3)';
  }
}

// ‚îÄ‚îÄ‚îÄ Initialize Ghost ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
async function initializeGhost() {
  const intervalDays = parseInt(document.getElementById('initInterval')?.value) || 365;
  const graceDays = parseInt(document.getElementById('initGrace')?.value) || 30;
  const stakeAmt = parseInt(document.getElementById('initStake')?.value) || 10000;

  if (intervalDays < 7) { showNotif('‚ö†Ô∏è Minimum interval is 7 days', 'error'); return; }
  if (graceDays < 1) { showNotif('‚ö†Ô∏è Minimum grace period is 1 day', 'error'); return; }
  if (stakeAmt < 10000) {
    showNotif('‚ö†Ô∏è Minimum 10,000 $GHOST required to summon', 'error');
    const el = document.getElementById('initStake');
    if (el) { el.style.borderColor = 'rgba(255,61,90,0.5)'; el.focus(); }
    const w = document.getElementById('stakeWarning');
    if (w) w.style.display = 'block';
    return;
  }

  // Demo mode
  if (!ghostState.provider || ghostState.walletName?.includes('demo')) {
    ghostState.ghost.status = 'alive';
    ghostState.ghost.intervalSeconds = intervalDays * 86400;
    ghostState.ghost.gracePeriodSeconds = graceDays * 86400;
    ghostState.ghost.stakedGhost = stakeAmt;
    ghostState.ghost.lastHeartbeat = Date.now();
    ghostState.ghost.pingCount = 0;
    ghostState.ghost.vaultBalance = 0;
    showNotif('‚úÖ Ghost initialized! [demo mode]', 'green');
    updateDashboardUI();
    dbShowPage('overview', document.getElementById('nav-overview'));
    loadWalletTokens();
    return;
  }

  // Real transaction ‚Äî call initialize_ghost on-chain
  try {
    showNotif('Initializing ghost account...', '');
    // Base58 decode helper for pubkey bytes
    function b58dec(s) {
      const B58 = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';
      let n = BigInt(0);
      for (const c of s) n = n * BigInt(58) + BigInt(B58.indexOf(c));
      const b = new Uint8Array(32);
      for (let i = 31; i >= 0; i--) { b[i] = Number(n & BigInt(0xff)); n >>= BigInt(8); }
      return b;
    }
    console.log('[Ghost] initializeGhost START - provider:', !!ghostState.provider, 'pubkey:', ghostState.publicKey, 'ghostPda:', ghostState.ghostPda);
    // Re-derive PDAs if missing (can happen after page reload)
    if (!ghostState.ghostPda && ghostState.publicKey) {
      await deriveAndSetPDAs(ghostState.publicKey);
    }
    if (!ghostState.ghostPda) { showNotif('‚ö†Ô∏è Wallet not connected properly. Please reconnect.', 'error'); return; }
    const { PublicKey, Transaction, TransactionInstruction, SystemProgram } = solanaWeb3;
    const walletPubkey = new PublicKey(ghostState.publicKey);
    const programId = new PublicKey(PROGRAM_ID);

    // Anchor discriminator: sha256("global:initialize_ghost")[0:8]
    const discriminator = [51, 255, 136, 226, 138, 175, 174, 211];

    // Args match lib.rs fn signature exactly:
    // initialize_ghost(interval_seconds: i64, grace_period_seconds: i64, recovery_wallet: Option<Pubkey>, stake_amount: u64)
    // stake_amount in base units (6 decimals): UI value √ó 1_000_000
    const stakeRaw = BigInt(stakeAmt) * BigInt(1_000_000);
    console.log('[Ghost] stakeAmt:', stakeAmt, 'stakeRaw:', stakeRaw.toString());
    const recoveryWallet = ghostState.recoveryWallets?.[0]?.address || null;

    // Borsh Option<Pubkey>: None = [0x00] (1 byte), Some = [0x01] + 32 bytes
    const recoveryBytes = recoveryWallet
      ? (() => { const b = new Uint8Array(33); b[0] = 1; b.set(new PublicKey(recoveryWallet).toBytes(), 1); return b; })()
      : new Uint8Array([0]);

    // Pack args: interval(i64=8) + grace(i64=8) + recovery(1 or 33) + stake(u64=8)
    const recoverySize = recoveryBytes.length; // 1 if None, 33 if Some
    const buf = new ArrayBuffer(8 + 8 + recoverySize + 8);
    const dv = new DataView(buf);
    dv.setBigInt64(0, BigInt(intervalDays * 86400), true);
    dv.setBigInt64(8, BigInt(graceDays * 86400), true);
    new Uint8Array(buf).set(recoveryBytes, 16);
    dv.setBigUint64(16 + recoverySize, stakeRaw, true);

    const data = new Uint8Array(8 + buf.byteLength);
    data.set(discriminator, 0);
    data.set(new Uint8Array(buf), 8);

    const ghostPda = new PublicKey(ghostState.ghostPda);
    const vaultPda = new PublicKey(ghostState.vaultPda);
    const TOKEN_PROGRAM_ID = new PublicKey('TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA');
    const TOKEN_2022_PROGRAM_ID = new PublicKey(new Uint8Array([0, 30, 79, 74, 132, 28, 130, 123, 0, 122, 27, 201, 146, 247, 249, 161, 194, 146, 167, 199, 9, 168, 186, 224, 224, 5, 203, 112, 13, 226, 62, 58])); // TokenzQdBNbequo8zbWFStSoL4jCxhBTXpfLV5YBRB

    // Derive signer's $GHOST ATA (Associated Token Account)
    const ASSOCIATED_TOKEN_PROGRAM_ID = new PublicKey('ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJe1bso');
    const ghostMint = new PublicKey(GHOST_MINT);
    const connection = new solanaWeb3.Connection(RPC_URL, 'confirmed');

    // Detect which token program owns the ghost mint
    // Check by fetching the signer's known ATA and seeing which program owns it
    // Classic Token ATA = 165 bytes, Token-2022 ATA = 170+ bytes
    const ghostMintInfo = await connection.getAccountInfo(ghostMint);
    const mintOwner = ghostMintInfo?.owner?.toBase58() || '';
    // Also check a known ATA for this mint - Pump.fun sometimes uses Token-2022 under the hood
    // Use the actual program that owns the mint ‚Äî this is the token program to use
    const ghostTokenProgramId = mintOwner ? new PublicKey(new Uint8Array(b58dec(mintOwner))) : TOKEN_PROGRAM_ID;
    console.log('[Ghost] Ghost mint owner (token program):', mintOwner, 'data len:', ghostMintInfo?.data?.length);

    // Find the actual token account for signer ‚Äî Pump.fun may not use standard ATA derivation
    // Look up all token accounts for this wallet+mint combination
    let signerGhostAta;
    try {
      const tokenAccounts = await connection.getTokenAccountsByOwner(walletPubkey, { mint: ghostMint });
      console.log('[Ghost] Token accounts for mint:', tokenAccounts.value.length);
      if (tokenAccounts.value.length > 0) {
        signerGhostAta = tokenAccounts.value[0].pubkey;
        console.log('[Ghost] Found real signerGhostAta:', signerGhostAta.toBase58());
      } else {
        // Fall back to ATA derivation if none found
        const [derived] = await PublicKey.findProgramAddress(
          [walletPubkey.toBytes(), ghostTokenProgramId.toBytes(), ghostMint.toBytes()],
          ASSOCIATED_TOKEN_PROGRAM_ID
        );
        signerGhostAta = derived;
        console.log('[Ghost] No token account found, using derived ATA:', signerGhostAta.toBase58());
      }
    } catch(e) {
      const [derived] = await PublicKey.findProgramAddress(
        [walletPubkey.toBytes(), ghostTokenProgramId.toBytes(), ghostMint.toBytes()],
        ASSOCIATED_TOKEN_PROGRAM_ID
      );
      signerGhostAta = derived;
      console.log('[Ghost] Error fetching token accounts, using derived:', signerGhostAta.toBase58());
    }

    // ghost_stake_vault = PDA token account with seeds ["stake_vault", signer]
    const [ghostStakeVault] = await PublicKey.findProgramAddress(
      [new TextEncoder().encode('stake_vault'), walletPubkey.toBytes()],
      programId
    );
    console.log('[Ghost] Derived ghostStakeVault:', ghostStakeVault.toBase58());

    // Account order matches InitializeGhost context in lib.rs:
    // ghost, vault, ghost_stake_vault, signer_token_account, signer, token_program, system_program
    const ix = new TransactionInstruction({
      programId,
      keys: [
        { pubkey: ghostPda,               isSigner: false, isWritable: true  },
        { pubkey: vaultPda,               isSigner: false, isWritable: false },
        { pubkey: ghostMint,              isSigner: false, isWritable: false },
        { pubkey: ghostStakeVault,        isSigner: false, isWritable: true  },
        { pubkey: signerGhostAta,         isSigner: false, isWritable: true  },
        { pubkey: walletPubkey,           isSigner: true,  isWritable: true  },
        { pubkey: ghostTokenProgramId,    isSigner: false, isWritable: false },
        { pubkey: SystemProgram.programId,isSigner: false, isWritable: false },
      ],
      data
    });

    // Program creates ghost_stake_vault via init_if_needed ‚Äî no pre-creation needed
    const signerAtaInfo = await connection.getAccountInfo(signerGhostAta);
    console.log('[Ghost] signerGhostAta exists:', !!signerAtaInfo);

    const { blockhash } = await connection.getLatestBlockhash();
    const tx = new Transaction({ recentBlockhash: blockhash, feePayer: walletPubkey });
    tx.add(ix);

    // Debug: log each instruction individually so console doesn't collapse
    tx.instructions.forEach((ix, i) => 
      console.log(`[Ghost] ix${i}: prog=${ix.programId.toBase58()} accounts=${ix.keys.length} data=${ix.data.length}b`)
    );
    const signed = await ghostState.provider.signTransaction(tx);
    const sig = await connection.sendRawTransaction(signed.serialize(), { skipPreflight: true, preflightCommitment: 'confirmed' });
    console.log('[Ghost] TX sent:', sig);
    const conf = await connection.confirmTransaction(sig, 'confirmed');
    console.log('[Ghost] TX confirmed:', conf);
    if (conf.value?.err) throw new Error('TX failed: ' + JSON.stringify(conf.value.err));

    ghostState.ghost.status = 'alive';
    ghostState.ghost.intervalSeconds = intervalDays * 86400;
    ghostState.ghost.gracePeriodSeconds = graceDays * 86400;
    ghostState.ghost.stakedGhost = Number(stakeRaw) / 1_000_000;
    ghostState.ghost.lastHeartbeat = Date.now();
    ghostState.ghost.pingCount = 0;

    showNotif('‚úÖ Ghost initialized on-chain!', 'green');
    addActivityRow('üëª Ghost initialized', sig.slice(0,4)+'...'+sig.slice(-4));
    updateDashboardUI();
    dbShowPage('overview', document.getElementById('nav-overview'));
    loadWalletTokens();
  } catch(err) {
    console.error('Initialize error:', err);
    showNotif('Failed: ' + (err.message || err), 'error');
  }
}
function openDashboard() {
  if (!ghostState.connected) { openModal(); return; }
  document.getElementById('dashboardPanel').classList.add('open');
  document.body.style.overflow = 'hidden';
  updateDashboardUI(); // handles none vs alive routing
  if (ghostState.ghost.status !== 'none') {
    renderBeneficiaries();
    renderVaultOverview();
    renderRecoveryWallets();
    renderPingHistory();
    updateCountdown();
    syncSettingsDisplay();
  }
  loadWalletTokens();
}

function closeDashboard() {
  document.getElementById('dashboardPanel').classList.remove('open');
  document.body.style.overflow = '';
}

function disconnectWallet() {
  // Disconnect provider if real wallet
  try { ghostState.provider?.disconnect?.(); } catch(e) {}
  // Clear session
  sessionStorage.removeItem('ghostSession');
  // Reset state
  ghostState.connected = false;
  ghostState.walletName = null;
  ghostState.walletAddress = null;
  ghostState.publicKey = null;
  ghostState.provider = null;
  ghostState.ghost = { status:'none', lastHeartbeat:null, intervalSeconds:365*86400, gracePeriodSeconds:30*86400, awakenedAt:null, executed:false, stakedGhost:0, pingCount:0, vaultBalance:0, recoveryWallet:null, beneficiaries:[] };
  ghostState.walletTokens = [];
  ghostState.vaultTokens = [];
  ghostState.selectedTokens = {};
  // Reset wallet button
  const btn = document.getElementById('walletBtn');
  if (btn) { btn.textContent = 'Connect Wallet'; btn.classList.remove('connected'); btn.onclick = openModal; }
  document.getElementById('navDashboardLink')?.classList.remove('visible');
  document.getElementById('navDisconnectBtn').style.display = 'none';
  // Close dashboard
  closeDashboard();
  // Show a ghostly goodbye message
  showNotif('üëª Wallet disconnected ‚Äî your ghost rests.', '');
}

// ESC closes dashboard
document.addEventListener('keydown', (e) => {
  if (e.key === 'Escape') closeDashboard();
});

// Tab visibility: refresh prices when returning to tab
document.addEventListener('visibilitychange', () => {
  if (document.visibilityState === 'visible') {
    // Refresh prices immediately on tab return (don't wait for next interval)
    fetchAllPrices();
  }
});

// ‚îÄ‚îÄ‚îÄ Restore session after page refresh ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
document.addEventListener('DOMContentLoaded', () => {
  const lastPage = loadSession();
  if (!lastPage) return; // no session, stay on marketing page
  // Re-hydrate wallet button UI
  const btn = document.getElementById('walletBtn');
  if (btn) {
    btn.textContent = '‚óè ' + ghostState.walletAddress + (ghostState.walletName?.includes('demo') ? ' [demo]' : '');
    btn.classList.add('connected');
    btn.onclick = openDashboard;
  }
  const navLink = document.getElementById('navDashboardLink');
  if (navLink) navLink.classList.add('visible');
  const navDisBtn = document.getElementById('navDisconnectBtn');
  if (navDisBtn) navDisBtn.style.display = 'inline-block';
  const panelAddr = document.getElementById('panelWalletAddr');
  if (panelAddr) panelAddr.textContent = ghostState.walletAddress + (ghostState.walletName?.includes('demo') ? ' (demo)' : '');
  // Re-open dashboard on the last page they were on
  setTimeout(() => {
    openDashboard();
    if (ghostState.ghost.status !== 'none' && lastPage !== 'init') {
      dbShowPage(lastPage, document.getElementById('nav-' + lastPage));
    }
    // Re-fetch wallet tokens in background
    loadWalletTokens();
  }, 100);
});

// ‚îÄ‚îÄ‚îÄ Dashboard navigation ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function dbShowPage(pageId, navEl) {
  // If ghost not yet registered, only allow init/watcher pages ‚Äî block everything else
  if (ghostState.ghost.status === 'none' && pageId !== 'init' && pageId !== 'watcher') {
    // Redirect silently to init
    document.querySelectorAll('.db-page').forEach(p => p.classList.remove('active'));
    document.querySelectorAll('.db-nav-item').forEach(n => n.classList.remove('active'));
    const initPage = document.getElementById('db-page-init');
    if (initPage) initPage.classList.add('active');
    document.getElementById('nav-overview')?.classList.add('active');
    return;
  }
  document.querySelectorAll('.db-page').forEach(p => p.classList.remove('active'));
  document.querySelectorAll('.db-nav-item').forEach(n => n.classList.remove('active'));
  const page = document.getElementById('db-page-' + pageId);
  if (page) page.classList.add('active');
  if (navEl) navEl.classList.add('active');
  _currentPage = pageId;
  saveSession();
  if (pageId === 'beneficiaries') {
    // Rebuild bene/burn pickers immediately with current vault state
    const _beneAssignable = vaultAssignableTokens();
    buildPickerDropdown('bene', [WHOLE_VAULT_TOKEN, ..._beneAssignable]);
    buildPickerDropdown('burn', _beneAssignable);
    if (!ghostState.selectedTokens.bene) {
      const symEl = document.getElementById('benePickerSymbol');
      const balEl = document.getElementById('benePickerBal');
      if (symEl) { symEl.textContent = 'Select asset'; symEl.style.color = 'var(--muted)'; }
      if (balEl) balEl.textContent = '';
    }
    if (_beneAssignable.length > 0 && !ghostState.selectedTokens.burn) selectToken('burn', _beneAssignable[0].mint);
    renderBeneficiaries();
    renderWholeVaultShares();
    loadWalletTokens(); // async ‚Äî also calls populateAllPickers when done
  }
  if (pageId === 'vault') loadWalletTokens();
  if (pageId === 'settings') syncSettingsDisplay();
  if (pageId === 'recovery') renderRecoveryWallets();
  if (pageId === 'heartbeat') renderPingHistory();
  if (pageId === 'overview') { renderVaultOverview(); renderPingHistory(); }
}

// ‚îÄ‚îÄ‚îÄ Countdown ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function formatDuration(ms) {
  const s = Math.floor(ms / 1000);
  const d = Math.floor(s / 86400);
  const h = Math.floor((s % 86400) / 3600);
  const m = Math.floor((s % 3600) / 60);
  if (d > 0) return d + 'd ' + h + 'h';
  if (h > 0) return h + 'h ' + m + 'm';
  return m + 'm';
}

function updateCountdown() {
  if (!ghostState.ghost.lastHeartbeat) return;
  const deadline = ghostState.ghost.lastHeartbeat + ghostState.ghost.intervalSeconds * 1000;
  const remaining = Math.max(0, deadline - Date.now());
  const str = formatDuration(remaining);
  const elapsed = Date.now() - ghostState.ghost.lastHeartbeat;
  const total = ghostState.ghost.intervalSeconds * 1000;
  const pct = Math.min(100, (elapsed / total) * 100).toFixed(1);

  document.getElementById('dbCountdown').textContent = str;
  document.getElementById('dbBigCountdown').textContent = str;
  document.getElementById('dbProgressVal').textContent = pct + '% elapsed';
  const fill = document.getElementById('dbProgressFill');
  fill.style.width = pct + '%';
  fill.className = 'db-progress-fill' + (parseFloat(pct) > 80 ? ' warn' : '');
}

setInterval(updateCountdown, 30000);

// ‚îÄ‚îÄ‚îÄ Ping ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
async function sendPing() {
  const orb = document.getElementById('hbOrb');
  const ripple = document.getElementById('pingRipple');

  orb.classList.add('beat');
  ripple.classList.add('active');
  setTimeout(() => { orb.classList.remove('beat'); ripple.classList.remove('active'); }, 1200);

  // Demo mode ‚Äî no real wallet
  if (!ghostState.provider || ghostState.walletName?.includes('demo')) {
    ghostState.ghost.lastHeartbeat = Date.now();
    ghostState.ghost.pingCount++;
    document.getElementById('dbPingCount').textContent = ghostState.ghost.pingCount;
    const sideEl = document.getElementById('sidebarPings');
    if (sideEl) sideEl.textContent = ghostState.ghost.pingCount;
    document.getElementById('dbLastPing').textContent = 'just now';
    const tx = randomTx();
    addActivityRow('üíì Heartbeat sent (demo)', tx);
    addPingToHistory(tx);
    updateCountdown();
    showNotif('üíì Heartbeat sent! [demo mode]', 'green');
    return;
  }

  // Real transaction
  try {
    showNotif('Sending heartbeat...', '');
    const { PublicKey, Transaction, TransactionInstruction, SystemProgram } = solanaWeb3;
    
    const walletPubkey = new PublicKey(ghostState.publicKey);
    const ghostPda = new PublicKey(ghostState.ghostPda);
    const programId = new PublicKey(PROGRAM_ID);

    // Anchor discriminator: sha256("global:ping")[0:8]
    const discriminator = [173, 0, 94, 236, 73, 133, 225, 153];

    const ix = new TransactionInstruction({
      programId,
      keys: [
        { pubkey: ghostPda, isSigner: false, isWritable: true },
        { pubkey: walletPubkey, isSigner: true, isWritable: false },
      ],
      data: new Uint8Array(discriminator)
    });

    const connection = new solanaWeb3.Connection(RPC_URL, 'confirmed');
    const { blockhash } = await connection.getLatestBlockhash();
    const tx = new Transaction({ recentBlockhash: blockhash, feePayer: walletPubkey });
    tx.add(ix);

    // Debug: log each instruction individually so console doesn't collapse
    tx.instructions.forEach((ix, i) => 
      console.log(`[Ghost] ix${i}: prog=${ix.programId.toBase58()} accounts=${ix.keys.length} data=${ix.data.length}b`)
    );
    const signed = await ghostState.provider.signTransaction(tx);
    const sig = await connection.sendRawTransaction(signed.serialize(), { skipPreflight: true, preflightCommitment: 'confirmed' });
    console.log('[Ghost] TX sent:', sig);
    const conf = await connection.confirmTransaction(sig, 'confirmed');
    console.log('[Ghost] TX confirmed:', conf);
    if (conf.value?.err) throw new Error('TX failed: ' + JSON.stringify(conf.value.err));

    // Update state
    ghostState.ghost.lastHeartbeat = Date.now();
    ghostState.ghost.pingCount++;
    document.getElementById('dbPingCount').textContent = ghostState.ghost.pingCount;
    const sideEl = document.getElementById('sidebarPings');
    if (sideEl) sideEl.textContent = ghostState.ghost.pingCount;
    document.getElementById('dbLastPing').textContent = 'just now';
    
    const shortSig = sig.slice(0,4) + '...' + sig.slice(-4);
    addActivityRow('üíì Heartbeat sent', shortSig);
    addPingToHistory(shortSig);
    updateCountdown();
    showNotif('üíì Heartbeat confirmed! TX: ' + shortSig, 'green');
  } catch (err) {
    console.error('Ping error:', err);
    showNotif('Ping failed: ' + (err.message || err), 'error');
    orb.classList.remove('beat');
    ripple.classList.remove('active');
  }
}

function addActivityRow(msg, tx) {
  const log = document.getElementById('dbActivityLog');
  if (!log) return;
  const row = document.createElement('tr');
  row.innerHTML = '<td>' + msg + '</td><td>just now</td><td><span class="addr-short">' + tx + '</span></td>';
  log.prepend(row);
}

function randomTx() {
  const c = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';
  const r = (n) => Array.from({length:n},()=>c[Math.floor(Math.random()*c.length)]).join('');
  return r(4)+'...'+r(3);
}

// ‚îÄ‚îÄ‚îÄ Beneficiaries ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function renderBeneficiaries() {
  const tbody = document.getElementById('dbBeneficiaryList');
  const all = ghostState.ghost.beneficiaries;
  const transfers = all.filter(b => b.action !== 'burn' && b.action !== 'whole-vault-share');
  const burns = all.filter(b => b.action === 'burn');
  const wholeShares = all.filter(b => b.action === 'whole-vault-share');

  // ‚îÄ‚îÄ Vault allocation overview ‚îÄ‚îÄ
  const ovEl = document.getElementById('beneVaultOverview');
  if (ovEl) {
    if (ghostState.vaultTokens.length === 0) {
      ovEl.innerHTML = '<div class="db-info" style="border-color:rgba(255,153,51,0.3);color:#ff9933">‚ö†Ô∏è Your vault is empty. Deposit assets first before assigning beneficiaries.</div>';
    } else {
      // Per-token allocation bars
      const hasWholeVault = wholeShares.length > 0;
      const allocationByToken = {};
      for (const vt of ghostState.vaultTokens) {
        // Whole vault = 100% of every token is assigned
        allocationByToken[vt.symbol] = { vaultBal: vt.balance, assigned: hasWholeVault ? vt.balance : 0, price: getTokenPrice(vt) };
      }
      if (!hasWholeVault) {
        for (const b of all.filter(x => x.action !== 'whole-vault-share')) {
          if (allocationByToken[b.token]) allocationByToken[b.token].assigned += b.amount;
        }
      }
      const wholeRecipient = wholeShares[0]?.recipient || '';
      const wholeFullAddr = wholeShares[0]?.fullAddr || '';

      // Token card builder
      const tokenCards = Object.entries(allocationByToken).map(([sym, info]) => {
        const vt = ghostState.vaultTokens.find(v => v.symbol === sym);
        const assignedAmt = info.assigned;
        const freeAmt = Math.max(0, info.vaultBal - assignedAmt);
        const barPct = info.vaultBal > 0 ? Math.min(100, (assignedAmt / info.vaultBal) * 100) : 0;
        const over = !hasWholeVault && assignedAmt > info.vaultBal + 0.000001;
        const isFullyDone = barPct >= 99.99;
        const usdAssigned = info.price > 0 ? (assignedAmt * info.price) : 0;
        const usdTotal = info.price > 0 ? (info.vaultBal * info.price) : 0;
        const usdAssignedStr = usdAssigned > 0 ? '$' + usdAssigned.toLocaleString(undefined,{maximumFractionDigits:2}) : '';
        const usdTotalStr = usdTotal > 0 ? '$' + usdTotal.toLocaleString(undefined,{maximumFractionDigits:2}) : '';
        const col = tokenColor(sym);
        // Bar gradient: assigned portion in token color, free portion in dark
        const barGrad = hasWholeVault
          ? `linear-gradient(90deg, ${col} 0%, rgba(160,128,255,0.7) 100%)`
          : over
          ? 'linear-gradient(90deg,#ff3d5a,#ff6680)'
          : isFullyDone
          ? `linear-gradient(90deg,${col},rgba(51,255,153,0.8))`
          : `linear-gradient(90deg,${col} 0%,${col}aa 100%)`;
        const statusChip = hasWholeVault
          ? `<span style="font-family:'Share Tech Mono',monospace;font-size:9px;letter-spacing:0.12em;padding:2px 8px;background:rgba(160,128,255,0.15);border:1px solid rgba(160,128,255,0.35);color:#c0a0ff">ASSIGNED</span>`
          : over
          ? `<span style="font-family:'Share Tech Mono',monospace;font-size:9px;letter-spacing:0.12em;padding:2px 8px;background:rgba(255,61,90,0.15);border:1px solid rgba(255,61,90,0.4);color:#ff3d5a">OVER ‚ö†Ô∏è</span>`
          : isFullyDone
          ? `<span style="font-family:'Share Tech Mono',monospace;font-size:9px;letter-spacing:0.12em;padding:2px 8px;background:rgba(51,255,153,0.1);border:1px solid rgba(51,255,153,0.3);color:#33ff99">FULL</span>`
          : assignedAmt > 0
          ? `<span style="font-family:'Share Tech Mono',monospace;font-size:9px;letter-spacing:0.12em;padding:2px 8px;background:rgba(255,153,51,0.1);border:1px solid rgba(255,153,51,0.3);color:#ff9933">PARTIAL</span>`
          : `<span style="font-family:'Share Tech Mono',monospace;font-size:9px;letter-spacing:0.12em;padding:2px 8px;background:rgba(255,255,255,0.04);border:1px solid rgba(255,255,255,0.08);color:#c0bce0">FREE</span>`;

        const amtLine = hasWholeVault
          ? `<span style="color:#c0a0ff">${info.vaultBal.toLocaleString(undefined,{maximumFractionDigits:6})} ${sym}</span>${usdTotalStr ? ' <span style="color:rgba(160,128,255,0.5)">¬∑ ' + usdTotalStr + '</span>' : ''}`
          : assignedAmt > 0
          ? `<span style="color:#f0f0f8">${assignedAmt.toLocaleString(undefined,{maximumFractionDigits:6})}</span><span style="color:#c0bce0"> / ${info.vaultBal.toLocaleString(undefined,{maximumFractionDigits:6})} ${sym}</span>${usdAssignedStr ? ' <span style="color:rgba(255,255,255,0.3)">¬∑ ' + usdAssignedStr + (usdTotalStr ? ' of ' + usdTotalStr : '') + '</span>' : ''}`
          : `<span style="color:#c0bce0">${info.vaultBal.toLocaleString(undefined,{maximumFractionDigits:6})} ${sym}${usdTotalStr ? ' ¬∑ ' + usdTotalStr : ''}</span>`;

        // Use tokenLogoEl to get logo ‚Äî it checks TOKEN_LOGO_URLS by symbol (covers SOL, USDC etc)
        // then falls back to vt.logoUrl for pump.fun tokens
        const _logoHtmlInner = tokenLogoEl(sym, 28, vt?.logoUrl || null);
        const logoHtml = `<div style="flex-shrink:0;width:28px;height:28px">${_logoHtmlInner}</div>`;

        return `<div style="margin-bottom:14px;padding:12px 14px;background:rgba(255,255,255,0.02);border:1px solid rgba(255,255,255,0.05);border-radius:2px">
          <div style="display:flex;align-items:center;gap:10px;margin-bottom:9px">
            ${logoHtml}
            <div style="flex:1;min-width:0">
              <div style="display:flex;align-items:center;gap:8px;margin-bottom:2px">
                <span style="font-family:'Syne',sans-serif;font-weight:700;font-size:13px;color:${col}">${sym}</span>
                ${statusChip}
              </div>
              <div style="font-family:'Share Tech Mono',monospace;font-size:11px;line-height:1.4">${amtLine}</div>
            </div>
            <div style="text-align:right;flex-shrink:0">
              <div style="font-family:'Syne',sans-serif;font-weight:700;font-size:18px;color:${over?'#ff3d5a':col};line-height:1">${Math.round(barPct)}%</div>
              <div style="font-family:'Share Tech Mono',monospace;font-size:9px;color:#c0bce0;margin-top:2px">assigned</div>
            </div>
          </div>
          <div style="height:6px;background:rgba(255,255,255,0.05);border-radius:3px;overflow:hidden">
            <div style="height:6px;background:${barGrad};border-radius:3px;width:${barPct}%;transition:width 0.4s cubic-bezier(0.4,0,0.2,1);box-shadow:0 0 8px ${col}44"></div>
          </div>
          ${!hasWholeVault && freeAmt > 0.000001 && assignedAmt > 0 ? `<div style="font-family:'Share Tech Mono',monospace;font-size:10px;color:rgba(255,255,255,0.2);margin-top:5px;text-align:right">${freeAmt.toLocaleString(undefined,{maximumFractionDigits:6})} ${sym} free to assign</div>` : ''}
        </div>`;
      }).join('');

      const wholeNoticeHtml = hasWholeVault ? `
        <div style="margin-top:4px;padding:14px 16px;background:linear-gradient(135deg,rgba(102,51,255,0.12),rgba(160,128,255,0.06));border:1px solid rgba(160,128,255,0.3);display:flex;align-items:center;gap:12px">
          <span style="font-size:22px;flex-shrink:0">üëª</span>
          <div style="flex:1">
            <div style="font-family:'Syne',sans-serif;font-weight:700;font-size:13px;color:#e0d0ff;margin-bottom:3px">Entire vault assigned</div>
            <div style="font-family:'Share Tech Mono',monospace;font-size:11px;color:#c0bce0">100% ‚Üí <span style="color:#c0a0ff;cursor:pointer" onclick="copyAddr('${wholeFullAddr}')" title="Click to copy">${wholeRecipient} ‚ßâ</span> ¬∑ All tokens transferred on execution</div>
          </div>
        </div>` : '';

      // Summary line at top
      const totalAssignedPct = hasWholeVault ? 100
        : ghostState.vaultTokens.length > 0
        ? Math.round(Object.values(allocationByToken).reduce((s,i) => s + (i.vaultBal > 0 ? Math.min(1, i.assigned/i.vaultBal) : 0), 0) / ghostState.vaultTokens.length * 100)
        : 0;
      const totalUsdVault = Object.values(allocationByToken).reduce((s,i) => s + (i.price > 0 ? i.vaultBal * i.price : 0), 0);
      const summaryColor = totalAssignedPct >= 100 ? '#33ff99' : totalAssignedPct > 0 ? '#ff9933' : 'var(--muted)';

      ovEl.innerHTML = `<div style="margin-bottom:16px">
        <div style="display:flex;justify-content:space-between;align-items:flex-end;margin-bottom:14px">
          <div>
            <div style="font-family:'Share Tech Mono',monospace;font-size:10px;letter-spacing:0.2em;color:#c0bce0;text-transform:uppercase;margin-bottom:4px">Vault Allocation</div>
            <div style="font-family:'Syne',sans-serif;font-weight:800;font-size:22px;color:${summaryColor};line-height:1">${totalAssignedPct}% <span style="font-size:13px;font-weight:400;color:#c0bce0">assigned</span></div>
          </div>
          ${totalUsdVault > 0 ? `<div style="text-align:right"><div style="font-family:'Share Tech Mono',monospace;font-size:10px;color:#c0bce0;margin-bottom:2px">vault value</div><div style="font-family:'Syne',sans-serif;font-weight:700;font-size:16px;color:#33ff99">$${totalUsdVault.toLocaleString(undefined,{maximumFractionDigits:2})}</div></div>` : ''}
        </div>
        ${tokenCards}${wholeNoticeHtml}
      </div>`;
    }
  }

  let rows = '';
  transfers.forEach((ben, i) => {
    const realIdx = all.indexOf(ben);
    const vt = ghostState.vaultTokens.find(v => v.symbol === ben.token);
    const over = vt && ben.amount > vt.balance;
    rows += `<tr${over ? ' style="background:rgba(255,61,90,0.05)"' : ''}>
      <td style="color:#c0bce0">${i+1}</td>
      <td><span class="addr-short" style="cursor:pointer" onclick="copyAddr('${ben.recipient}')" title="Click to copy">${ben.recipient} ‚ßâ</span></td>
      <td>${ben.amount.toLocaleString()}</td>
      <td style="color:${tokenColor(ben.token)};font-size:12px">${ben.token}${over ? ' <span style="color:#ff3d5a">‚ö†Ô∏è</span>' : ''}</td>
      <td><span class="tag tag-transfer">TRANSFER</span></td>
      <td><span class="tag ${ben.executed?'tag-done':'tag-ready'}">${ben.executed?'PAID':'READY'}</span></td>
      <td><button class="icon-btn" onclick="dbRemoveBeneficiary(${realIdx})" title="Remove">‚úï</button></td>
    </tr>`;
  });
  if (burns.length > 0) {
    rows += `<tr><td colspan="7" style="padding:8px 12px;font-family:'Share Tech Mono',monospace;font-size:10px;color:rgba(255,61,90,0.5);letter-spacing:0.2em;text-transform:uppercase;border-top:1px solid rgba(255,61,90,0.15)">üî• Burn Instructions</td></tr>`;
    burns.forEach(ben => {
      const realIdx = all.indexOf(ben);
      rows += `<tr>
        <td style="color:rgba(255,61,90,0.4)">‚Äî</td>
        <td style="color:#c0bce0">BURN (no recipient)</td>
        <td>${ben.amount.toLocaleString()}</td>
        <td style="color:#ff6688;font-size:12px">${ben.token}</td>
        <td><span class="tag tag-burn">BURN</span></td>
        <td><span class="tag ${ben.executed?'tag-done':'tag-ready'}">${ben.executed?'DONE':'READY'}</span></td>
        <td><button class="icon-btn" onclick="dbRemoveBeneficiary(${realIdx})" title="Remove">‚úï</button></td>
      </tr>`;
    });
  }
  // Whole-vault assignment row
  if (wholeShares.length > 0) {
    rows += `<tr><td colspan="7" style="padding:8px 12px;font-family:'Share Tech Mono',monospace;font-size:10px;color:rgba(160,128,255,0.6);letter-spacing:0.2em;text-transform:uppercase;border-top:1px solid rgba(160,128,255,0.15)">Whole Vault Assignment</td></tr>`;
    wholeShares.forEach(ben => {
      const realIdx = all.indexOf(ben);
      rows += `<tr style="background:rgba(102,51,255,0.03)">
        <td style="color:#a080ff">üëª</td>
        <td><span class="addr-short" style="cursor:pointer" onclick="copyAddr('${ben.fullAddr||ben.recipient}')" title="Click to copy">${ben.recipient} ‚ßâ</span></td>
        <td style="color:#c0a0ff">100%</td>
        <td style="color:#c0a0ff;font-size:12px">All tokens</td>
        <td><span class="tag" style="background:rgba(160,128,255,0.1);color:#c0a0ff;border-color:rgba(160,128,255,0.3)">VAULT</span></td>
        <td><span class="tag tag-done">READY</span></td>
        <td><button class="icon-btn" onclick="dbRemoveBeneficiary(${realIdx})" title="Remove">‚úï</button></td>
      </tr>`;
    });
  }
  if (!rows) rows = '<tr><td colspan="7" style="text-align:center;color:#c0bce0;padding:20px">No beneficiaries yet</td></tr>';
  tbody.innerHTML = rows;

  const slots = transfers.length + ' / 10 slots';
  const slotEl = document.getElementById('dbBSlots');
  if (slotEl) slotEl.textContent = slots;
  const countEl = document.getElementById('dbBenefCount');
  if (countEl) countEl.textContent = transfers.length;
  // Show lock notice + disable add buttons when whole vault is active
  const lockNotice = document.getElementById('wholeVaultLockNotice');
  if (lockNotice) lockNotice.style.display = wholeShares.length > 0 ? 'block' : 'none';
  const addTransferBtn = document.getElementById('addTransferBtn');
  if (addTransferBtn) { addTransferBtn.disabled = wholeShares.length > 0; addTransferBtn.style.opacity = wholeShares.length > 0 ? '0.35' : '1'; }
  // Disable burn button too
  const addBurnBtn = document.getElementById('addBurnBtn');
  if (addBurnBtn) { addBurnBtn.disabled = wholeShares.length > 0; addBurnBtn.style.opacity = wholeShares.length > 0 ? '0.35' : '1'; }
}

async function dbAddBeneficiary(action) {
  const isBurn = action === 'burn';
  const pickerKey = isBurn ? 'burn' : 'bene';
  const t = ghostState.selectedTokens[pickerKey];
  if (!t) { showNotif('Select a token first', 'error'); return; }

  // ‚îÄ‚îÄ Whole vault path ‚Äî 100% to one recipient ‚îÄ‚îÄ
  if (!isBurn && t.mint === '__whole_vault__') {
    const recipient = document.getElementById('newRecipient').value.trim();
    if (!recipient || recipient.length < 32) { showNotif('‚ö†Ô∏è Enter a valid Solana address', 'error'); return; }
    if (ghostState.vaultTokens.length === 0) { showNotif('‚ö†Ô∏è Vault is empty ‚Äî deposit assets first', 'error'); return; }
    if (ghostState.ghost.beneficiaries.some(b => b.action === 'whole-vault-share')) {
      showNotif('‚ö†Ô∏è A whole-vault recipient is already set. Remove it first.', 'error'); return;
    }
    const short = recipient.slice(0,4) + '...' + recipient.slice(-4);
    // Merge: remove any existing specific transfers/burns to this same address
    const beforeCount = ghostState.ghost.beneficiaries.length;
    ghostState.ghost.beneficiaries = ghostState.ghost.beneficiaries.filter(b => {
      const bAddr = (b.fullAddr || b.recipient || '').toLowerCase();
      const newAddr = recipient.toLowerCase();
      const shortMatch = bAddr === short.toLowerCase();
      const fullMatch = b.fullAddr && b.fullAddr.toLowerCase() === newAddr;
      return !(shortMatch || fullMatch);
    });
    const mergedCount = beforeCount - ghostState.ghost.beneficiaries.length;
    ghostState.ghost.beneficiaries.push({
      recipient: short, fullAddr: recipient,
      sharePct: 100, amount: 0,
      token: 'üëª 100% of vault',
      action: 'whole-vault-share', executed: false
    });
    document.getElementById('newRecipient').value = '';
    _refreshBenePickers();
    renderBeneficiaries();
    saveSession();
    const mergeNote = mergedCount > 0 ? ' ¬∑ merged ' + mergedCount + ' existing entr' + (mergedCount === 1 ? 'y' : 'ies') : '';
    showNotif('üëª Entire vault ‚Üí ' + short + mergeNote, 'green');
    addActivityRow('üëª Whole vault 100% ‚Üí ' + short, randomTx());
    return;
  }

  const amountInput = isBurn ? 'burnAmount' : 'newAmount';
  const amount = parseFloat(document.getElementById(amountInput).value);
  if (!amount || amount <= 0) { showNotif('Enter a valid amount', 'error'); return; }

  // Validate against vault balance
  const vaultToken = ghostState.vaultTokens.find(v => v.symbol === t.symbol || v.mint === t.mint);
  if (!vaultToken) { showNotif('‚ö†Ô∏è ' + t.symbol + ' is not in your vault', 'error'); return; }
  const alreadyAssigned = ghostState.ghost.beneficiaries
    .filter(b => b.token === t.symbol)
    .reduce((sum, b) => sum + b.amount, 0);
  const remaining = vaultToken.balance - alreadyAssigned;
  if (amount > remaining) {
    showNotif('‚ö†Ô∏è Only ' + remaining.toLocaleString() + ' ' + t.symbol + ' available to assign', 'error');
    return;
  }

  let recipient = '(burn)';
  if (!isBurn) {
    recipient = document.getElementById('newRecipient').value.trim();
    if (!recipient || recipient.length < 32) { showNotif('‚ö†Ô∏è Enter a valid Solana recipient address', 'error'); return; }
    const transfers = ghostState.ghost.beneficiaries.filter(b => b.action !== 'burn');
    if (transfers.length >= 10) { showNotif('‚ö†Ô∏è Maximum 10 transfer beneficiaries', 'error'); return; }
  }

  const short = isBurn ? '(burn)' : recipient.slice(0,4)+'...'+recipient.slice(-4);

  // If this recipient already has a whole-vault-share, merge: remove it and replace with specific entry
  let mergedFromWhole = false;
  if (!isBurn && recipient && recipient !== '(burn)') {
    const recipShort = short;
    const recipFull = recipient.toLowerCase();
    const wholeIdx = ghostState.ghost.beneficiaries.findIndex(b => {
      if (b.action !== 'whole-vault-share') return false;
      const bAddr = (b.fullAddr || '').toLowerCase();
      const bShort = (b.recipient || '').toLowerCase();
      return bAddr === recipFull || bShort === recipShort.toLowerCase();
    });
    if (wholeIdx !== -1) {
      ghostState.ghost.beneficiaries.splice(wholeIdx, 1);
      mergedFromWhole = true;
    }
  }

  // Demo mode
  if (!ghostState.provider || ghostState.walletName?.includes('demo')) {
    ghostState.ghost.beneficiaries.push({ recipient: short, fullAddr: isBurn ? null : recipient, amount, token: t.symbol, action, executed: false });
    _refreshBenePickers();
    renderBeneficiaries();
    renderVaultHoldings();
    document.getElementById(amountInput).value = '';
    if (!isBurn) document.getElementById('newRecipient').value = '';
    const mergeNote = mergedFromWhole ? ' ¬∑ whole-vault assignment replaced' : '';
    const msg = isBurn ? 'üî• Burn instruction added' : ('‚úÖ Beneficiary added' + mergeNote);
    addActivityRow(isBurn ? 'üî• Burn instruction added [demo]' : 'üìã Beneficiary added [demo]', randomTx());
    showNotif(msg, 'green');
    saveSession();
    return;
  }

  // Real transaction
  try {
    showNotif(isBurn ? 'Adding burn instruction...' : 'Adding beneficiary...', '');
    const { PublicKey, Transaction, TransactionInstruction } = solanaWeb3;
    const walletPubkey = new PublicKey(ghostState.publicKey);
    const ghostPda = new PublicKey(ghostState.ghostPda);
    const programId = new PublicKey(PROGRAM_ID);

    const discriminator = [105, 214, 106, 141, 180, 166, 123, 238];

    // Args: recipient(Pubkey=32), amount(u64=8), token_mint(Option<Pubkey>=33), action(u8=1) = 74 bytes
    // amount must be in base units (6 decimals)
    const amountRaw = BigInt(Math.round(amount * 1_000_000));
    const buf = new ArrayBuffer(32 + 8 + 33 + 1);
    const dv = new DataView(buf);
    const bufBytes = new Uint8Array(buf);

    // recipient: Pubkey (32 bytes) ‚Äî zero for burn
    if (!isBurn) {
      bufBytes.set(new PublicKey(recipient).toBytes(), 0);
    }
    // amount: u64 (8 bytes at offset 32)
    dv.setBigUint64(32, amountRaw, true);
    // token_mint: Option<Pubkey> (33 bytes at offset 40)
    // Use GHOST_MINT as the token_mint for now (vault holds SPL tokens)
    // tag=0 means None (no specific mint required by program for tracking purposes)
    bufBytes[40] = 0; // None tag
    bufBytes.fill(0, 41, 73); // 32 zero bytes
    // action: u8 (offset 73) ‚Äî 0=Transfer, 1=Burn
    bufBytes[73] = isBurn ? 1 : 0;

    const data = new Uint8Array(8 + buf.byteLength);
    data.set(discriminator, 0);
    data.set(bufBytes, 8);

    // ManageBeneficiaries context: ghost(mut), signer(mut)
    const ix = new TransactionInstruction({ programId,
      keys: [
        { pubkey: ghostPda,    isSigner: false, isWritable: true },
        { pubkey: walletPubkey, isSigner: true,  isWritable: true },
      ],
      data });

    const connection = new solanaWeb3.Connection(RPC_URL, 'confirmed');
    const { blockhash } = await connection.getLatestBlockhash();
    const tx = new Transaction({ recentBlockhash: blockhash, feePayer: walletPubkey });
    tx.add(ix);
    // Debug: log each instruction individually so console doesn't collapse
    tx.instructions.forEach((ix, i) => 
      console.log(`[Ghost] ix${i}: prog=${ix.programId.toBase58()} accounts=${ix.keys.length} data=${ix.data.length}b`)
    );
    const signed = await ghostState.provider.signTransaction(tx);
    const sig = await connection.sendRawTransaction(signed.serialize(), { skipPreflight: true, preflightCommitment: 'confirmed' });
    console.log('[Ghost] TX sent:', sig);
    const conf = await connection.confirmTransaction(sig, 'confirmed');
    console.log('[Ghost] TX confirmed:', conf);
    if (conf.value?.err) throw new Error('TX failed: ' + JSON.stringify(conf.value.err));
    const shortSig = sig.slice(0,4)+'...'+sig.slice(-4);

    ghostState.ghost.beneficiaries.push({ recipient: short, fullAddr: isBurn ? null : recipient, amount, token: t.symbol, action, executed: false });
    _refreshBenePickers();
    renderBeneficiaries();
    renderVaultHoldings();
    document.getElementById(amountInput).value = '';
    if (!isBurn) document.getElementById('newRecipient').value = '';
    addActivityRow(isBurn ? 'üî• Burn instruction on-chain' : 'üìã Beneficiary added on-chain', shortSig);
    const mergeNote2 = mergedFromWhole ? ' ¬∑ whole-vault assignment replaced' : '';
    showNotif(isBurn ? 'üî• Burn instruction confirmed!' : ('‚úÖ Beneficiary added on-chain!' + mergeNote2), 'green');
  } catch(err) {
    console.error('Add beneficiary error:', err);
    showNotif('Failed: ' + (err.message || err), 'error');
  }
}

function dbRemoveBeneficiary(index) {
  if (!confirm('Remove this beneficiary?')) return;
  ghostState.ghost.beneficiaries.splice(index, 1);
  _refreshBenePickers();
  renderBeneficiaries();
  renderVaultHoldings(); // re-enable vault withdraw inputs now assignment is cleared
  saveSession();
  showNotif('‚úÖ Removed', 'green');
}

// ‚îÄ‚îÄ‚îÄ Bene amount helpers ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function updateBeneRemaining() {
  const t = ghostState.selectedTokens.bene;
  const lbl = document.getElementById('beneRemainingLabel');
  if (!lbl || !t) return;
  const vt = ghostState.vaultTokens.find(v => v.mint === t.mint);
  if (!vt) return;
  const assigned = ghostState.ghost.beneficiaries
    .filter(b => b.token === t.symbol && b.action !== 'whole-vault-share')
    .reduce((s, b) => s + b.amount, 0);
  const rem = vt.balance - assigned;
  lbl.textContent = '¬∑ ' + rem.toLocaleString() + ' ' + t.symbol + ' remaining';
  lbl.style.color = rem <= 0 ? '#ff3d5a' : 'var(--muted)';
}

function fillMaxBene() {
  const t = ghostState.selectedTokens.bene;
  if (!t) return;
  const vt = ghostState.vaultTokens.find(v => v.mint === t.mint);
  if (!vt) return;
  const assigned = ghostState.ghost.beneficiaries
    .filter(b => b.token === t.symbol && b.action !== 'whole-vault-share')
    .reduce((s, b) => s + b.amount, 0);
  const rem = Math.max(0, vt.balance - assigned);
  document.getElementById('newAmount').value = rem;
  updateBeneRemaining();
}

// ‚îÄ‚îÄ‚îÄ Whole vault plan ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
if (!ghostState.ghost.wholeVaultShares) ghostState.ghost.wholeVaultShares = [];

function renderWholeVaultShares() {
  const shares = ghostState.ghost.wholeVaultShares || [];
  const el = document.getElementById('wholeVaultShares');
  if (!el) return;
  if (shares.length === 0) { el.innerHTML = ''; return; }
  const totalPct = shares.reduce((s, x) => s + x.pct, 0);
  el.innerHTML = shares.map((s, i) => `
    <div style="display:flex;align-items:center;gap:10px;padding:8px 12px;background:rgba(102,51,255,0.04);border:1px solid rgba(160,128,255,0.1);margin-bottom:6px">
      <span style="font-family:'Share Tech Mono',monospace;font-size:12px;color:#c0a0ff;width:44px">${s.pct}%</span>
      <span style="font-family:'Share Tech Mono',monospace;font-size:11px;color:#f0f0f8;flex:1">${s.addr}</span>
      <button class="icon-btn" onclick="removeWholeVaultShare(${i})" style="color:#ff6666">‚úï</button>
    </div>`).join('') +
    `<div style="font-family:'Share Tech Mono',monospace;font-size:11px;color:${totalPct===100?'#33ff99':totalPct>100?'#ff3d5a':'#ff9933'};margin-top:4px">
      Total: ${totalPct}% ${totalPct===100?'‚úì Complete':totalPct>100?'‚ö†Ô∏è Over 100%':'‚Äî '+(100-totalPct)+'% unassigned'}
    </div>`;
  updateSharePreview();
}

function updateSharePreview() {
  const el = document.getElementById('wholeVaultPreview');
  if (!el) return;
  const pct = 100; // always 100%
  if (!pct || pct <= 0) { el.textContent = ''; return; }
  // Show what this share would receive from current vault
  const lines = ghostState.vaultTokens
    .filter(v => v.balance > 0)
    .map(v => {
      const amt = (v.balance * pct / 100);
      const price = getTokenPrice(v);
      const usd = price > 0 ? ' (~$' + (amt * price).toFixed(2) + ')' : '';
      return amt.toLocaleString(undefined, {maximumFractionDigits:4}) + ' ' + v.symbol + usd;
    });
  el.textContent = lines.length ? pct + '% share = ' + lines.join(' + ') : 'Deposit assets to vault first';
}

function addWholeVaultShare() {
  const addr = document.getElementById('wholeVaultAddr').value.trim();
  const pct = parseFloat(document.getElementById('wholeVaultPct').value);
  if (!addr || addr.length < 32) { showNotif('‚ö†Ô∏è Enter a valid Solana address', 'error'); return; }
  if (!pct || pct <= 0 || pct > 100) { showNotif('‚ö†Ô∏è Enter a share between 1 and 100', 'error'); return; }
  if (!ghostState.ghost.wholeVaultShares) ghostState.ghost.wholeVaultShares = [];
  const total = ghostState.ghost.wholeVaultShares.reduce((s, x) => s + x.pct, 0);
  if (total + pct > 100) { showNotif('‚ö†Ô∏è Total shares would exceed 100% (' + (total + pct) + '%)', 'error'); return; }
  const short = addr.slice(0,4) + '...' + addr.slice(-4);
  ghostState.ghost.wholeVaultShares.push({ addr: short, fullAddr: addr, pct });
  document.getElementById('wholeVaultAddr').value = '';
  document.getElementById('wholeVaultPct').value = '';
  renderWholeVaultShares();
}

function removeWholeVaultShare(i) {
  ghostState.ghost.wholeVaultShares.splice(i, 1);
  renderWholeVaultShares();
}

function dbSaveWholeVaultPlan() {
  const shares = ghostState.ghost.wholeVaultShares || [];
  if (shares.length === 0) { showNotif('Add at least one recipient share first', 'error'); return; }
  const totalPct = shares.reduce((s, x) => s + x.pct, 0);
  if (totalPct !== 100) { showNotif('‚ö†Ô∏è Shares must total exactly 100% (currently ' + totalPct + '%)', 'error'); return; }
  if (ghostState.vaultTokens.length === 0) { showNotif('‚ö†Ô∏è Vault is empty ‚Äî deposit assets first', 'error'); return; }

  // Remove any existing whole-vault-share entries, replace with new plan
  ghostState.ghost.beneficiaries = ghostState.ghost.beneficiaries.filter(b => b.action !== 'whole-vault-share');
  for (const s of shares) {
    ghostState.ghost.beneficiaries.push({
      recipient: s.addr,
      fullAddr: s.fullAddr,
      sharePct: s.pct,
      amount: 0, // calculated at execution time
      token: 'VAULT √ó' + s.pct + '%',
      action: 'whole-vault-share',
      executed: false
    });
  }
  renderBeneficiaries();
  saveSession();
  showNotif('üëª Whole vault plan saved ¬∑ ' + shares.length + ' recipient' + (shares.length > 1 ? 's' : '') + ' ¬∑ ' + totalPct + '%', 'green');
  addActivityRow('üëª Whole vault plan: ' + shares.map(s => s.pct + '% ‚Üí ' + s.addr).join(', '), randomTx());
}

// ‚îÄ‚îÄ‚îÄ Vault ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ




// ‚îÄ‚îÄ‚îÄ Settings ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ






// ‚îÄ‚îÄ‚îÄ Recovery ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ




// ‚îÄ‚îÄ‚îÄ Watcher ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
async function dbLookupSoul() {
  const addr = document.getElementById('soulToCheck').value.trim();
  if (!addr) { showNotif('Enter a wallet address'); return; }
  
  const result = document.getElementById('watcherResult');
  result.classList.add('visible');
  result.innerHTML = '<span style="color:#c0bce0">Looking up soul...</span>';

  try {
    // Derive ghost PDA for this address
    const { PublicKey } = solanaWeb3;
    const wallet = new PublicKey(addr);
    const programId = new PublicKey(PROGRAM_ID);
    const [ghostPda] = PublicKey.findProgramAddressSync(
      [new TextEncoder().encode('ghost'), wallet.toBytes()],
      programId
    );

    const response = await fetch(RPC_URL, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        jsonrpc: '2.0', id: 1,
        method: 'getAccountInfo',
        params: [ghostPda.toString(), { encoding: 'base64' }]
      })
    });
    const data = await response.json();

    if (!data.result?.value) {
      result.innerHTML = `
        <span style="color:#c0bce0">SOUL</span> &nbsp;${addr.slice(0,8)}...<br>
        <span style="color:#c0bce0">STATUS</span> &nbsp;<span style="color:#c0bce0">NO GHOST FOUND</span><br>
        <span style="color:rgba(120,80,255,0.4)">// This address has no ghost protocol account</span>
      `;
      return;
    }

    // Decode basic info
    const rawData = atob(data.result.value.data[0]);
    const bytes = new Uint8Array(rawData.length);
    for (let i = 0; i < rawData.length; i++) bytes[i] = rawData.charCodeAt(i);
    const view = new DataView(bytes.buffer);
    
    let offset = 8 + 32; // skip discriminator + owner
    // recovery_wallet: Option<Pubkey> - Borsh None=1byte, Some=33bytes
    const rTag = bytes[offset]; offset += 1;
    if (rTag === 1) offset += 32;
    const lastBeat = Number(view.getBigInt64(offset, true)); offset += 8;
    const interval = Number(view.getBigInt64(offset, true)); offset += 8;
    const grace = Number(view.getBigInt64(offset, true)); offset += 8;
    const awakened = bytes[offset] === 1; offset += 1;
    // awakened_at: Option<i64> - None=1byte, Some=9bytes
    const awTag = bytes[offset]; offset += 1;
    if (awTag === 1) offset += 8;
    const executed = bytes[offset] === 1;

    const now = Math.floor(Date.now() / 1000);
    const silenceSeconds = now - lastBeat;
    const remainingSeconds = Math.max(0, interval - silenceSeconds);
    const remainingDays = Math.floor(remainingSeconds / 86400);
    const lastPingDays = Math.floor(silenceSeconds / 86400);

    let status, statusColor, statusNote;
    if (executed) {
      status = 'EXECUTED'; statusColor = '#ff3366';
      statusNote = '// Ghost has been executed ‚Äî assets distributed';
    } else if (awakened) {
      status = 'AWAKENED üëª'; statusColor = '#ffaa33';
      statusNote = '// Grace period active ‚Äî recovery wallet can still cancel';
    } else if (silenceSeconds > interval) {
      status = 'SILENT ‚ö†Ô∏è'; statusColor = '#ffaa33';
      statusNote = '// Silence detected ‚Äî grace period may be active';
    } else {
      status = 'ALIVE'; statusColor = '#33ff99';
      statusNote = '// Soul is alive (' + remainingDays + ' days remaining)';
    }

    result.innerHTML = `
      <span style="color:#c0bce0">SOUL</span> &nbsp;${addr.slice(0,8)}...<br>
      <span style="color:#c0bce0">GHOST PDA</span> &nbsp;${ghostPda.toString().slice(0,8)}...<br>
      <span style="color:#c0bce0">STATUS</span> &nbsp;<span style="color:${statusColor}">${status}</span><br>
      <span style="color:#c0bce0">LAST PING</span> &nbsp;${lastPingDays} days ago<br>
      <span style="color:#c0bce0">INTERVAL</span> &nbsp;${Math.floor(interval/86400)} days<br>
      <span style="color:#c0bce0">GRACE PERIOD</span> &nbsp;${Math.floor(grace/86400)} days<br>
      <span style="color:rgba(120,80,255,0.4)">${statusNote}</span>
    `;
  } catch(err) {
    result.innerHTML = '<span style="color:var(--pulse)">Error: ' + (err.message || err) + '</span>';
  }
}

async function cancelAwakening() {
  if (!ghostState.provider || ghostState.walletName?.includes('demo')) {
    ghostState.ghost.status = 'alive';
    ghostState.ghost.awakened = false;
    ghostState.ghost.awakenedAt = null;
    ghostState.ghost.lastHeartbeat = Date.now();
    showNotif('‚úÖ Awakening cancelled [demo]', 'green');
    renderDashboard();
    return;
  }
  try {
    showNotif('Cancelling awakening...', '');
    const { PublicKey, Transaction, TransactionInstruction } = solanaWeb3;
    const walletPk = new PublicKey(ghostState.publicKey);
    // cancel_awakening can be called by owner OR recovery wallet
    // ghostPda derived from the OWNER's key, not necessarily connected wallet
    const ownerKey = ghostState.ghost.ownerPubkey || ghostState.publicKey;
    const [ghostPda] = await PublicKey.findProgramAddress(
      [new TextEncoder().encode('ghost'), new PublicKey(ownerKey).toBytes()],
      new PublicKey(PROGRAM_ID)
    );
    const programId = new PublicKey(PROGRAM_ID);

    // Discriminator: sha256("global:cancel_awakening")[0:8]
    const disc = [22, 144, 208, 215, 15, 165, 157, 122]; // sha256('global:cancel_awakening')[0:8]
    const ix = new TransactionInstruction({
      programId,
      keys: [
        { pubkey: ghostPda, isSigner: false, isWritable: true },
        { pubkey: walletPk, isSigner: true, isWritable: false },
      ],
      data: new Uint8Array(disc)
    });

    const connection = new solanaWeb3.Connection(RPC_URL, 'confirmed');
    const { blockhash } = await connection.getLatestBlockhash();
    const tx = new Transaction({ recentBlockhash: blockhash, feePayer: walletPk });
    tx.add(ix);
    // Debug: log each instruction individually so console doesn't collapse
    tx.instructions.forEach((ix, i) => 
      console.log(`[Ghost] ix${i}: prog=${ix.programId.toBase58()} accounts=${ix.keys.length} data=${ix.data.length}b`)
    );
    const signed = await ghostState.provider.signTransaction(tx);
    const sig = await connection.sendRawTransaction(signed.serialize(), { skipPreflight: true });
    await connection.confirmTransaction(sig, 'confirmed');

    ghostState.ghost.status = 'alive';
    ghostState.ghost.awakened = false;
    ghostState.ghost.awakenedAt = null;
    ghostState.ghost.lastHeartbeat = Date.now();
    showNotif('‚úÖ Awakening cancelled!', 'green');
    renderDashboard();
    addActivityRow('üõë Awakening cancelled', sig.slice(0,4)+'...'+sig.slice(-4));
  } catch(err) {
    showNotif('Cancel failed: ' + (err.message || err), 'error');
  }
}

// ‚îÄ‚îÄ‚îÄ Recovery wallet mode ‚Äî check if connected wallet is someone's recovery ‚îÄ‚îÄ
function setWatcherMode(mode) {
  const obs = document.getElementById('watcherPanelObserve');
  const grd = document.getElementById('watcherPanelGuardian');
  const btnObs = document.getElementById('watcherModeObserve');
  const btnGrd = document.getElementById('watcherModeGuardian');
  if (mode === 'observe') {
    obs.style.display = ''; grd.style.display = 'none';
    btnObs.style.background = 'rgba(102,51,255,0.2)'; btnObs.style.color = '#c8a8ff';
    btnObs.style.border = '1px solid rgba(102,51,255,0.4)';
    btnGrd.style.background = 'transparent'; btnGrd.style.color = '#606080';
    btnGrd.style.border = '1px solid rgba(102,51,255,0.15)';
  } else {
    obs.style.display = 'none'; grd.style.display = '';
    btnGrd.style.background = 'rgba(255,153,102,0.15)'; btnGrd.style.color = '#ffcc99';
    btnGrd.style.border = '1px solid rgba(255,153,102,0.5)';
    btnObs.style.background = 'transparent'; btnObs.style.color = '#606080';
    btnObs.style.border = '1px solid rgba(102,51,255,0.15)';
  }
}

async function scanGuardianAssignments() {
  if (!ghostState.publicKey) { showNotif('Connect your wallet first', 'error'); return; }
  const statusEl = document.getElementById('guardianScanStatus');
  const listEl = document.getElementById('guardianAssignmentsList');
  const scanEl = document.getElementById('guardianScanState');

  statusEl.textContent = '‚ü≥ Scanning chain for ghost accounts...';
  statusEl.style.color = '#c0a0ff';

  try {
    const { PublicKey } = solanaWeb3;
    const connection = new solanaWeb3.Connection(RPC_URL, 'confirmed');
    const programId = new PublicKey(PROGRAM_ID);
    const myPk = new PublicKey(ghostState.publicKey);
    const myBytes = myPk.toBytes();

    // getProgramAccounts with memcmp filter:
    // GhostAccount layout after 8-byte discriminator:
    // owner(32), recovery_wallet tag(1), recovery_wallet pubkey(32)
    // Filter: offset 8+32+1 = 41, match my 32-byte pubkey
    const accounts = await connection.getProgramAccounts(programId, {
      filters: [
        { memcmp: { offset: 41, bytes: myPk.toBase58() } }
      ]
    });

    if (accounts.length === 0) {
      statusEl.textContent = '‚Äî No guardian assignments found for this wallet';
      statusEl.style.color = '#9090a8';
      return;
    }

    statusEl.textContent = '';
    scanEl.style.paddingBottom = '0';

    // Decode each account
    const cards = [];
    for (const { pubkey, account } of accounts) {
      try {
        const bytes = new Uint8Array(account.data);
        const view = new DataView(bytes.buffer);
        let off = 8;
        // owner pubkey
        const ownerBytes = bytes.slice(off, off+32); off += 32;
        const B58 = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';
        let n = 0n; for (const b of ownerBytes) n = n*256n+BigInt(b);
        let ownerB58 = ''; let tmp = n;
        while(tmp>0n){ownerB58=B58[Number(tmp%58n)]+ownerB58;tmp=tmp/58n;}
        // skip recovery wallet (1+32)
        const rTag = bytes[off]; off++;
        if (rTag===1) off+=32;
        // last_heartbeat, interval, grace
        const lastBeat = Number(view.getBigInt64(off,true)); off+=8;
        const interval = Number(view.getBigInt64(off,true)); off+=8;
        const grace = Number(view.getBigInt64(off,true)); off+=8;
        // awakened
        const awakened = bytes[off]===1; off++;
        // awakened_at
        const awTag = bytes[off]; off++;
        if(awTag===1) off+=8;
        // executed
        const executed = bytes[off]===1;

        const now = Math.floor(Date.now()/1000);
        const silenceSeconds = now - lastBeat;
        const remainingSeconds = Math.max(0, interval - silenceSeconds);
        const daysSince = Math.floor(silenceSeconds/86400);
        const daysLeft = Math.floor(remainingSeconds/86400);
        const statusColor = executed ? '#ff3366' : awakened ? '#ffaa33' : '#33ff99';
        const statusText = executed ? 'EXECUTED' : awakened ? '‚ö†Ô∏è AWAKENED' : '‚úÖ ALIVE';
        const graceLeft = awakened ? Math.max(0, Math.floor((grace - silenceSeconds + interval)/86400)) : 0;

        cards.push(`
          <div style="background:#07070f;border:1px solid ${awakened?'rgba(255,170,51,0.35)':'rgba(102,51,255,0.2)'};padding:20px 22px;margin-bottom:12px" data-owner="${ownerB58}" data-awakened="${awakened}" data-executed="${executed}">
            <div style="display:flex;justify-content:space-between;align-items:flex-start;margin-bottom:14px">
              <div>
                <div style="font-family:'Share Tech Mono',monospace;font-size:11px;color:var(--muted);letter-spacing:0.15em;margin-bottom:4px">SOUL</div>
                <div style="font-family:'Share Tech Mono',monospace;font-size:13px;color:#e0ddf0">${ownerB58.slice(0,8)}...${ownerB58.slice(-6)}</div>
              </div>
              <div style="text-align:right">
                <div style="font-family:'Share Tech Mono',monospace;font-size:11px;color:var(--muted);letter-spacing:0.15em;margin-bottom:4px">STATUS</div>
                <div style="font-family:'Share Tech Mono',monospace;font-size:13px;color:${statusColor}">${statusText}</div>
              </div>
            </div>
            <div style="display:flex;gap:24px;font-family:'Share Tech Mono',monospace;font-size:12px;color:#9090a8;margin-bottom:${awakened&&!executed?'16':'0'}px">
              <span>Last ping: <span style="color:#c0bce0">${daysSince}d ago</span></span>
              <span>Interval: <span style="color:#c0bce0">${Math.floor(interval/86400)}d</span></span>
              ${awakened&&!executed ? `<span>Grace left: <span style="color:#ffaa33">${graceLeft}d</span></span>` : `<span>Time left: <span style="color:#c0bce0">${daysLeft}d</span></span>`}
            </div>
            ${!executed && awakened ? `
            <div style="display:flex;gap:8px;padding-top:14px;border-top:1px solid rgba(255,170,51,0.15)">
              <button class="db-btn" style="flex:1;border-color:#ffaa33;color:#ffaa33;padding:10px" onclick="guardianCancelAwakening('${ownerB58}')">üõë Cancel Awakening</button>
              <button class="db-btn" style="flex:1;border-color:#c0a0ff;color:#c0a0ff;padding:10px" onclick="guardianWithdrawAll('${ownerB58}')">üì§ Withdraw Vault</button>
            </div>` : !executed ? `
            <div style="padding-top:12px;border-top:1px solid rgba(102,51,255,0.1)">
              <button class="db-btn" style="width:100%;border-color:#c0a0ff;color:#c0a0ff;padding:10px;opacity:0.6" onclick="guardianWithdrawAll('${ownerB58}')">üì§ Withdraw Vault (if authorized)</button>
            </div>` : ''}
          </div>`);
      } catch(e) { /* skip malformed */ }
    }

    listEl.innerHTML = `
      <div style="font-family:'Share Tech Mono',monospace;font-size:11px;letter-spacing:0.2em;color:var(--muted);margin-bottom:14px">${cards.length} SOUL${cards.length!==1?'S':''} UNDER YOUR PROTECTION</div>
      ${cards.join('')}`;
    listEl.style.display = '';
  } catch(err) {
    statusEl.textContent = 'Scan failed: ' + (err.message||err);
    statusEl.style.color = '#ff3366';
  }
}

async function guardianCancelAwakening(ownerAddress) {
  ghostState.ghost.ownerPubkey = ownerAddress;
  await cancelAwakening();
  await scanGuardianAssignments(); // refresh
}

async function guardianWithdrawAll(ownerAddress) {
  showNotif('Guardian vault withdrawal coming soon', 'error');
  // TODO: call withdraw_from_vault for each token in the vault
}

async function checkIfRecoveryWallet() {
  if (!ghostState.publicKey) return;
  // This requires an indexer in production. For now, expose manual entry:
  // User can paste the soul's address to act as their recovery wallet
  const soul = document.getElementById('recoverySoulInput')?.value?.trim();
  if (!soul) return;
  try {
    const { PublicKey } = solanaWeb3;
    const [ghostPda] = await PublicKey.findProgramAddress(
      [new TextEncoder().encode('ghost'), new PublicKey(soul).toBytes()],
      new PublicKey(PROGRAM_ID)
    );
    const connection = new solanaWeb3.Connection(RPC_URL, 'confirmed');
    const acct = await connection.getAccountInfo(ghostPda);
    if (!acct) { showNotif('No ghost found for that address', 'error'); return; }
    // Decode to verify recovery wallet matches connected wallet
    const bytes = new Uint8Array(acct.data);
    const view = new DataView(bytes.buffer);
    let off = 8 + 32; // skip disc + owner
    const rTag = bytes[off]; off++;
    if (rTag !== 1) { showNotif('This ghost has no recovery wallet set', 'error'); return; }
    // Decode recovery wallet pubkey
    const B58 = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';
    const pkBytes = bytes.slice(off, off+32); off += 32;
    let n = BigInt(0);
    for (const b of pkBytes) n = n * 256n + BigInt(b);
    let r = ''; let tmp = n;
    while (tmp > 0n) { const rem = Number(tmp % 58n); r = B58[rem] + r; tmp = tmp / 58n; }
    const recovPk = r;
    if (!recovPk.includes(ghostState.publicKey.slice(0,8))) {
      // Check full match
      const connectedBytes = new PublicKey(ghostState.publicKey).toBytes();
      const match = pkBytes.every((b,i) => b === connectedBytes[i]);
      if (!match) { showNotif('Your wallet is not the recovery wallet for this ghost', 'error'); return; }
    }
    // Set recovery mode ‚Äî store owner so cancelAwakening uses correct PDA
    ghostState.ghost.ownerPubkey = soul;
    const lastBeat = Number(view.getBigInt64(off, true)); off += 8;
    const interval = Number(view.getBigInt64(off, true)); off += 8;
    const awakened = bytes[off+8] === 1;
    const status = awakened ? '‚ö†Ô∏è AWAKENED ‚Äî you can cancel!' : '‚úÖ Alive';
    const daysSincePing = Math.floor((Date.now()/1000 - lastBeat)/86400);
    const statusColor = awakened ? '#ffaa33' : '#33ff99';
    const statusText = awakened ? '‚ö†Ô∏è AWAKENED' : '‚úÖ ALIVE';
    document.getElementById('recoveryStatusResult').innerHTML = `
      <div style="background:rgba(0,0,0,0.3);border:1px solid ${awakened ? 'rgba(255,170,51,0.4)' : 'rgba(51,255,153,0.3)'};padding:22px;font-family:'Share Tech Mono',monospace;font-size:13px;line-height:2.4;color:#e0ddf0">
        <div style="font-size:11px;letter-spacing:0.2em;color:#ff9966;margin-bottom:12px">‚úì AUTHORITY VERIFIED ‚Äî GUARDIAN ACCESS GRANTED</div>
        <div><span style="color:var(--muted)">SOUL</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;${soul.slice(0,8)}...${soul.slice(-4)}</div>
        <div><span style="color:var(--muted)">STATUS</span>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:${statusColor}">${statusText}</span></div>
        <div><span style="color:var(--muted)">LAST PING</span>&nbsp;${daysSincePing}d ago</div>
        <div><span style="color:var(--muted)">INTERVAL</span>&nbsp;&nbsp;${Math.floor(interval/86400)}d</div>
        ${awakened ? `
        <div style="margin-top:16px;padding-top:16px;border-top:1px solid rgba(255,170,51,0.2)">
          <div style="color:#ffaa33;margin-bottom:10px">‚ö† Ghost has awakened ‚Äî grace period is active. You can cancel this awakening.</div>
          <button class="db-btn" style="border-color:#ff9966;color:#ff9966;width:100%" onclick="cancelAwakening()">üõë CANCEL AWAKENING ON-CHAIN</button>
        </div>` : `
        <div style="margin-top:12px;color:rgba(51,255,153,0.5);font-size:11px">// Soul is alive ‚Äî no action required. You'll be notified if they stop pinging.</div>`}
      </div>`;
  } catch(err) {
    showNotif('Error: ' + (err.message||err), 'error');
  }
}

async function dbCheckSilence() {
  const addr = document.getElementById('soulToCheck').value.trim();
  if (!addr) { showNotif('Enter a wallet address first', 'error'); return; }
  showNotif('Checking silence... use Playground to submit checkSilence tx', 'info');
  await dbLookupSoul();
}

// ‚îÄ‚îÄ‚îÄ Wallet Token Loading & Custom Token Picker ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
ghostState.walletTokens = [];
ghostState.vaultTokens = []; // [{symbol, mint, balance, decimals}]
ghostState.selectedTokens = {}; // { deposit: token, bene: token, burn: token }

const TOKEN_LOGO_URLS = {
  'SOL':    'https://raw.githubusercontent.com/solana-labs/token-list/main/assets/mainnet/So11111111111111111111111111111111111111112/logo.png',
  'wSOL':   'https://raw.githubusercontent.com/solana-labs/token-list/main/assets/mainnet/So11111111111111111111111111111111111111112/logo.png',
  'USDC':   'https://raw.githubusercontent.com/solana-labs/token-list/main/assets/mainnet/EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v/logo.png',
  'USDT':   'https://raw.githubusercontent.com/solana-labs/token-list/main/assets/mainnet/Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB/logo.svg',
  'mSOL':   'https://raw.githubusercontent.com/solana-labs/token-list/main/assets/mainnet/mSoLzYCxHdYgdzU16g5QSh3i5K3z3KZK7ytfqcJm7So/logo.png',
  'bSOL':   'https://raw.githubusercontent.com/solana-labs/token-list/main/assets/mainnet/bSo13r4TkiE4KumL71LsHTPpL2euBYLFx6h9HP3piy1/logo.png',
  'BONK':   'https://arweave.net/hQiPZOsRZXGXBJd_82PhVdlM_hACsT_q6wqwaNV279c',
  'ETH':    'https://raw.githubusercontent.com/solana-labs/token-list/main/assets/mainnet/7vfCXTUXx5WJV5JADk17DUJ4ksgau7utNKj4b963voxs/logo.png',
  '$GHOST': null, // fallback to ghost emoji
};
const TOKEN_FALLBACK = { 'SOL':'‚óé','wSOL':'‚óé','$GHOST':'üëª','USDC':'$','USDT':'$','mSOL':'‚óé','bSOL':'‚óé','ETH':'‚ü†','BONK':'üê∂' };

function tokenLogoEl(sym, size = 32, customUrl = null) {
  // Glowing treasure chest for whole vault
  if (sym === 'Whole Vault') {
    const s = size;
    return `<span style="width:${s}px;height:${s}px;display:flex;align-items:center;justify-content:center;flex-shrink:0"><svg width="${s}" height="${s}" viewBox="0 0 36 36" fill="none" xmlns="http://www.w3.org/2000/svg" style="filter:drop-shadow(0 0 6px rgba(255,200,60,0.7)) drop-shadow(0 0 12px rgba(255,160,0,0.4))"><rect x="3" y="16" width="30" height="17" rx="2" fill="#7c4d00" stroke="#f0a020" stroke-width="1.2"/><rect x="3" y="16" width="30" height="8" rx="2" fill="#a06000" stroke="#f0a020" stroke-width="1.2"/><rect x="3" y="16" width="30" height="4" rx="1" fill="#c07800" stroke="#f0c040" stroke-width="0.8"/><rect x="2" y="8" width="32" height="11" rx="3" fill="#c07800" stroke="#f0b030" stroke-width="1.2"/><rect x="2" y="8" width="32" height="6" rx="2" fill="#d48a00" stroke="#f0c040" stroke-width="0.8"/><rect x="13" y="19" width="10" height="7" rx="1.5" fill="#f0a020" stroke="#ffd060" stroke-width="0.8"/><circle cx="18" cy="22.5" r="2" fill="#ffd060" stroke="#fff8d0" stroke-width="0.5"/><rect x="5" y="11" width="26" height="2" rx="1" fill="#e09a00" opacity="0.5"/><circle cx="8" cy="12" r="1.2" fill="#ffd060"/><circle cx="28" cy="12" r="1.2" fill="#ffd060"/><path d="M10 28 Q18 24 26 28" stroke="#ffd060" stroke-width="0.8" stroke-dasharray="2 1" opacity="0.5"/></svg></span>`;
  }
  const url = customUrl || TOKEN_LOGO_URLS[sym];
  if (url) {
    return `<img src="${url}" alt="${sym}" style="width:${size}px;height:${size}px;border-radius:50%;object-fit:cover;display:block;" onerror="this.style.display='none';this.nextSibling.style.display='flex'"><span style="display:none;width:${size}px;height:${size}px;border-radius:50%;background:rgba(102,51,255,0.2);align-items:center;justify-content:center;font-size:${Math.round(size*0.5)}px">${TOKEN_FALLBACK[sym]||'ü™ô'}</span>`;
  }
  return `<span style="width:${size}px;height:${size}px;border-radius:50%;background:rgba(102,51,255,0.2);display:flex;align-items:center;justify-content:center;font-size:${Math.round(size*0.5)}px">${TOKEN_FALLBACK[sym]||'ü™ô'}</span>`;
}
function tokenIcon(sym) { return TOKEN_FALLBACK[sym] || 'ü™ô'; }

// Per-picker token cache so selectToken can look up by mint
const _pickerTokens = {};

// Resolve display symbol ‚Äî wSOL always shown as SOL to users
function resolveDisplaySym(t) {
  if (!t) return '';
  if (t.mint === 'So11111111111111111111111111111111111111112' || t.mint === 'native') return 'SOL';
  return t.symbol || '';
}

function buildPickerDropdown(pickerId, tokens, onSelect) {
  const drop = document.getElementById(pickerId + 'PickerDrop') || document.getElementById(pickerId + 'Drop');
  if (!drop) return;
  // Store the token list for this picker keyed by mint
  _pickerTokens[pickerId] = tokens;
  // Don't rebuild while open ‚Äî patch logos in-place only
  if (drop.classList.contains('open')) {
    tokens.forEach((t) => {
      if (!t.logoUrl) return;
      const opt = drop.querySelector(`.token-picker-option[data-mint="${t.mint}"]`);
      if (!opt) return;
      const iconEl = opt.querySelector('.tp-opt-icon');
      if (iconEl && !iconEl.querySelector('img[src*="http"]')) {
        iconEl.innerHTML = tokenLogoEl(resolveDisplaySym(t), 32, t.logoUrl);
      }
    });
    return;
  }
  drop.innerHTML = tokens.map((t) => `
    <div class="token-picker-option" data-mint="${t.mint}" onclick="selectToken('${pickerId}','${t.mint}')">
      <div class="tp-opt-icon" style="overflow:hidden;background:none">${tokenLogoEl(resolveDisplaySym(t), 32, t.logoUrl||null)}</div>
      <div class="tp-opt-info">
        <div class="tp-opt-symbol">${resolveDisplaySym(t)}</div>
        <div class="tp-opt-bal">${t.isWholeVault ? 'All tokens ¬∑ proportional shares' : t.balance.toLocaleString(undefined,{maximumFractionDigits:6}) + ' available'}</div>
      </div>
      <span class="tp-opt-check" data-check="${pickerId}-${t.mint}" style="display:none">‚úì</span>
    </div>`).join('') || '<div style="padding:14px;font-family:Share Tech Mono,monospace;font-size:12px;color:#c0bce0">No tokens found</div>';
}

function selectToken(pickerId, mintOrIdx) {
  // Support both mint string lookup (new) and numeric index (legacy)
  let t;
  // Always do mint-based lookup if given a string; fall back to numeric index
  if (typeof mintOrIdx === 'string') {
    const pool = _pickerTokens[pickerId] || (pickerId === 'vault' ? ghostState.vaultTokens : ghostState.walletTokens);
    t = pool.find(tok => tok.mint === mintOrIdx);
  } else {
    const tokens = pickerId === 'vault' ? ghostState.vaultTokens : ghostState.walletTokens;
    t = tokens[mintOrIdx];
  }
  if (!t) return;
  ghostState.selectedTokens[pickerId] = t;
  // Update button label with logo
  const symEl = document.getElementById(pickerId + 'PickerSymbol');
  const balEl = document.getElementById(pickerId + 'PickerBal');
  const logoEl = document.getElementById(pickerId + 'PickerLogo');
  if (symEl) symEl.textContent = resolveDisplaySym(t);
  if (balEl) balEl.textContent = t.isWholeVault ? 'all tokens ¬∑ % shares' : t.balance.toLocaleString(undefined,{maximumFractionDigits:6}) + ' available';
  if (logoEl) logoEl.innerHTML = tokenLogoEl(resolveDisplaySym(t), 26, t.logoUrl||null);
  // Check mark ‚Äî clear all for this picker, set for selected
  document.querySelectorAll(`[data-check^="${pickerId}-"]`).forEach(el => el.style.display = 'none');
  const chk = document.querySelector(`[data-check="${pickerId}-${t.mint}"]`);
  if (chk) chk.style.display = 'inline';
  closeAllPickers();
  // Side effects
  if (pickerId === 'deposit') {
    document.getElementById('depositBalance').value = t.balance.toLocaleString(undefined,{maximumFractionDigits:6}) + ' ' + resolveDisplaySym(t);
  }
  if (pickerId === 'bene') {
    const isWhole = t.mint === '__whole_vault__';
    const amtRow = document.getElementById('beneAmountRow');
    const shareRow = document.getElementById('beneShareRow');
    if (amtRow) amtRow.style.display = isWhole ? 'none' : '';
    if (shareRow) shareRow.style.display = isWhole ? '' : 'none';
    if (!isWhole) updateBeneRemaining();
    else updateSharePreview();
  }
}

function toggleTokenPicker(id) {
  const btn = document.querySelector(`#${id}Picker .token-picker-btn`);
  const drop = document.getElementById(id + 'PickerDrop');
  if (!btn || !drop) return;
  const isOpen = drop.classList.contains('open');
  closeAllPickers();
  if (!isOpen) { drop.classList.add('open'); btn.classList.add('open'); }
}

function closeAllPickers() {
  document.querySelectorAll('.token-picker-dropdown').forEach(d => d.classList.remove('open'));
  document.querySelectorAll('.token-picker-btn').forEach(b => b.classList.remove('open'));
}
document.addEventListener('click', e => {
  if (!e.target.closest('.token-picker')) closeAllPickers();
});


// ‚îÄ‚îÄ‚îÄ wSOL wrap/unwrap helpers ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// SOL is displayed as "SOL" everywhere but stored/transferred as wSOL internally.
// wrap: create/fund a temp wSOL ATA, sync balance, return ATA pubkey
// unwrap: close the wSOL ATA back to native SOL (sends lamports to owner)

const WSOL_MINT = 'So11111111111111111111111111111111111111112';
const TOKEN_PROGRAM_ID_PK = () => new solanaWeb3.PublicKey('TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA');
const ASSOC_TOKEN_PROGRAM_ID_PK = () => new solanaWeb3.PublicKey('ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJe1bso');
const SYSTEM_PROGRAM_ID_PK = () => solanaWeb3.SystemProgram.programId;

async function deriveATA(ownerPubkey, mintPubkey) {
  const [ata] = await solanaWeb3.PublicKey.findProgramAddress(
    [ownerPubkey.toBytes(), TOKEN_PROGRAM_ID_PK().toBytes(), mintPubkey.toBytes()],
    ASSOC_TOKEN_PROGRAM_ID_PK()
  );
  return ata;
}

// Build instruction to create ATA if it doesn't exist
function createATAInstruction(payer, ata, owner, mint, tokenProgram) {
  const { PublicKey } = solanaWeb3;
  const tokenProg = tokenProgram || TOKEN_PROGRAM_ID_PK();
  // Idempotent create [1]: 6 accounts only ‚Äî no rent sysvar needed
  const keys = [
    { pubkey: payer,                   isSigner: true,  isWritable: true  },
    { pubkey: ata,                     isSigner: false, isWritable: true  },
    { pubkey: owner,                   isSigner: false, isWritable: false },
    { pubkey: mint,                    isSigner: false, isWritable: false },
    { pubkey: SYSTEM_PROGRAM_ID_PK(), isSigner: false, isWritable: false },
    { pubkey: tokenProg,               isSigner: false, isWritable: false },
  ];
  return new solanaWeb3.TransactionInstruction({
    programId: ASSOC_TOKEN_PROGRAM_ID_PK(),
    keys,
    data: new Uint8Array(0) // standard create (empty buffer) ‚Äî idempotent [1] fails on some nodes
  });
}

// Wrap native SOL into a wSOL token account
// If wSOL ATA already exists ‚Üí reuse it (transfer + syncNative only)
// If not ‚Üí create via manual keypair (ATA program unreliable on some nodes)
// Returns { instructions, wsolAta, kp } ‚Äî kp is non-null only when new account created
async function buildWrapSOLInstructions(walletPubkey, lamports, connection) {
  const { Keypair, SystemProgram, TransactionInstruction, PublicKey } = solanaWeb3;
  const mintPk = new PublicKey(WSOL_MINT);
  const TOKEN_PROG = TOKEN_PROGRAM_ID_PK();
  const instructions = [];

  const wsolAta = await deriveATA(walletPubkey, mintPk);
  const existing = connection ? await connection.getAccountInfo(wsolAta) : null;
  console.log('[Ghost] wSOL ATA:', wsolAta.toBase58(), 'exists:', !!existing);

  let wsolAcct = wsolAta;
  let kp = null;

  if (!existing) {
    // createAccount with lamports = rent + wrapAmount
    // Per SPL docs: InitializeAccount sets token balance = SOL balance at init time
    // So we bake the wrap amount directly into createAccount ‚Äî no transfer+syncNative needed
    kp = Keypair.generate();
    wsolAcct = kp.publicKey;
    const space = 165;
    const rent = connection ? await connection.getMinimumBalanceForRentExemption(space) : 2039280;
    instructions.push(SystemProgram.createAccount({
      fromPubkey: walletPubkey, newAccountPubkey: wsolAcct,
      lamports: rent + Number(lamports), // rent + wrap amount = token balance at init
      space, programId: TOKEN_PROG
    }));
    const initData = new Uint8Array(33);
    initData[0] = 18; // InitializeAccount3 opcode
    initData.set(walletPubkey.toBytes(), 1); // owner = wallet
    instructions.push(new TransactionInstruction({
      programId: TOKEN_PROG,
      keys: [{ pubkey: wsolAcct, isSigner: false, isWritable: true },
             { pubkey: mintPk,   isSigner: false, isWritable: false }],
      data: initData
    }));
    console.log('[Ghost] wSOL keypair account:', wsolAcct.toBase58(), 'lamports:', rent + Number(lamports));
  } else {
    // Account already exists ‚Äî transfer additional SOL and sync
    instructions.push(SystemProgram.transfer({
      fromPubkey: walletPubkey, toPubkey: wsolAcct, lamports: Number(lamports)
    }));
    instructions.push(new TransactionInstruction({
      programId: TOKEN_PROG,
      keys: [{ pubkey: wsolAcct, isSigner: false, isWritable: true }],
      data: new Uint8Array([17]) // SyncNative
    }));
  }

  return { instructions, wsolAta: wsolAcct, kp };
}

// Unwrap wSOL ATA back to native SOL by closing the account
// CloseAccount sends lamports (wSOL balance + rent) to destination
async function buildUnwrapSOLInstructions(walletPubkey, wsolAta) {
  // CloseAccount instruction: opcode 9
  // Accounts: [account(mut), destination(mut), authority]
  const data = new Uint8Array([9]);
  return [new solanaWeb3.TransactionInstruction({
    programId: TOKEN_PROGRAM_ID_PK(),
    keys: [
      { pubkey: wsolAta,      isSigner: false, isWritable: true  },
      { pubkey: walletPubkey, isSigner: false, isWritable: true  },
      { pubkey: walletPubkey, isSigner: true,  isWritable: false },
    ],
    data
  })];
}

// Normalise a token entry: if it's native SOL or wSOL, display as "SOL"
function displaySymbol(token) {
  if (!token) return '';
  if (token.mint === 'native' || token.mint === WSOL_MINT) return 'SOL';
  return token.symbol || '';
}
// end wSOL helpers

async function loadWalletTokens() {
  const knownSymbols = {
    'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v': 'USDC',
    'Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB': 'USDT',
    'So11111111111111111111111111111111111111112': 'wSOL',
    'mSoLzYCxHdYgdzU16g5QSh3i5K3z3KZK7ytfqcJm7So': 'mSOL',
    'bSo13r4TkiE4KumL71LsHTPpL2euBYLFx6h9HP3piy1': 'bSOL',
    '7vfCXTUXx5WJV5JADk17DUJ4ksgau7utNKj4b963voxs': 'ETH',
    'DezXAZ8z7PnrnRJjz3wXBoRgixCa6xjnB7YaB1pPB263': 'BONK',
  };

  if (!ghostState.publicKey || ghostState.walletName?.includes('demo')) {
    // Only init demo tokens once ‚Äî never overwrite if already set
    if (ghostState.walletTokens.length === 0) {
      // Preload logos/prices for demo wallet tokens
      setTimeout(() => { pumpFunFetched.clear(); priceFetched.clear(); fetchPumpFunData(); }, 800);
      const demoMints = [
        'k4MxJAdy22Dgd2UTQ9p3etbnaSLUH1q5cEfSRi6pump',
        '7opAGer4hk78N7VtYjk2bVif6SzvPkBm8PzQAvzspump',
        'BH4Dgd9cBTZDtqHjopomdfZZS4ry26qADcW13MNRpump',
      ];
      ghostState.walletTokens = [
        { symbol: 'SOL',  mint: 'native',                                                            balance: 4.99,    decimals: 9 },
        { symbol: '...',  mint: 'k4MxJAdy22Dgd2UTQ9p3etbnaSLUH1q5cEfSRi6pump',                    balance: 10000,   decimals: 6 },
        { symbol: 'USDC', mint: 'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v',                    balance: 250,     decimals: 6 },
        { symbol: '...',  mint: '7opAGer4hk78N7VtYjk2bVif6SzvPkBm8PzQAvzspump',                    balance: 1000000, decimals: 6 },
        { symbol: '...',  mint: 'BH4Dgd9cBTZDtqHjopomdfZZS4ry26qADcW13MNRpump',                    balance: 500000,  decimals: 6 },
      ];
      // Fetch real names/logos for demo pump.fun tokens
      await fetchTokenMetadata(ghostState.walletTokens, demoMints);
    }
    populateAllPickers();
    return;
  }

  // Real wallet ‚Äî fetch live balances but preserve any in-memory vault adjustments
  try {
    const [solRes, splRes, spl22Res] = await Promise.all([
      fetch(RPC_URL, { method:'POST', headers:{'Content-Type':'application/json'},
        body: JSON.stringify({jsonrpc:'2.0',id:1,method:'getBalance',params:[ghostState.publicKey]}) }),
      fetch(RPC_URL, { method:'POST', headers:{'Content-Type':'application/json'},
        body: JSON.stringify({jsonrpc:'2.0',id:2,method:'getTokenAccountsByOwner',
          params:[ghostState.publicKey,{programId:'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA'},{encoding:'jsonParsed'}]}) }),
      fetch(RPC_URL, { method:'POST', headers:{'Content-Type':'application/json'},
        body: JSON.stringify({jsonrpc:'2.0',id:3,method:'getTokenAccountsByOwner',
          params:[ghostState.publicKey,{programId:'TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb'},{encoding:'jsonParsed'}]}) })
    ]);
    const solData = await solRes.json();
    const splData = await splRes.json();
    const spl22Data = await spl22Res.json();
    // Merge Token-2022 accounts into splData results
    if (spl22Data.result?.value) {
      splData.result = splData.result || { value: [] };
      splData.result.value = [...(splData.result.value || []), ...spl22Data.result.value];
    }
    const solBalance = (solData.result?.value || 0) / 1e9;
    const freshTokens = [{ symbol: 'SOL', mint: 'native', balance: solBalance, decimals: 9 }];
    // Note: if wallet also holds a wSOL ATA, we merge it into the native SOL entry below

    const unknownMints = [];
    for (const acct of (splData.result?.value || [])) {
      const info = acct.account.data.parsed?.info;
      if (!info) continue;
      const balance = parseFloat(info.tokenAmount.uiAmountString || 0);
      if (balance <= 0) continue;
      const mint = info.mint;
      const symbol = knownSymbols[mint] || null;
      if (!symbol) unknownMints.push(mint);
      freshTokens.push({ symbol: symbol || mint.slice(0,4)+'...'+mint.slice(-4), mint, balance, decimals: info.tokenAmount.decimals });
    }

    // Merge any wSOL ATA balance into the native SOL entry (show as single "SOL")
    const wsolEntry = freshTokens.find(t => t.mint === 'So11111111111111111111111111111111111111112');
    if (wsolEntry) {
      const solEntry = freshTokens.find(t => t.mint === 'native');
      if (solEntry) { solEntry.balance += wsolEntry.balance; }
      freshTokens.splice(freshTokens.indexOf(wsolEntry), 1); // remove separate wSOL entry
    }

    // Fetch on-chain metadata for unknown mints (name + image)
    if (unknownMints.length > 0) {
      await fetchTokenMetadata(freshTokens, unknownMints);
    }

    // Always use fresh on-chain balances as source of truth
    // Preserve logos/names fetched this session, but never keep stale balances
    for (const fresh of freshTokens) {
      const existing = ghostState.walletTokens.find(t => t.mint === fresh.mint);
      if (existing) {
        existing.balance = fresh.balance; // always update from chain
        existing.symbol = fresh.symbol || existing.symbol;
        if (fresh.logoUrl) existing.logoUrl = fresh.logoUrl;
      }
    }
    // Add any new tokens not previously seen
    for (const fresh of freshTokens) {
      if (!ghostState.walletTokens.find(t => t.mint === fresh.mint)) {
        ghostState.walletTokens.push(fresh);
      }
    }
    // Remove tokens that no longer exist in wallet (balance went to 0 on-chain)
    ghostState.walletTokens = ghostState.walletTokens.filter(t =>
      freshTokens.find(f => f.mint === t.mint) || t._sessionOnly
    );
    if (ghostState.walletTokens.length === freshTokens.length) {
      setTimeout(fetchPumpFunData, 200);
    }

    // Fetch vault token balances from chain ‚Äî source of truth regardless of session state
    if (ghostState.ghost?.status === 'alive' || ghostState.ghost?.status === 'triggered') {
      try {
        const vaultPdaStr = ghostState.vaultPda;
        if (vaultPdaStr) {
          const [vaultSpl, vaultSpl22] = await Promise.all([
            fetch(RPC_URL, { method:'POST', headers:{'Content-Type':'application/json'},
              body: JSON.stringify({jsonrpc:'2.0',id:'vs1',method:'getTokenAccountsByOwner',
                params:[vaultPdaStr,{programId:'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA'},{encoding:'jsonParsed'}]})
            }).then(r=>r.json()),
            fetch(RPC_URL, { method:'POST', headers:{'Content-Type':'application/json'},
              body: JSON.stringify({jsonrpc:'2.0',id:'vs2',method:'getTokenAccountsByOwner',
                params:[vaultPdaStr,{programId:'TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb'},{encoding:'jsonParsed'}]})
            }).then(r=>r.json())
          ]);
          const vaultAccts = [
            ...(vaultSpl.result?.value || []),
            ...(vaultSpl22.result?.value || [])
          ];
          // Rebuild vaultTokens from on-chain data
          const freshVault = [];
          for (const acct of vaultAccts) {
            const info = acct.account.data.parsed?.info;
            if (!info) continue;
            const balance = parseFloat(info.tokenAmount.uiAmountString || 0);
            if (balance <= 0) continue;
            const mint = info.mint;
            // Find metadata from wallet tokens or existing vault tokens
            const meta = ghostState.walletTokens.find(t => t.mint === mint)
                      || ghostState.vaultTokens.find(t => t.mint === mint)
                      || {};
            freshVault.push({
              symbol: meta.symbol || mint.slice(0,6),
              mint,
              balance,
              decimals: info.tokenAmount.decimals,
              logoUrl: meta.logoUrl || null,
              name: meta.name || null
            });
          }
          if (freshVault.length > 0 || vaultAccts.length >= 0) {
            // Merge: preserve logos/names from existing entries, update balances from chain
            for (const fresh of freshVault) {
              const existing = ghostState.vaultTokens.find(v => v.mint === fresh.mint);
              if (existing) {
                existing.balance = fresh.balance;
                if (fresh.logoUrl) existing.logoUrl = fresh.logoUrl;
              } else {
                ghostState.vaultTokens.push(fresh);
              }
            }
            // Remove vault tokens that no longer have on-chain balance
            ghostState.vaultTokens = ghostState.vaultTokens.filter(v =>
              v.mint === ghostState.ghost?.ghostMint || // keep GHOST stake entry
              freshVault.find(f => f.mint === v.mint)
            );
          }
          console.log('[Ghost] Vault tokens from chain:', ghostState.vaultTokens.map(v => v.symbol + ':' + v.balance));
        }
      } catch(e) { console.warn('[Ghost] Vault fetch error:', e); }
    }

    populateAllPickers();
    fetchPumpFunData(); // get logos/prices for any pump.fun tokens
  } catch(err) {
    console.error('Token load error:', err);
    showNotif('Could not load wallet tokens', 'error');
  }
}

// Fetch token name + image from on-chain Metaplex metadata
async function fetchTokenMetadata(tokens, mints) {
  // Step 1: Try Jupiter token list for established tokens
  try {
    const res = await fetch('https://token.jup.ag/all');
    if (res.ok) {
      const list = await res.json();
      const byMint = {};
      for (const t of list) byMint[t.address] = t;
      for (const token of tokens) {
        if (!mints.includes(token.mint)) continue;
        const meta = byMint[token.mint];
        if (meta) {
          token.symbol = meta.symbol || token.symbol;
          token.name = meta.name;
          if (meta.logoURI) token.logoUrl = meta.logoURI;
        }
      }
    }
  } catch(e) {}

  // Step 2: For any still-unknown tokens (pump.fun etc), use Helius getAsset
  const stillUnknown = tokens.filter(t => mints.includes(t.mint) && t.symbol?.includes('...'));
  await Promise.all(stillUnknown.map(async token => {
    try {
      const res = await fetch(HELIUS_API, {
        method: 'POST', headers: {'Content-Type': 'application/json'},
        body: JSON.stringify({jsonrpc:'2.0', id:'meta', method:'getAsset', params:{id: token.mint}})
      });
      if (!res.ok) return;
      const d = await res.json();
      const asset = d?.result;
      const sym = asset?.content?.metadata?.symbol;
      const name = asset?.content?.metadata?.name;
      const img = asset?.content?.links?.image || asset?.content?.files?.[0]?.cdn_uri;
      const jsonUri = asset?.content?.json_uri;

      if (sym) { token.symbol = sym; token.name = name; }
      if (img) token.logoUrl = normaliseUrl(img);

      // Fetch off-chain JSON if no direct image
      if (!token.logoUrl && jsonUri && (jsonUri.startsWith('http') || jsonUri.startsWith('ipfs'))) {
        try {
          const metaRes = await fetch(normaliseUrl(jsonUri));
          if (metaRes.ok) {
            const meta = await metaRes.json();
            const metaImg = meta.image || meta.image_uri;
            if (metaImg) token.logoUrl = normaliseUrl(metaImg);
            if (!sym && meta.symbol) { token.symbol = meta.symbol; token.name = meta.name; }
          }
        } catch(e) {}
      }
      console.log('[Ghost] Helius metadata:', token.mint.slice(0,8), '‚Üí', token.symbol, token.logoUrl ? '(logo)' : '(no logo)');
    } catch(e) {}
  }));
}

// Rebuild bene + burn pickers from current vault + beneficiary state
function _refreshBenePickers() {
  const assignable = vaultAssignableTokens();
  buildPickerDropdown('bene', [WHOLE_VAULT_TOKEN, ...assignable]);
  buildPickerDropdown('burn', assignable);
  // If current selection is no longer available, reset it
  const curBene = ghostState.selectedTokens.bene;
  if (curBene && curBene.mint !== '__whole_vault__') {
    const stillAvailable = assignable.find(a => a.mint === curBene.mint);
    if (!stillAvailable) {
      ghostState.selectedTokens.bene = null;
      const symEl = document.getElementById('benePickerSymbol');
      const balEl = document.getElementById('benePickerBal');
      const logoEl = document.getElementById('benePickerLogo');
      if (symEl) symEl.textContent = 'Select vault asset';
      if (balEl) balEl.textContent = '';
      if (logoEl) logoEl.innerHTML = '';
    } else {
      // Update displayed remaining balance
      const balEl = document.getElementById('benePickerBal');
      if (balEl) balEl.textContent = stillAvailable.isWholeVault ? 'all tokens ¬∑ % shares' : stillAvailable.balance.toLocaleString(undefined,{maximumFractionDigits:6}) + ' available';
    }
  }
  const curBurn = ghostState.selectedTokens.burn;
  if (curBurn) {
    const stillAvailable = assignable.find(a => a.mint === curBurn.mint);
    if (!stillAvailable) {
      ghostState.selectedTokens.burn = null;
      const symEl = document.getElementById('burnPickerSymbol');
      const balEl = document.getElementById('burnPickerBal');
      const logoEl = document.getElementById('burnPickerLogo');
      if (symEl) symEl.textContent = 'Select vault asset';
      if (balEl) balEl.textContent = '';
      if (logoEl) logoEl.innerHTML = '';
    }
  }
  // Refresh remaining label
  updateBeneRemaining();
}

// Returns vault tokens with remaining unassigned balance (for bene/burn pickers)
function vaultAssignableTokens() {
  // Check if whole-vault plan covers 100% ‚Äî if so, no individual tokens available
  const wholeVaultPct = ghostState.ghost.beneficiaries
    .filter(b => b.action === 'whole-vault-share')
    .reduce((s, b) => s + (b.sharePct || 0), 0);
  if (wholeVaultPct >= 100) return []; // entire vault is already spoken for

  return ghostState.vaultTokens
    .filter(vt => {
      if (vt.balance <= 0) return false;
      // Sum only specific transfer/burn assignments (not whole-vault-share)
      const assigned = ghostState.ghost.beneficiaries
        .filter(b => b.action !== 'whole-vault-share' && (b.token === vt.symbol || b.token === vt.mint))
        .reduce((s, b) => s + (b.amount || 0), 0);
      return assigned < vt.balance; // still has unassigned balance
    })
    .map(vt => {
      const assigned = ghostState.ghost.beneficiaries
        .filter(b => b.action !== 'whole-vault-share' && (b.token === vt.symbol || b.token === vt.mint))
        .reduce((s, b) => s + (b.amount || 0), 0);
      return { ...vt, balance: +(vt.balance - assigned).toFixed(9) };
    });
}

// "Whole vault" pseudo-token for the bene picker
const WHOLE_VAULT_TOKEN = { symbol: 'Whole Vault', mint: '__whole_vault__', balance: 0, logoUrl: null, isWholeVault: true, chestIcon: true };

function populateAllPickers() {
  const t = ghostState.walletTokens;
  // Deposit picker: wallet tokens with balance > 0
  const depositTokens = t.filter(tok => tok.balance > 0);
  buildPickerDropdown('deposit', depositTokens);
  // Bene picker: assignable vault tokens + whole vault option at bottom
  const assignable = vaultAssignableTokens();
  const beneTokens = [WHOLE_VAULT_TOKEN, ...assignable];
  buildPickerDropdown('bene', beneTokens);
  // Burn picker: only real vault tokens with remaining balance
  buildPickerDropdown('burn', assignable);
  // Auto-select first token
  if (depositTokens.length > 0 && !ghostState.selectedTokens.deposit) selectToken('deposit', depositTokens[0].mint);
  // Bene picker: show "Select asset" placeholder by default, don't auto-select
  if (!ghostState.selectedTokens.bene) {
    // Show placeholder
    const symEl = document.getElementById('benePickerSymbol');
    const balEl = document.getElementById('benePickerBal');
    if (symEl) { symEl.textContent = 'Select asset'; symEl.style.color = 'var(--muted)'; }
    if (balEl) balEl.textContent = '';
  }
  if (assignable.length > 0 && !ghostState.selectedTokens.burn) selectToken('burn', assignable[0].mint);
  buildPickerDropdown('vault', ghostState.vaultTokens);
}

// ‚îÄ‚îÄ‚îÄ Vault Overview (on Overview page) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function renderVaultOverview() {
  const el = document.getElementById('dbVaultOverview');
  if (!el) return;
  const tokens = ghostState.vaultTokens;
  if (tokens.length === 0) {
    el.innerHTML = '<div style="padding:16px 20px;font-family:\'Share Tech Mono\',monospace;font-size:12px;color:#c0bce0">No assets in vault</div>';
    const usdEl = document.getElementById('dbVaultUsdTotal');
    const subEl = document.getElementById('dbVaultUsdSub');
    if (usdEl) usdEl.textContent = '';
    if (subEl) subEl.style.display = 'none';
    return;
  }

  // Simple USD pricing: SOL ~$86, GHOST uses live price, others approximate
  let totalUsd = 0;
  const rows = tokens.map(t => {
    const price = getTokenPrice(t);
    const usdVal = t.balance * price;
    totalUsd += usdVal;
    const usdStr = usdVal > 0 ? ' ¬∑ ~$' + usdVal.toFixed(2) : '';
    return `<div data-ov-mint="${t.mint}" style="display:flex;align-items:center;gap:14px;padding:12px 20px;border-bottom:1px solid rgba(102,51,255,0.06)">
      <div data-ov-logo="${t.mint}" style="width:36px;height:36px;flex-shrink:0;overflow:hidden">${tokenLogoEl(t.symbol, 36, t.logoUrl||null)}</div>
      <div style="flex:1">
        <div style="font-family:'Syne',sans-serif;font-weight:700;font-size:15px;color:#f0f0f8">${t.symbol}</div>
        <div data-ov-bal="${t.mint}" style="font-family:'Share Tech Mono',monospace;font-size:12px;color:#c0bce0">${t.balance.toLocaleString(undefined,{maximumFractionDigits:6})} ${t.symbol}${usdStr}</div>
      </div>
    </div>`;
  }).join('');

  // Diff: only rebuild if token count changed, else patch in-place
  const existingOvRows = el.querySelectorAll('[data-ov-mint]');
  if (existingOvRows.length !== tokens.length) {
    el.innerHTML = rows;
  } else {
    tokens.forEach((t) => {
      const price = getTokenPrice(t);
      const usdVal = t.balance * price;
      const usdStr = usdVal > 0 ? ' ¬∑ ~$' + usdVal.toFixed(2) : '';
      const balEl = el.querySelector(`[data-ov-bal="${t.mint}"]`);
      if (balEl) balEl.textContent = `${t.balance.toLocaleString(undefined,{maximumFractionDigits:6})} ${t.symbol}${usdStr}`;
      // Only update logo if not already loaded
      const logoEl = el.querySelector(`[data-ov-logo="${t.mint}"]`);
      if (logoEl && t.logoUrl) {
        const img = logoEl.querySelector('img');
        if (!img || img.naturalWidth === 0) logoEl.innerHTML = tokenLogoEl(t.symbol, 36, t.logoUrl);
      }
    });
  }
  const usdEl = document.getElementById('dbVaultUsdTotal');
  const subEl = document.getElementById('dbVaultUsdSub');
  if (usdEl) {
    if (totalUsd > 0) {
      usdEl.textContent = '$' + totalUsd.toLocaleString(undefined, {minimumFractionDigits:2, maximumFractionDigits:2});
      if (subEl) subEl.style.display = 'block';
    } else {
      usdEl.textContent = '';
      if (subEl) subEl.style.display = 'none';
    }
  }
}

// ‚îÄ‚îÄ‚îÄ Ping History ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
ghostState.pingHistory = []; // [{num, ts, tx, gap}]

function addPingToHistory(tx) {
  const now = Date.now();
  const last = ghostState.pingHistory[0]?.ts;
  const gap = last ? formatDuration(now - last) : '‚Äî';
  const num = ghostState.ghost.pingCount;
  ghostState.pingHistory.unshift({ num, ts: now, tx, gap });
  renderPingHistory();
}

function renderPingHistory() {
  const tbody = document.getElementById('dbPingHistory');
  if (!tbody) return;
  if (ghostState.pingHistory.length === 0) {
    tbody.innerHTML = '<tr><td colspan="4" style="text-align:center;color:#c0bce0;padding:20px">No pings recorded yet this session</td></tr>';
    return;
  }
  tbody.innerHTML = ghostState.pingHistory.map(p => {
    const d = new Date(p.ts);
    const dateStr = d.toLocaleDateString('en-GB', { day:'numeric', month:'short', year:'numeric' }) + ' ' + d.toLocaleTimeString('en-GB', { hour:'2-digit', minute:'2-digit' });
    return `<tr>
      <td style="color:#c0bce0">${p.num}</td>
      <td>${dateStr}</td>
      <td><span class="addr-short">${p.tx}</span></td>
      <td style="color:#c0bce0">${p.gap}</td>
    </tr>`;
  }).join('');
}

// ‚îÄ‚îÄ‚îÄ Recovery Wallets (up to 3) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
ghostState.recoveryWallets = []; // [{address, canWithdraw}]

function renderRecoveryWallets() {
  const el = document.getElementById('recoveryWalletsList');
  if (!el) return;

  const form = document.getElementById('addRecoveryForm');
  if (form) form.style.display = ghostState.recoveryWallets.length >= 3 ? 'none' : 'block';

  if (ghostState.recoveryWallets.length === 0) {
    el.innerHTML = '<div class="db-info" style="margin-bottom:0">No recovery wallets configured.</div>';
    // Update overview card
    const statusEl = document.getElementById('dbRecoveryStatus');
    const shortEl = document.getElementById('dbRecoveryShort');
    if (statusEl) statusEl.textContent = 'NONE';
    if (shortEl) shortEl.textContent = 'not configured';
    return;
  }

  el.innerHTML = ghostState.recoveryWallets.map((w, i) => `
    <div class="db-form" style="margin-bottom:12px;padding:16px 20px">
      <div style="display:flex;align-items:center;justify-content:space-between;gap:12px;flex-wrap:wrap">
        <div style="flex:1">
          <div style="font-family:'Share Tech Mono',monospace;font-size:11px;color:#c0bce0;letter-spacing:0.15em;text-transform:uppercase;margin-bottom:4px">Recovery Wallet ${i+1}</div>
          <div style="font-family:'Share Tech Mono',monospace;font-size:13px;color:var(--text);word-break:break-all;display:flex;align-items:center;gap:8px">
            ${w.address}
            <button onclick="copyAddr('${w.address}')" style="background:none;border:1px solid rgba(102,51,255,0.2);color:#c0bce0;font-family:Share Tech Mono,monospace;font-size:10px;padding:2px 7px;cursor:pointer" title="Copy">‚ßâ</button>
          </div>
          <div style="margin-top:8px;display:flex;gap:16px">
            <label style="display:flex;align-items:center;gap:6px;cursor:default;font-family:'Share Tech Mono',monospace;font-size:12px;color:var(--green)">
              <input type="checkbox" checked disabled style="accent-color:#33ff99"> Cancel awakening
            </label>
            <label style="display:flex;align-items:center;gap:6px;cursor:pointer;font-family:'Share Tech Mono',monospace;font-size:12px;color:${w.canWithdraw ? 'var(--amber)' : 'var(--muted)'}">
              <input type="checkbox" ${w.canWithdraw ? 'checked' : ''} onchange="toggleRecoveryWithdraw(${i}, this.checked)" style="accent-color:#ffb830;cursor:pointer"> Vault withdrawals
            </label>
          </div>
        </div>
        <button class="db-btn db-btn-danger" style="padding:7px 14px;font-size:11px;flex-shrink:0" onclick="dbRemoveRecoveryWallet(${i})">üóëÔ∏è Remove</button>
      </div>
    </div>`).join('');

  // Update overview card
  const statusEl = document.getElementById('dbRecoveryStatus');
  const shortEl = document.getElementById('dbRecoveryShort');
  if (statusEl) statusEl.textContent = ghostState.recoveryWallets.length + ' SET';
  if (shortEl) {
    const a = ghostState.recoveryWallets[0].address;
    shortEl.textContent = a.slice(0,4)+'...'+a.slice(-4) + (ghostState.recoveryWallets.length > 1 ? ' +' + (ghostState.recoveryWallets.length-1) + ' more' : '');
  }
}

async function dbAddRecoveryWallet() {
  const addr = document.getElementById('dbNewRecovery').value.trim();
  if (!addr || addr.length < 32) { showNotif('‚ö†Ô∏è Enter a valid Solana address', 'error'); return; }
  if (ghostState.recoveryWallets.find(w => w.address === addr)) { showNotif('‚ö†Ô∏è Address already added', 'error'); return; }
  const canWithdraw = document.getElementById('permWithdraw').checked;

  // Demo mode
  if (!ghostState.provider || ghostState.walletName?.includes('demo')) {
    ghostState.recoveryWallets = [{ address: addr, canWithdraw }];
    ghostState.ghost.recoveryWallet = addr;
    document.getElementById('dbNewRecovery').value = '';
    renderRecoveryWallets();
    showNotif('‚úÖ Recovery wallet set [demo]', 'green');
    return;
  }

  // On-chain: update_recovery_wallet
  try {
    showNotif('Setting recovery wallet on-chain...', '');
    const { PublicKey, Transaction, TransactionInstruction } = solanaWeb3;
    const walletPk = new PublicKey(ghostState.publicKey);
    const ghostPda = new PublicKey(ghostState.ghostPda);
    const programId = new PublicKey(PROGRAM_ID);

    // Discriminator: sha256("global:update_recovery_wallet")[0:8]
    const disc = [17, 163, 88, 154, 97, 78, 169, 93]; // sha256('global:update_recovery_wallet')[0:8]
    // Args: recovery_wallet: Option<Pubkey>
    const recoveryBytes = new Uint8Array(33);
    recoveryBytes[0] = 1;
    recoveryBytes.set(new PublicKey(addr).toBytes(), 1);
    const data = new Uint8Array(8 + 33);
    data.set(disc, 0);
    data.set(recoveryBytes, 8);

    const ix = new TransactionInstruction({
      programId,
      keys: [
        { pubkey: ghostPda, isSigner: false, isWritable: true },
        { pubkey: walletPk, isSigner: true, isWritable: false },
      ],
      data
    });

    const connection = new solanaWeb3.Connection(RPC_URL, 'confirmed');
    const { blockhash } = await connection.getLatestBlockhash();
    const tx = new Transaction({ recentBlockhash: blockhash, feePayer: walletPk });
    tx.add(ix);
    // Debug: log each instruction individually so console doesn't collapse
    tx.instructions.forEach((ix, i) => 
      console.log(`[Ghost] ix${i}: prog=${ix.programId.toBase58()} accounts=${ix.keys.length} data=${ix.data.length}b`)
    );
    const signed = await ghostState.provider.signTransaction(tx);
    const sig = await connection.sendRawTransaction(signed.serialize(), { skipPreflight: true });
    await connection.confirmTransaction(sig, 'confirmed');

    ghostState.recoveryWallets = [{ address: addr, canWithdraw }];
    ghostState.ghost.recoveryWallet = addr;
    document.getElementById('dbNewRecovery').value = '';
    renderRecoveryWallets();
    showNotif('‚úÖ Recovery wallet set on-chain!', 'green');
  } catch(err) {
    showNotif('Failed: ' + (err.message || err), 'error');
  }
}

async function dbRemoveRecoveryWallet(idx) {
  if (!confirm('Remove this recovery wallet on-chain?')) return;

  if (!ghostState.provider || ghostState.walletName?.includes('demo')) {
    ghostState.recoveryWallets.splice(idx, 1);
    if (!ghostState.recoveryWallets.length) ghostState.ghost.recoveryWallet = null;
    renderRecoveryWallets();
    return;
  }

  try {
    showNotif('Removing recovery wallet on-chain...', '');
    const { PublicKey, Transaction, TransactionInstruction } = solanaWeb3;
    const walletPk = new PublicKey(ghostState.publicKey);
    const ghostPda = new PublicKey(ghostState.ghostPda);
    const programId = new PublicKey(PROGRAM_ID);

    const disc = [17, 163, 88, 154, 97, 78, 169, 93]; // sha256('global:update_recovery_wallet')[0:8]
    // Option::None = [0x00]
    const data = new Uint8Array(9);
    data.set(disc, 0);
    data[8] = 0; // None

    const ix = new TransactionInstruction({
      programId,
      keys: [
        { pubkey: ghostPda, isSigner: false, isWritable: true },
        { pubkey: walletPk, isSigner: true, isWritable: false },
      ],
      data
    });

    const connection = new solanaWeb3.Connection(RPC_URL, 'confirmed');
    const { blockhash } = await connection.getLatestBlockhash();
    const tx = new Transaction({ recentBlockhash: blockhash, feePayer: walletPk });
    tx.add(ix);
    // Debug: log each instruction individually so console doesn't collapse
    tx.instructions.forEach((ix, i) => 
      console.log(`[Ghost] ix${i}: prog=${ix.programId.toBase58()} accounts=${ix.keys.length} data=${ix.data.length}b`)
    );
    const signed = await ghostState.provider.signTransaction(tx);
    const sig = await connection.sendRawTransaction(signed.serialize(), { skipPreflight: true });
    await connection.confirmTransaction(sig, 'confirmed');

    ghostState.recoveryWallets.splice(idx, 1);
    if (!ghostState.recoveryWallets.length) ghostState.ghost.recoveryWallet = null;
    renderRecoveryWallets();
    showNotif('Recovery wallet removed on-chain', 'green');
  } catch(err) {
    showNotif('Failed: ' + (err.message || err), 'error');
  }
}

function toggleRecoveryWithdraw(idx, val) {
  ghostState.recoveryWallets[idx].canWithdraw = val;
  showNotif(val ? '‚ö†Ô∏è Withdrawal rights granted' : 'Withdrawal rights revoked', val ? 'info' : 'info');
}

// Legacy stubs for old calls
function dbUpdateRecovery() { dbAddRecoveryWallet(); }
function dbRemoveRecovery() { if (ghostState.recoveryWallets.length) dbRemoveRecoveryWallet(0); }

// ‚îÄ‚îÄ‚îÄ Copyable addresses ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function copyAddr(addr) {
  navigator.clipboard?.writeText(addr).then(() => showNotif('‚úÖ Address copied', 'green')).catch(() => showNotif('Copy failed', 'error'));
}
// Helper: how much of a vault token is assigned to specific beneficiaries
function vaultAssignedAmount(symbol, mint) {
  return ghostState.ghost.beneficiaries
    .filter(b => b.action !== 'whole-vault-share' && (b.token === symbol || b.token === mint))
    .reduce((s, b) => s + (b.amount || 0), 0);
}

function renderVaultHoldings() {
  const el = document.getElementById('vaultHoldingsList');
  if (!el) return;
  if (ghostState.vaultTokens.length === 0) {
    el.innerHTML = '<div style="padding:24px;text-align:center;font-family:\'Share Tech Mono\',monospace;font-size:12px;color:#c0bce0">No assets in vault yet.</div>';
    const tot = document.getElementById('vaultHoldingsUsdTotal');
    if (tot) { tot.textContent = ''; tot.style.textShadow = ''; }
    const sub = document.getElementById('vaultHoldingsUsdSub');
    if (sub) sub.style.display = 'none';
    return;
  }

  const wholeVaultPct = ghostState.ghost.beneficiaries
    .filter(b => b.action === 'whole-vault-share')
    .reduce((s, b) => s + (b.sharePct || 0), 0);

  let totalUsd = 0;
  const rows = ghostState.vaultTokens.map((t, i) => {
    // Normalise wSOL ‚Üí display as SOL everywhere in vault
    if (t.mint === WSOL_MINT_PK_STR || t.mint === 'So11111111111111111111111111111111111111112') t.symbol = 'SOL';
    const price = getTokenPrice(t);
    const usdVal = price > 0 ? t.balance * price : null;
    if (usdVal !== null) totalUsd += usdVal;
    const usdStr = usdVal !== null ? ` <span style="color:rgba(144,144,168,0.6)">\u2248 $${usdVal.toFixed(2)}</span>` : '';

    const assigned = wholeVaultPct >= 100 ? t.balance : vaultAssignedAmount(t.symbol, t.mint);
    const free = Math.max(0, +(t.balance - assigned).toFixed(9));
    const isFullyAssigned = assigned >= t.balance - 0.000000001;
    const isPartiallyAssigned = assigned > 0.000000001 && !isFullyAssigned;

    const badge = isFullyAssigned
      ? `<span style="font-family:'Share Tech Mono',monospace;font-size:9px;letter-spacing:0.12em;color:#a080ff;background:rgba(160,128,255,0.1);border:1px solid rgba(160,128,255,0.25);padding:2px 7px;margin-left:8px">ASSIGNED</span>`
      : isPartiallyAssigned
      ? `<span style="font-family:'Share Tech Mono',monospace;font-size:9px;letter-spacing:0.12em;color:#ff9933;background:rgba(255,153,51,0.08);border:1px solid rgba(255,153,51,0.25);padding:2px 7px;margin-left:8px">PARTIAL</span>`
      : '';

    const freeNote = isPartiallyAssigned
      ? `<span style="color:#ff9933;font-size:11px"> ¬∑ ${free.toLocaleString(undefined,{maximumFractionDigits:6})} free / ${assigned.toLocaleString(undefined,{maximumFractionDigits:6})} assigned</span>`
      : isFullyAssigned
      ? `<span style="color:#a080ff;font-size:11px"> ¬∑ fully assigned to beneficiar${ghostState.ghost.beneficiaries.filter(b=>b.token===t.symbol&&b.action!=='whole-vault-share').length===1?'y':'ies'}</span>`
      : '';

    const canWd = !isFullyAssigned && free > 0;
    const wdMax = canWd ? free : 0;

    return `
    <div class="vault-asset-row" data-mint="${t.mint}" style="${isFullyAssigned ? 'opacity:0.78;background:rgba(160,128,255,0.025)' : ''}">
      <div class="vault-asset-icon" style="background:none;overflow:hidden" data-logo="${t.mint}">${tokenLogoEl(t.symbol, 36, t.logoUrl||null)}</div>
      <div class="vault-asset-info">
        <div class="vault-asset-symbol" style="display:flex;align-items:center">${t.symbol}${badge}</div>
        <div class="vault-asset-bal" data-bal="${t.mint}">${t.balance.toLocaleString(undefined,{maximumFractionDigits:6})} ${t.symbol} in vault${usdStr}${freeNote}</div>
      </div>
      <div class="vault-asset-actions">
        ${canWd
          ? `<input class="vault-asset-input" type="text" inputmode="decimal" id="wdAmt${i}" placeholder="Amount" oninput="formatWithdrawInput(this,${wdMax})">
             <button class="db-btn db-btn-outline" style="padding:7px 14px;font-size:11px" onclick="dbWithdrawAsset(${i})">Withdraw</button>
             <button class="db-btn db-btn-outline" style="padding:7px 8px;font-size:11px" onclick="fillMaxWithdraw('wdAmt${i}',${wdMax})">MAX</button>`
          : `<input class="vault-asset-input" type="text" inputmode="decimal" id="wdAmt${i}" placeholder="‚Äî" disabled style="opacity:0.3">
             <button class="db-btn db-btn-outline" style="padding:7px 14px;font-size:11px;opacity:0.3;cursor:not-allowed" disabled title="${isFullyAssigned ? 'Fully assigned to beneficiaries ‚Äî remove the beneficiary first to withdraw' : 'No free balance'}">Withdraw</button>
             <button class="db-btn db-btn-outline" style="padding:7px 8px;font-size:11px;opacity:0.3;cursor:not-allowed" disabled>MAX</button>`
        }
      </div>
    </div>`;
  }).join('');

  el.innerHTML = rows;

  // Restore logos without re-fetching
  ghostState.vaultTokens.forEach((t) => {
    if (!t.logoUrl) return;
    const logoEl = el.querySelector(`[data-logo="${t.mint}"]`);
    if (logoEl) {
      const img = logoEl.querySelector('img');
      if (!img || !img.src.startsWith('http')) logoEl.innerHTML = tokenLogoEl(t.symbol, 36, t.logoUrl);
    }
  });

  const tot = document.getElementById('vaultHoldingsUsdTotal');
  const sub = document.getElementById('vaultHoldingsUsdSub');
  if (tot) {
    if (totalUsd > 0) {
      const whole = Math.floor(totalUsd).toLocaleString();
      const cents = (totalUsd % 1).toFixed(2).slice(1);
      tot.innerHTML = `<span style="font-size:0.55em;vertical-align:super;margin-right:2px;opacity:0.7">$</span>${whole}<span style="font-size:0.45em;vertical-align:super;opacity:0.6">${cents}</span>`;
      tot.style.textShadow = '0 0 40px rgba(51,255,153,0.35)';
      if (sub) sub.style.display = 'block';
    } else {
      tot.innerHTML = ''; tot.style.textShadow = '';
      if (sub) sub.style.display = 'none';
    }
  }
  fetchPumpFunData();
  // Keep WITHDRAW ALL button and deposit notice in sync with beneficiary state
  const wdAllBtn = document.querySelector('button[onclick="dbWithdrawAll()"]');
  const wvBene = ghostState.ghost.beneficiaries.find(b => b.action === 'whole-vault-share');
  if (wdAllBtn) {
    wdAllBtn.disabled = !!wvBene;
    wdAllBtn.style.opacity = wvBene ? '0.3' : '1';
    wdAllBtn.style.cursor = wvBene ? 'not-allowed' : 'pointer';
    wdAllBtn.title = wvBene ? 'Vault is assigned to a beneficiary ‚Äî remove assignment first' : 'Withdraw all vault assets';
  }
  const depNotice = document.getElementById('depositWholeVaultNotice');
  const depRecip = document.getElementById('depositWholeVaultRecip');
  if (depNotice) depNotice.style.display = wvBene ? 'block' : 'none';
  if (depRecip && wvBene) depRecip.textContent = wvBene.recipient;
}

// ‚îÄ‚îÄ‚îÄ Bulk deposit / withdraw ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function dbDepositAll() {
  if (ghostState.provider && !ghostState.walletName?.includes('demo')) {
    showNotif('Use individual deposits for each asset ‚Äî Deposit All coming soon', 'error');
    return;
  }
  const tokens = ghostState.walletTokens.filter(tok => tok.balance > 0);
  if (tokens.length === 0) { showNotif('No assets with balance in wallet', 'error'); return; }
  let count = 0;
  for (const t of tokens) {
    const amount = t.balance;
    if (!amount || amount <= 0) continue;
    const symbol = t.symbol;
    const mint = t.mint;
    t.balance = 0;
    const existing = ghostState.vaultTokens.find(v => v.mint === mint);
    if (existing) {
      existing.balance += amount;
      if (!existing.logoUrl && t.logoUrl) existing.logoUrl = t.logoUrl;
    } else {
      ghostState.vaultTokens.push({ symbol, mint, balance: amount, decimals: t.decimals, logoUrl: t.logoUrl || null, name: t.name || null });
    }
    addActivityRow('üì• Deposited ' + amount.toLocaleString() + ' ' + symbol, randomTx());
    count++;
  }
  if (count === 0) { showNotif('Nothing to deposit', 'error'); return; }

  // Rebuild deposit picker ‚Äî all tokens now 0
  buildPickerDropdown('deposit', []);
  const symEl = document.getElementById('depositPickerSymbol');
  const balEl = document.getElementById('depositPickerBal');
  const logoEl = document.getElementById('depositPickerLogo');
  if (symEl) symEl.textContent = 'Select asset';
  if (balEl) balEl.textContent = '';
  if (logoEl) logoEl.innerHTML = '';
  document.getElementById('depositBalance').value = '‚Äî';
  document.getElementById('depositAmt').value = '';
  document.getElementById('depositAmtDisplay').value = '';
  ghostState.selectedTokens.deposit = null;

  renderVaultHoldings();
  renderVaultOverview();
  showNotif('üì• Deposited all ' + count + ' asset' + (count > 1 ? 's' : '') + ' to vault!', 'green');
  saveSession();
  // fetchPumpFunData gets logos for newly deposited tokens ‚Äî no extra render needed
  setTimeout(fetchPumpFunData, 300);
}

async function dbWithdrawAll() {
  if (ghostState.ghost.status === 'awakened') { showNotif('‚ö†Ô∏è Withdrawals blocked while awakened', 'error'); return; }
  const wholeVaultActive = ghostState.ghost.beneficiaries.some(b => b.action === 'whole-vault-share');
  if (wholeVaultActive) {
    const rec = ghostState.ghost.beneficiaries.find(b => b.action === 'whole-vault-share')?.recipient || '';
    showNotif('‚ö†Ô∏è Vault is assigned to ' + rec + ' ‚Äî remove beneficiary first', 'error'); return;
  }
  const tokens = [...ghostState.vaultTokens];
  if (tokens.length === 0) { showNotif('Vault is empty', 'error'); return; }

  // ‚îÄ‚îÄ Demo mode ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  if (!ghostState.provider || ghostState.walletName?.includes('demo')) {
    let count = 0;
    for (const vt of tokens) {
      const wt = ghostState.walletTokens.find(w => w.mint === vt.mint);
      if (wt) { wt.balance += vt.balance; } else {
        ghostState.walletTokens.push({ symbol: vt.symbol, mint: vt.mint, balance: vt.balance, decimals: vt.decimals, logoUrl: vt.logoUrl || null });
      }
      addActivityRow('üì§ Withdrew ' + vt.balance.toLocaleString() + ' ' + vt.symbol + ' [demo]', randomTx());
      count++;
    }
    ghostState.vaultTokens = [];
    const depositPool = ghostState.walletTokens.filter(tok => tok.balance > 0);
    buildPickerDropdown('deposit', depositPool);
    buildPickerDropdown('bene', [WHOLE_VAULT_TOKEN, ...vaultAssignableTokens()]);
    buildPickerDropdown('burn', vaultAssignableTokens());
    ghostState.selectedTokens.deposit = null;
    if (depositPool.length > 0) selectToken('deposit', depositPool[0].mint);
    renderVaultHoldings(); renderVaultOverview();
    showNotif('üì§ Withdrew all ' + count + ' asset' + (count > 1 ? 's' : '') + ' from vault! [demo]', 'green');
    saveSession();
    return;
  }

  // ‚îÄ‚îÄ On-chain: one withdraw_from_vault tx per token ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  const { PublicKey, Transaction, TransactionInstruction } = solanaWeb3;
  const walletPk  = new PublicKey(ghostState.publicKey);
  const ghostPda  = new PublicKey(ghostState.ghostPda);
  const vaultPda  = new PublicKey(ghostState.vaultPda);
  const programId = new PublicKey(PROGRAM_ID);
  const TOKEN_PROG = new PublicKey(TOKEN_PROGRAM_STR);
  const disc = [180, 34, 37, 46, 156, 0, 211, 238]; // withdraw_from_vault discriminator
  const connection = new solanaWeb3.Connection(RPC_URL, 'confirmed');

  let successCount = 0;
  showNotif('Withdrawing ' + tokens.length + ' asset' + (tokens.length > 1 ? 's' : '') + ' from vault...', '');

  for (const vt of tokens) {
    try {
      const isSOL = (vt.mint === WSOL_MINT_PK_STR || vt.mint === 'native');
      const mintStr = effectiveMint(vt.mint);
      const WSOL_MINT_PK = new PublicKey(WSOL_MINT_PK_STR);
      const mintPk = isSOL ? WSOL_MINT_PK : new PublicKey(mintStr);
      const displaySym = isSOL ? 'SOL' : vt.symbol;
      const amount = vt.balance;

      const ownerAta = await findATA(walletPk, mintPk);
      const vaultAta = await findATA(vaultPda, mintPk);

      const amountRaw = BigInt(Math.round(amount * Math.pow(10, vt.decimals)));
      const buf = new ArrayBuffer(8);
      new DataView(buf).setBigUint64(0, amountRaw, true);
      const data = new Uint8Array(16);
      data.set(disc, 0); data.set(new Uint8Array(buf), 8);

      const { blockhash } = await connection.getLatestBlockhash();
      const tx = new Transaction({ recentBlockhash: blockhash, feePayer: walletPk });
      tx.add(new TransactionInstruction({ programId,
        keys: [
          { pubkey: ghostPda,   isSigner: false, isWritable: false },
          { pubkey: vaultPda,   isSigner: false, isWritable: false },
          { pubkey: walletPk,   isSigner: true,  isWritable: true  },
          { pubkey: mintPk,     isSigner: false, isWritable: false },
          { pubkey: ownerAta,   isSigner: false, isWritable: true  },
          { pubkey: vaultAta,   isSigner: false, isWritable: true  },
          { pubkey: TOKEN_PROG, isSigner: false, isWritable: false },
        ], data }));
      if (isSOL) tx.add(buildUnwrapIx(walletPk, ownerAta));

      const signed = await ghostState.provider.signTransaction(tx);
      const sig    = await connection.sendRawTransaction(signed.serialize());
      await connection.confirmTransaction(sig, 'confirmed');

      // Apply to local state only after confirmed on-chain
      const walletMint = isSOL ? 'native' : vt.mint;
      const wt = ghostState.walletTokens.find(w => w.mint === walletMint);
      if (wt) { wt.balance += amount; } else {
        ghostState.walletTokens.push({ symbol: displaySym, mint: walletMint, balance: amount, decimals: vt.decimals, logoUrl: vt.logoUrl || null });
      }
      const idx = ghostState.vaultTokens.indexOf(vt);
      if (idx !== -1) ghostState.vaultTokens.splice(idx, 1);
      addActivityRow('üì§ Withdrew ' + amount.toLocaleString() + ' ' + displaySym, sig.slice(0,4)+'...'+sig.slice(-4));
      successCount++;
    } catch(err) {
      console.error('Withdraw all error for ' + vt.symbol + ':', err);
      showNotif('‚ö†Ô∏è Failed to withdraw ' + vt.symbol + ': ' + (err.message || err), 'error');
    }
  }

  if (successCount > 0) {
    const depositPool = ghostState.walletTokens.filter(tok => tok.balance > 0);
    buildPickerDropdown('deposit', depositPool);
    buildPickerDropdown('bene', [WHOLE_VAULT_TOKEN, ...vaultAssignableTokens()]);
    buildPickerDropdown('burn', vaultAssignableTokens());
    ghostState.selectedTokens.deposit = null;
    if (depositPool.length > 0) selectToken('deposit', depositPool[0].mint);
    renderVaultHoldings(); renderVaultOverview();
    showNotif('‚úÖ Withdrew ' + successCount + '/' + tokens.length + ' asset' + (successCount > 1 ? 's' : '') + ' from vault!', 'green');
    saveSession();
  }
}

// ‚îÄ‚îÄ‚îÄ Comma-formatted amount helpers ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function formatDepositInput(el) {
  let raw = el.value.replace(/[^0-9.]/g, '');
  const parts = raw.split('.');
  if (parts.length > 2) raw = parts[0] + '.' + parts.slice(1).join('');
  const [whole, dec] = raw.split('.');
  const intPart = parseInt(whole || '0', 10) || 0;
  const formatted = intPart.toLocaleString() + (dec !== undefined ? '.' + dec : '');
  el.value = raw ? formatted : '';
  document.getElementById('depositAmt').value = raw || '';
}

function formatWithdrawInput(el, maxVal) {
  let raw = el.value.replace(/[^0-9.]/g, '');
  const parts = raw.split('.');
  if (parts.length > 2) raw = parts[0] + '.' + parts.slice(1).join('');
  const [whole, dec] = raw.split('.');
  const intPart = parseInt(whole || '0', 10) || 0;
  el.value = raw ? intPart.toLocaleString() + (dec !== undefined ? '.' + dec : '') : '';
  el.dataset.raw = raw || '';
}

function fillMaxWithdraw(id, maxVal) {
  const el = document.getElementById(id);
  if (!el) return;
  el.dataset.raw = maxVal.toString();
  el.value = parseFloat(maxVal).toLocaleString(undefined, {maximumFractionDigits: 9});
}

function fillMaxDeposit() {
  const sel = ghostState.selectedTokens.deposit;
  if (!sel) return;
  // Always read balance from the live walletTokens array (not the stale selection copy)
  const live = ghostState.walletTokens.find(w => w.mint === sel.mint) || sel;
  const bal = live.balance || 0;
  document.getElementById('depositAmt').value = bal.toString();
  document.getElementById('depositAmtDisplay').value = bal.toLocaleString(undefined, {maximumFractionDigits: 9});
}

// ‚îÄ‚îÄ‚îÄ Vault Actions ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// ‚îÄ‚îÄ‚îÄ SOL/wSOL constants ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const WSOL_MINT_PK_STR = 'So11111111111111111111111111111111111111112';
const TOKEN_PROGRAM_STR    = 'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA';
const TOKEN_2022_STR       = 'TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb'; // real Token-2022

// No normalization needed ‚Äî TokenzQdBNbLqP5... IS the real Token-2022 program
function normalizeTokenProg(addr) { return addr; }
const ASSOC_TOKEN_PROG_STR = 'ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJe1bso';

// Resolve effective mint: native SOL ‚Üí wSOL mint string
function effectiveMint(mint) {
  return (mint === 'native' || mint === 'sol') ? WSOL_MINT_PK_STR : mint;
}

// Derive ATA ‚Äî synchronous using pre-fetched PDA
async function findATAWithProg(owner, mint, tokenProg) {
  const { PublicKey } = solanaWeb3;
  const ASSOC = new PublicKey('ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJe1bso');
  const [ata] = await PublicKey.findProgramAddress(
    [owner.toBytes(), tokenProg.toBytes(), mint.toBytes()], ASSOC
  );
  return ata;
}

async function findATA(ownerPk, mintPk) {
  const { PublicKey } = solanaWeb3;
  const TOKEN_PROG = new PublicKey(TOKEN_PROGRAM_STR);
  const ASSOC_PROG = new PublicKey(ASSOC_TOKEN_PROG_STR);
  const [ata] = await PublicKey.findProgramAddress(
    [ownerPk.toBytes(), TOKEN_PROG.toBytes(), mintPk.toBytes()],
    ASSOC_PROG
  );
  return ata;
}

// Build create-ATA instruction (with rent sysvar for compatibility)
// Manual token account creation ‚Äî bypasses ATA program entirely
// Generates a new keypair, creates + initializes the account, returns keypair
// Caller must call tx.partialSign(kp) before provider.signTransaction(tx)
async function buildManualTokenAccountIxs(walletPk, mintPk, ownerPk, tokenProgPk, connection) {
  const { Keypair, SystemProgram, TransactionInstruction } = solanaWeb3;
  const kp = Keypair.generate();
  // Token account space: 165 bytes (Token), 165 bytes (Token-2022 base without extensions)
  const space = 165;
  const lamports = await connection.getMinimumBalanceForRentExemption(space);

  const createIx = SystemProgram.createAccount({
    fromPubkey: walletPk,
    newAccountPubkey: kp.publicKey,
    lamports,
    space,
    programId: tokenProgPk, // token program owns the account
  });

  // InitializeAccount3: opcode 18, layout = [18u8, owner_pubkey(32)]
  const initData = new Uint8Array(33);
  initData[0] = 18;
  initData.set(ownerPk.toBytes(), 1);

  const initIx = new TransactionInstruction({
    programId: tokenProgPk,
    keys: [
      { pubkey: kp.publicKey, isSigner: false, isWritable: true },
      { pubkey: mintPk,       isSigner: false, isWritable: false },
    ],
    data: initData,
  });

  return { createIx, initIx, kp };
}

function buildCreateATAIx(payerPk, ataPk, ownerPk, mintPk, tokenProgId) {
  const { PublicKey, TransactionInstruction, SystemProgram } = solanaWeb3;
  const tokenProg = tokenProgId || new PublicKey(TOKEN_PROGRAM_STR);
  // Idempotent create [1]: 6 accounts only ‚Äî no rent sysvar
  return new TransactionInstruction({
    programId: new PublicKey(ASSOC_TOKEN_PROG_STR),
    keys: [
      { pubkey: payerPk,                 isSigner: true,  isWritable: true  },
      { pubkey: ataPk,                   isSigner: false, isWritable: true  },
      { pubkey: ownerPk,                 isSigner: false, isWritable: false },
      { pubkey: mintPk,                  isSigner: false, isWritable: false },
      { pubkey: SystemProgram.programId, isSigner: false, isWritable: false },
      { pubkey: tokenProg,               isSigner: false, isWritable: false },
    ],
    data: new Uint8Array(0) // standard create (empty buffer)
  });
}

// Build wSOL wrap instructions: Transfer native SOL ‚Üí wSOL ATA + SyncNative
// Returns { preIxs: [], wsolAta: PublicKey }
async function buildWrapIxs(walletPk, lamports) {
  const { PublicKey, SystemProgram, TransactionInstruction } = solanaWeb3;
  const mintPk = new PublicKey(WSOL_MINT_PK_STR);
  const wsolAta = await findATA(walletPk, mintPk);
  const preIxs = [
    // idempotent create ‚Äî safe to include even if ATA already exists
    buildCreateATAIx(walletPk, wsolAta, walletPk, mintPk),
    // fund it with native SOL
    SystemProgram.transfer({ fromPubkey: walletPk, toPubkey: wsolAta, lamports: Number(lamports) }),
    // SyncNative (opcode 17) ‚Äî tells token program to update balance from lamports
    new TransactionInstruction({
      programId: new PublicKey(TOKEN_PROGRAM_STR),
      keys: [{ pubkey: wsolAta, isSigner: false, isWritable: true }],
      data: new Uint8Array([17])
    }),
  ];
  return { preIxs, wsolAta };
}

// Build wSOL unwrap (CloseAccount) instruction: drains wSOL ATA ‚Üí native SOL back to wallet
// opcode 9 = CloseAccount in SPL Token program
function buildUnwrapIx(walletPk, wsolAta) {
  const { PublicKey, TransactionInstruction } = solanaWeb3;
  return new TransactionInstruction({
    programId: new PublicKey(TOKEN_PROGRAM_STR),
    keys: [
      { pubkey: wsolAta,   isSigner: false, isWritable: true  }, // account to close
      { pubkey: walletPk,  isSigner: false, isWritable: true  }, // destination (gets lamports)
      { pubkey: walletPk,  isSigner: true,  isWritable: false }, // authority
    ],
    data: new Uint8Array([9])
  });
}

// ‚îÄ‚îÄ‚îÄ Deposit ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
async function dbDeposit() {
  const sel = ghostState.selectedTokens.deposit;
  if (!sel) { showNotif('Select a token first', 'error'); return; }
  const t = ghostState.walletTokens.find(w => w.mint === sel.mint) || sel;
  ghostState.selectedTokens.deposit = t;
  const amount = parseFloat(document.getElementById('depositAmt').value);
  if (!amount || amount <= 0) { showNotif('Enter a valid amount', 'error'); return; }
  if (amount > t.balance) { showNotif('‚ö†Ô∏è Insufficient wallet balance', 'error'); return; }

  const isSOL   = (t.mint === 'native');
  // Display symbol ‚Äî always show "SOL" not "wSOL" to the user
  const displaySym  = isSOL ? 'SOL' : t.symbol;
  // Internal mint used for ATAs and contract calls
  const mintStr = effectiveMint(t.mint);

  // Helper: update UI state after successful deposit
  const _applyDeposit = () => {
    t.balance = Math.max(0, t.balance - amount);
    // Vault always stores by the effective (wSOL) mint, displayed as SOL
    const vaultMint = mintStr;
    const vaultSym  = displaySym;
    const existing = ghostState.vaultTokens.find(v => v.mint === vaultMint);
    if (existing) {
      existing.balance += amount;
      if (!existing.logoUrl && t.logoUrl) existing.logoUrl = t.logoUrl;
    } else {
      ghostState.vaultTokens.push({
        symbol: vaultSym, mint: vaultMint, balance: amount,
        decimals: t.decimals, logoUrl: t.logoUrl || null, name: t.name || null
      });
    }
    buildPickerDropdown('deposit', ghostState.walletTokens.filter(tok => tok.balance > 0));
    buildPickerDropdown('bene', [WHOLE_VAULT_TOKEN, ...vaultAssignableTokens()]);
    buildPickerDropdown('burn', vaultAssignableTokens());
    document.getElementById('depositPickerBal').textContent =
      t.balance.toLocaleString(undefined, {maximumFractionDigits:6}) + ' available';
    document.getElementById('depositPickerLogo').innerHTML = tokenLogoEl(displaySym, 26, t.logoUrl||null);
    document.getElementById('depositBalance').value =
      t.balance.toLocaleString(undefined, {maximumFractionDigits:6}) + ' ' + displaySym;
    document.getElementById('depositAmt').value = '';
    document.getElementById('depositAmtDisplay').value = '';
    const depositPool = ghostState.walletTokens.filter(tok => tok.balance > 0);
    buildPickerDropdown('deposit', depositPool);
    if (!ghostState.selectedTokens.deposit || ghostState.selectedTokens.deposit.balance <= 0) {
      ghostState.selectedTokens.deposit = null;
      if (depositPool.length > 0) { selectToken('deposit', depositPool[0].mint); }
      else {
        const s=document.getElementById('depositPickerSymbol'),
              b=document.getElementById('depositPickerBal'),
              l=document.getElementById('depositPickerLogo');
        if(s)s.textContent='Select asset';if(b)b.textContent='';if(l)l.innerHTML='';
        document.getElementById('depositBalance').value='‚Äî';
      }
    }
    renderVaultHoldings(); renderVaultOverview();
    saveSession(); pumpFunFetched.delete(mintStr); setTimeout(fetchPumpFunData, 400);
  };

  // Demo mode
  if (!ghostState.provider || ghostState.walletName?.includes('demo')) {
    _applyDeposit();
    addActivityRow('üì• Deposited ' + amount.toLocaleString() + ' ' + displaySym + ' [demo]', randomTx());
    showNotif('‚úÖ Deposited ' + amount.toLocaleString(undefined,{maximumFractionDigits:4}) + ' ' + displaySym + ' to vault! [demo]', 'green');
    return;
  }

  // ‚îÄ‚îÄ On-chain ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  try {
    showNotif('Depositing ' + amount.toLocaleString(undefined,{maximumFractionDigits:4}) + ' ' + displaySym + ' to vault...', '');
    const { PublicKey, Transaction, TransactionInstruction } = solanaWeb3;
    const walletPk  = new PublicKey(ghostState.publicKey);
    const ghostPda  = new PublicKey(ghostState.ghostPda);
    const vaultPda  = new PublicKey(ghostState.vaultPda);
    const programId = new PublicKey(PROGRAM_ID);
    const TOKEN_PROG = new PublicKey(TOKEN_PROGRAM_STR);
    console.log('[Ghost] mintStr:', mintStr, 'isSOL:', isSOL);
    const mintPk     = isSOL ? null : new PublicKey(mintStr); // null for SOL, we use depositMintPk

    const connection = new solanaWeb3.Connection(RPC_URL, 'confirmed');
    const WSOL_MINT_PK = new PublicKey('So11111111111111111111111111111111111111112');

    // For SOL: work with wSOL mint + classic token program
    const depositMintPk   = isSOL ? WSOL_MINT_PK : mintPk;
    const depositMintStr  = isSOL ? 'So11111111111111111111111111111111111111112' : mintStr;
    let rawMintOwner = TOKEN_PROGRAM_STR;
    if (!isSOL && mintPk) {
      try {
        const mintAcct = await connection.getAccountInfo(mintPk);
        rawMintOwner = mintAcct?.owner?.toBase58() || TOKEN_PROGRAM_STR;
      } catch(e) { /* default to classic token */ }
    }
    // Normalize pump.fun non-standard Token-2022 ‚Üí standard for ATA creation
    const normalizedTokenProg = normalizeTokenProg(rawMintOwner);
    console.log('[Ghost] rawMintOwner:', rawMintOwner, 'normalized:', normalizedTokenProg);
    const tokenProgPk    = new PublicKey(normalizedTokenProg); // for ATA creation
    const rawTokenProgPk = new PublicKey(rawMintOwner || TOKEN_PROGRAM_STR); // for deposit instruction

    // Owner source token account
    const ownerAta = isSOL
      ? await findATA(walletPk, WSOL_MINT_PK)  // wSOL ATA (created + funded in wrap step)
      : rawMintOwner === TOKEN_PROGRAM_STR
        ? await findATA(walletPk, depositMintPk)  // classic Token ‚Äî use ATA derivation
        : (await connection.getTokenAccountsByOwner(walletPk, { mint: depositMintPk })).value[0]?.pubkey
          || await findATA(walletPk, depositMintPk); // Token-2022 ‚Äî look up real account

    // Vault destination token account
    const ghostMintStr = ghostState.ghost?.mint || GHOST_MINT;
    // For GHOST: use the stake_vault PDA (deterministic, program-owned)
    // For other tokens: look up existing token account on-chain first,
    //   fall back to ATA derivation if none found yet
    let vaultAta;
    if (depositMintStr === ghostMintStr) {
      const [pk] = await solanaWeb3.PublicKey.findProgramAddress(
        [new TextEncoder().encode('stake_vault'), walletPk.toBytes()],
        new PublicKey(PROGRAM_ID)
      );
      vaultAta = pk;
    } else {
      // Check for existing token accounts owned by vaultPda for this mint
      try {
        const existing = await connection.getTokenAccountsByOwner(vaultPda, { mint: depositMintPk });
        if (existing.value.length > 0) {
          vaultAta = existing.value[0].pubkey;
          console.log('[Ghost] Found existing vault token account:', vaultAta.toBase58());
        }
      } catch(_) {}
      if (!vaultAta) {
        vaultAta = await findATAWithProg(vaultPda, depositMintPk, tokenProgPk);
      }
    }

    console.log('[Ghost] deposit mint:', depositMintPk.toBase58(), 'tokenProg:', tokenProgPk.toBase58());
    console.log('[Ghost] ownerAta:', ownerAta.toBase58(), 'vaultAta:', vaultAta.toBase58());

    const { blockhash } = await connection.getLatestBlockhash();
    const tx = new Transaction({ recentBlockhash: blockhash, feePayer: walletPk });

    // Phase 1: Create vault token account if needed
    const vaultAtaInfo = await connection.getAccountInfo(vaultAta);
    console.log('[Ghost] vaultAta:', vaultAta.toBase58(), 'exists:', !!vaultAtaInfo);
    if (!vaultAtaInfo) {
      // Step 1a: Fund vault PDA so ATA program accepts it as a valid owner
      const vaultPdaInfo = await connection.getAccountInfo(vaultPda);
      console.log('[Ghost] vaultPda lamports:', vaultPdaInfo?.lamports ?? 0);
      if (!vaultPdaInfo || vaultPdaInfo.lamports === 0) {
        showNotif('Activating vault...', '');
        const minRent = await connection.getMinimumBalanceForRentExemption(0);
        const { blockhash: fundBh } = await connection.getLatestBlockhash();
        const fundTx = new Transaction({ recentBlockhash: fundBh, feePayer: walletPk });
        fundTx.add(solanaWeb3.SystemProgram.transfer({
          fromPubkey: walletPk, toPubkey: vaultPda, lamports: minRent
        }));
        const fundSigned = await ghostState.provider.signTransaction(fundTx);
        const fundSig = await connection.sendRawTransaction(fundSigned.serialize(), { skipPreflight: true });
        console.log('[Ghost] Vault PDA fund tx:', fundSig);
        const fundConf = await connection.confirmTransaction(fundSig, 'confirmed');
        if (fundConf.value?.err) throw new Error('Vault activation failed: ' + JSON.stringify(fundConf.value.err));
        console.log('[Ghost] Vault PDA funded');
      }

      // Step 1b: Create vault token account via raw createAccount + initializeAccount3
      // Bypasses ATA program which fails with ProgramAccountNotFound on some RPCs
      showNotif('Initializing vault token account...', '');
      console.log('[Ghost] Creating vault token account manually');
      const { blockhash: initBh } = await connection.getLatestBlockhash();
      const initTx = new Transaction({ recentBlockhash: initBh, feePayer: walletPk });
      const { createIx, initIx, kp: vaultTokenKp } = await buildManualTokenAccountIxs(
        walletPk, depositMintPk, vaultPda, rawTokenProgPk, connection
      );
      initTx.add(createIx, initIx);
      // Wallet signs first, then keypair signs ‚Äî Phantom may strip pre-existing partial sigs
      const initWalletSigned = await ghostState.provider.signTransaction(initTx);
      initWalletSigned.partialSign(vaultTokenKp); // add keypair sig AFTER wallet
      const initSig = await connection.sendRawTransaction(initWalletSigned.serialize(), { skipPreflight: true });
      console.log('[Ghost] Vault token account tx:', initSig, 'addr:', vaultTokenKp.publicKey.toBase58());
      const initConf = await connection.confirmTransaction(initSig, 'confirmed');
      if (initConf.value?.err) throw new Error('Vault init failed: ' + JSON.stringify(initConf.value.err));
      // Override vaultAta to use the newly created account
      vaultAta = vaultTokenKp.publicKey;
      console.log('[Ghost] Vault token account created:', vaultAta.toBase58());
      showNotif('Vault ready ‚Äî proceeding with deposit...', '');
      const { blockhash: newBh } = await connection.getLatestBlockhash();
      tx.recentBlockhash = newBh;
    }

    // Phase 2: For SOL ‚Äî wrap native SOL to wSOL in separate tx
    let effectiveOwnerAta = ownerAta;
    if (isSOL) {
      const lamports = Math.round(amount * 1e9);
      const { instructions: wrapIxs, wsolAta, kp: wsolKp } = await buildWrapSOLInstructions(walletPk, lamports, connection);
      showNotif('Wrapping SOL...', '');
      const { blockhash: wrapBh } = await connection.getLatestBlockhash();
      const wrapTx = new Transaction({ recentBlockhash: wrapBh, feePayer: walletPk });
      wrapIxs.forEach(ix => wrapTx.add(ix));
      console.log('[Ghost] SOL wrap account:', wsolAta.toBase58(), 'newKp:', !!wsolKp);
      const wrapWalletSigned = await ghostState.provider.signTransaction(wrapTx);
      if (wsolKp) wrapWalletSigned.partialSign(wsolKp);
      const wrapSig = await connection.sendRawTransaction(wrapWalletSigned.serialize(), { skipPreflight: true });
      const wrapConf = await connection.confirmTransaction(wrapSig, 'confirmed');
      if (wrapConf.value?.err) throw new Error('SOL wrap failed: ' + JSON.stringify(wrapConf.value.err));
      effectiveOwnerAta = wsolAta;
      showNotif('SOL wrapped ‚Äî depositing...', '');
      const { blockhash: depBh } = await connection.getLatestBlockhash();
      tx.recentBlockhash = depBh;
    }

    // Phase 3: Deposit
    const disc = [18, 62, 110, 8, 26, 106, 248, 151];
    const amountRaw = BigInt(Math.round(amount * Math.pow(10, isSOL ? 9 : t.decimals)));
    const buf = new ArrayBuffer(8);
    new DataView(buf).setBigUint64(0, amountRaw, true);
    const data = new Uint8Array(16);
    data.set(disc, 0); data.set(new Uint8Array(buf), 8);

    tx.add(new TransactionInstruction({ programId,
      keys: [
        { pubkey: ghostPda,          isSigner: false, isWritable: false },
        { pubkey: walletPk,          isSigner: true,  isWritable: true  },
        { pubkey: depositMintPk,     isSigner: false, isWritable: false },
        { pubkey: effectiveOwnerAta, isSigner: false, isWritable: true  },
        { pubkey: vaultAta,          isSigner: false, isWritable: true  },
        { pubkey: rawTokenProgPk,    isSigner: false, isWritable: false },
      ], data }));

    const signed = await ghostState.provider.signTransaction(tx);
    let sig;
    try {
      sig = await connection.sendRawTransaction(signed.serialize(), { 
        skipPreflight: false,
        preflightCommitment: 'confirmed'
      });
    } catch(simErr) {
      // Get detailed logs from the SendTransactionError
      let logs = [];
      try { logs = await simErr.getLogs(connection); } catch(_) {}
      if (!logs?.length) {
        // Fall back to manual simulation with unsigned tx
        try {
          const sim = await connection.simulateTransaction(tx);
          logs = sim.value.logs || [];
          console.error('[Ghost] Sim error:', sim.value.err);
        } catch(_) {}
      }
      console.error('[Ghost] TX logs:', logs);
      const lastLogs = logs.slice(-5).join(' | ');
      throw new Error('TX failed: ' + simErr.message + (lastLogs ? ' | ' + lastLogs : ''));
    }
    const conf   = await connection.confirmTransaction(sig, 'confirmed');
    if (conf.value?.err) throw new Error('TX failed: ' + JSON.stringify(conf.value.err));

    _applyDeposit();
    const shortSig = sig.slice(0,4)+'...'+sig.slice(-4);
    addActivityRow('üì• Deposited ' + amount.toLocaleString() + ' ' + displaySym, shortSig);
    showNotif('‚úÖ Deposited ' + amount.toLocaleString(undefined,{maximumFractionDigits:4}) + ' ' + displaySym + ' to vault!', 'green');
  } catch(err) {
    console.error('Deposit error:', err);
    showNotif('Deposit failed: ' + (err.message || err), 'error');
  }
}

// ‚îÄ‚îÄ‚îÄ Withdraw ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
async function dbWithdrawAsset(vaultIdx) {
  if (ghostState.ghost.status === 'awakened') { showNotif('‚ö†Ô∏è Withdrawals blocked while awakened', 'error'); return; }
  const vt = ghostState.vaultTokens[vaultIdx];
  if (!vt) return;
  const wdEl  = document.getElementById('wdAmt' + vaultIdx);
  const amount = parseFloat(wdEl?.dataset.raw || wdEl?.value || '0');
  if (!amount || amount <= 0) { showNotif('Enter an amount to withdraw', 'error'); return; }
  if (amount > vt.balance)   { showNotif('‚ö†Ô∏è Exceeds vault balance', 'error'); return; }

  // wSOL stored in vault always displayed as SOL to the user
  const isSOL     = (vt.mint === WSOL_MINT_PK_STR || vt.mint === 'native');
  const displaySym = isSOL ? 'SOL' : vt.symbol;
  const mintStr    = effectiveMint(vt.mint);

  const _applyWithdraw = () => {
    vt.balance -= amount;
    if (vt.balance <= 0.000000001) ghostState.vaultTokens.splice(vaultIdx, 1);
    // Return to wallet ‚Äî native SOL entry (mint:'native') for wSOL withdrawals
    const walletMint = isSOL ? 'native' : vt.mint;
    const wt = ghostState.walletTokens.find(w => w.mint === walletMint);
    if (wt) {
      wt.balance += amount;
      const sel = ghostState.selectedTokens.deposit;
      if (sel && sel.mint === walletMint) {
        document.getElementById('depositPickerBal').textContent =
          wt.balance.toLocaleString(undefined,{maximumFractionDigits:6}) + ' available';
        document.getElementById('depositBalance').value =
          wt.balance.toLocaleString(undefined,{maximumFractionDigits:6}) + ' ' + displaySym;
      }
    } else {
      ghostState.walletTokens.push({ symbol: displaySym, mint: walletMint, balance: amount, decimals: vt.decimals, logoUrl: vt.logoUrl||null });
    }
    buildPickerDropdown('deposit', ghostState.walletTokens.filter(tok => tok.balance > 0));
    buildPickerDropdown('bene', [WHOLE_VAULT_TOKEN, ...vaultAssignableTokens()]);
    buildPickerDropdown('burn', vaultAssignableTokens());
    renderVaultHoldings(); renderVaultOverview(); saveSession();
  };

  // Demo mode
  if (!ghostState.provider || ghostState.walletName?.includes('demo')) {
    _applyWithdraw();
    addActivityRow('üì§ Withdrew ' + amount.toLocaleString() + ' ' + displaySym + ' [demo]', randomTx());
    showNotif('‚úÖ Withdrew ' + amount.toLocaleString(undefined,{maximumFractionDigits:4}) + ' ' + displaySym + ' [demo]', 'green');
    return;
  }

  // ‚îÄ‚îÄ On-chain ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  try {
    showNotif('Withdrawing ' + amount.toLocaleString(undefined,{maximumFractionDigits:4}) + ' ' + displaySym + '...', '');
    const { PublicKey, Transaction, TransactionInstruction } = solanaWeb3;
    const walletPk  = new PublicKey(ghostState.publicKey);
    const ghostPda  = new PublicKey(ghostState.ghostPda);
    const vaultPda  = new PublicKey(ghostState.vaultPda);
    const programId = new PublicKey(PROGRAM_ID);
    const TOKEN_PROG = new PublicKey(TOKEN_PROGRAM_STR);
    console.log('[Ghost] mintStr:', mintStr, 'isSOL:', isSOL);

    // For SOL: always use wSOL mint for ATA derivation ‚Äî never pass null
    const WSOL_MINT_PK = new PublicKey(WSOL_MINT_PK_STR);
    const mintPk = isSOL ? WSOL_MINT_PK : new PublicKey(mintStr);

    const ownerAta = await findATA(walletPk, mintPk);
    const vaultAta = await findATA(vaultPda, mintPk);

    // withdraw_from_vault discriminator: sha256("global:withdraw_from_vault")[0:8]
    const disc = [180, 34, 37, 46, 156, 0, 211, 238];
    const amountRaw = BigInt(Math.round(amount * Math.pow(10, vt.decimals)));
    const buf = new ArrayBuffer(8);
    new DataView(buf).setBigUint64(0, amountRaw, true);
    const data = new Uint8Array(16);
    data.set(disc, 0); data.set(new Uint8Array(buf), 8);

    const connection = new solanaWeb3.Connection(RPC_URL, 'confirmed');
    const { blockhash } = await connection.getLatestBlockhash();
    const tx = new Transaction({ recentBlockhash: blockhash, feePayer: walletPk });

    tx.add(new TransactionInstruction({ programId,
      keys: [
        { pubkey: ghostPda,   isSigner: false, isWritable: false },
        { pubkey: vaultPda,   isSigner: false, isWritable: false },
        { pubkey: walletPk,   isSigner: true,  isWritable: true  },
        { pubkey: mintPk,     isSigner: false, isWritable: false },
        { pubkey: ownerAta,   isSigner: false, isWritable: true  },
        { pubkey: vaultAta,   isSigner: false, isWritable: true  },
        { pubkey: TOKEN_PROG, isSigner: false, isWritable: false },
      ], data }));

    // For SOL: after withdraw_from_vault moves wSOL to owner's ATA,
    // close the wSOL ATA to convert back to native SOL automatically.
    // This is the unwrap ‚Äî user sees SOL arrive in wallet, never sees wSOL.
    if (isSOL) {
      tx.add(buildUnwrapIx(walletPk, ownerAta));
    }

    // Debug: log each instruction individually so console doesn't collapse
    tx.instructions.forEach((ix, i) => 
      console.log(`[Ghost] ix${i}: prog=${ix.programId.toBase58()} accounts=${ix.keys.length} data=${ix.data.length}b`)
    );
    const signed = await ghostState.provider.signTransaction(tx);
    const sig    = await connection.sendRawTransaction(signed.serialize());
    await connection.confirmTransaction(sig, 'confirmed');

    _applyWithdraw();
    const shortSig = sig.slice(0,4)+'...'+sig.slice(-4);
    addActivityRow('üì§ Withdrew ' + amount.toLocaleString() + ' ' + displaySym, shortSig);
    showNotif('‚úÖ Withdrew ' + amount.toLocaleString(undefined,{maximumFractionDigits:4}) + ' ' + displaySym + ' to wallet!', 'green');
  } catch(err) {
    console.error('Withdraw error:', err);
    showNotif('Withdraw failed: ' + (err.message || err), 'error');
  }
}


// ‚îÄ‚îÄ‚îÄ Settings ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function syncSettingsDisplay() {
  const g = ghostState.ghost;
  const iDays = Math.round(g.intervalSeconds / 86400);
  const gDays = Math.round(g.gracePeriodSeconds / 86400);
  const el = id => document.getElementById(id);
  if (el('settingsIntervalVal')) el('settingsIntervalVal').textContent = iDays;
  if (el('settingsIntervalSub')) el('settingsIntervalSub').textContent = 'days ¬∑ ~' + (iDays/30).toFixed(1) + ' months';
  if (el('settingsGraceVal')) el('settingsGraceVal').textContent = gDays;
  if (el('settingsGraceSub')) el('settingsGraceSub').textContent = 'days after silence detected';
  if (el('settingsStakedVal')) el('settingsStakedVal').textContent = (g.stakedGhost || 10000).toLocaleString();
}

async function dbUpdateInterval() {
  const days = parseInt(document.getElementById('dbNewInterval').value);
  if (!days || days < 7) { showNotif('‚ö†Ô∏è Minimum 7 days required', 'error'); return; }
  const seconds = days * 86400;

  if (!ghostState.provider || ghostState.walletName?.includes('demo')) {
    ghostState.ghost.intervalSeconds = seconds;
    document.getElementById('dbInterval').textContent = days + ' days';
    document.getElementById('dbNewInterval').value = '';
    document.getElementById('dbIntervalPreview').textContent = days + ' days ‚âà ' + (days/30).toFixed(1) + ' months';
    syncSettingsDisplay(); updateCountdown();
    showNotif('‚úÖ Interval updated [demo]', 'green'); return;
  }
  try {
    showNotif('Updating interval...', '');
    const { PublicKey, Transaction, TransactionInstruction } = solanaWeb3;
    const walletPubkey = new PublicKey(ghostState.publicKey);
    const ghostPda = new PublicKey(ghostState.ghostPda);
    const programId = new PublicKey(PROGRAM_ID);
    // sha256("global:update_interval")[0:8]
    const disc = [0, 103, 203, 94, 136, 229, 87, 49];
    const buf = new ArrayBuffer(8);
    new DataView(buf).setBigInt64(0, BigInt(seconds), true);
    const data = new Uint8Array(8 + 8);
    data.set(disc, 0); data.set(new Uint8Array(buf), 8);
    const ix = new TransactionInstruction({ programId,
      keys: [{ pubkey: ghostPda, isSigner: false, isWritable: true }, { pubkey: walletPubkey, isSigner: true, isWritable: true }], data });
    const connection = new solanaWeb3.Connection(RPC_URL, 'confirmed');
    const { blockhash } = await connection.getLatestBlockhash();
    const tx = new Transaction({ recentBlockhash: blockhash, feePayer: walletPubkey });
    tx.add(ix);
    // Debug: log each instruction individually so console doesn't collapse
    tx.instructions.forEach((ix, i) => 
      console.log(`[Ghost] ix${i}: prog=${ix.programId.toBase58()} accounts=${ix.keys.length} data=${ix.data.length}b`)
    );
    const signed = await ghostState.provider.signTransaction(tx);
    const sig = await connection.sendRawTransaction(signed.serialize(), { skipPreflight: true, preflightCommitment: 'confirmed' });
    console.log('[Ghost] TX sent:', sig);
    const conf = await connection.confirmTransaction(sig, 'confirmed');
    console.log('[Ghost] TX confirmed:', conf);
    if (conf.value?.err) throw new Error('TX failed: ' + JSON.stringify(conf.value.err));
    ghostState.ghost.intervalSeconds = seconds;
    document.getElementById('dbInterval').textContent = days + ' days';
    document.getElementById('dbNewInterval').value = '';
    document.getElementById('dbIntervalPreview').textContent = days + ' days ‚âà ' + (days/30).toFixed(1) + ' months';
    syncSettingsDisplay(); updateCountdown();
    showNotif('‚úÖ Interval updated on-chain: ' + days + ' days', 'green');
  } catch(err) { showNotif('Failed: ' + (err.message || err), 'error'); }
}

async function dbUpdateGrace() {
  const days = parseInt(document.getElementById('dbNewGrace').value);
  if (!days || days < 1) { showNotif('‚ö†Ô∏è Minimum 1 day required', 'error'); return; }
  const seconds = days * 86400;

  if (!ghostState.provider || ghostState.walletName?.includes('demo')) {
    ghostState.ghost.gracePeriodSeconds = seconds;
    document.getElementById('dbGrace').textContent = days + ' days';
    document.getElementById('dbNewGrace').value = '';
    document.getElementById('dbGracePreview').textContent = days + ' days';
    syncSettingsDisplay();
    showNotif('‚úÖ Grace period updated [demo]', 'green'); return;
  }
  try {
    showNotif('Updating grace period...', '');
    const { PublicKey, Transaction, TransactionInstruction } = solanaWeb3;
    const walletPubkey = new PublicKey(ghostState.publicKey);
    const ghostPda = new PublicKey(ghostState.ghostPda);
    const programId = new PublicKey(PROGRAM_ID);
    // sha256("global:update_grace_period")[0:8]
    const disc = [7, 76, 130, 186, 86, 93, 66, 134];
    const buf = new ArrayBuffer(8);
    new DataView(buf).setBigInt64(0, BigInt(seconds), true);
    const data = new Uint8Array(8 + 8);
    data.set(disc, 0); data.set(new Uint8Array(buf), 8);
    const ix = new TransactionInstruction({ programId,
      keys: [{ pubkey: ghostPda, isSigner: false, isWritable: true }, { pubkey: walletPubkey, isSigner: true, isWritable: true }], data });
    const connection = new solanaWeb3.Connection(RPC_URL, 'confirmed');
    const { blockhash } = await connection.getLatestBlockhash();
    const tx = new Transaction({ recentBlockhash: blockhash, feePayer: walletPubkey });
    tx.add(ix);
    // Debug: log each instruction individually so console doesn't collapse
    tx.instructions.forEach((ix, i) => 
      console.log(`[Ghost] ix${i}: prog=${ix.programId.toBase58()} accounts=${ix.keys.length} data=${ix.data.length}b`)
    );
    const signed = await ghostState.provider.signTransaction(tx);
    const sig = await connection.sendRawTransaction(signed.serialize(), { skipPreflight: true, preflightCommitment: 'confirmed' });
    console.log('[Ghost] TX sent:', sig);
    const conf = await connection.confirmTransaction(sig, 'confirmed');
    console.log('[Ghost] TX confirmed:', conf);
    if (conf.value?.err) throw new Error('TX failed: ' + JSON.stringify(conf.value.err));
    ghostState.ghost.gracePeriodSeconds = seconds;
    document.getElementById('dbGrace').textContent = days + ' days';
    document.getElementById('dbNewGrace').value = '';
    document.getElementById('dbGracePreview').textContent = days + ' days';
    syncSettingsDisplay();
    showNotif('‚úÖ Grace period updated on-chain: ' + days + ' days', 'green');
  } catch(err) { showNotif('Failed: ' + (err.message || err), 'error'); }
}



async function dbAbandon() {
  // Step 1: Confirmation modal
  const confirmed = await new Promise(resolve => {
    const modal = document.createElement('div');
    modal.style.cssText = 'position:fixed;inset:0;z-index:100000;background:rgba(5,5,15,0.9);display:flex;align-items:center;justify-content:center;backdrop-filter:blur(6px)';
    modal.innerHTML = `
      <div style="background:#0e0b1a;border:1px solid rgba(255,61,90,0.4);border-radius:12px;padding:36px;max-width:420px;width:90%;text-align:center;box-shadow:0 0 60px rgba(255,61,90,0.15)">
        <div style="font-size:48px;margin-bottom:16px;filter:drop-shadow(0 0 12px rgba(255,80,40,0.6))">‚ö†Ô∏è</div>
        <div style="font-family:'Syne',sans-serif;font-weight:800;font-size:20px;color:#ff6080;margin-bottom:10px">Abandon Ghost?</div>
        <div style="font-family:'Share Tech Mono',monospace;font-size:13px;color:#b0a8d0;line-height:1.7;margin-bottom:24px">
          This permanently closes your vault and burns <span style="color:#ff6080;font-weight:700">50% of your staked $GHOST</span>.<br><br>
          Your beneficiaries will <strong>not</strong> receive anything. All assets held in your vault ‚Äî plus the remaining 50% $GHOST ‚Äî are returned directly to your wallet. <strong>This cannot be undone.</strong>
        </div>
        <div style="display:flex;gap:12px;justify-content:center">
          <button id="_abandonCancel" style="background:rgba(255,255,255,0.05);border:1px solid rgba(255,255,255,0.15);color:#b0a8d0;padding:10px 24px;border-radius:6px;cursor:pointer;font-family:'Share Tech Mono',monospace;font-size:13px">Cancel</button>
          <button id="_abandonConfirm" style="background:rgba(255,61,90,0.15);border:1px solid rgba(255,61,90,0.5);color:#ff6080;padding:10px 24px;border-radius:6px;cursor:pointer;font-family:'Syne',sans-serif;font-weight:700;font-size:14px">Yes, Abandon Forever</button>
        </div>
      </div>`;
    document.body.appendChild(modal);
    document.getElementById('_abandonCancel').onclick = () => { modal.remove(); resolve(false); };
    document.getElementById('_abandonConfirm').onclick = () => { modal.remove(); resolve(true); };
  });

  if (!confirmed) return;

  // Step 2: Ghost fly-up animation overlay
  const overlay = document.createElement('div');
  overlay.className = 'ghost-abandon-overlay';

  // Particle colors
  const particleColors = ['#a060ff','#ff60a0','#60a0ff','#ffffff','#ffcc00'];
  const particles = Array.from({length: 20}, (_, i) => {
    const angle = (i / 20) * Math.PI * 2;
    const dist = 80 + Math.random() * 100;
    const tx = Math.cos(angle) * dist + 'px';
    const ty = (Math.sin(angle) * dist - 60) + 'px';
    const color = particleColors[i % particleColors.length];
    return `<div class="particle" style="background:${color};top:50%;left:50%;margin:-4px;--tx:${tx};--ty:${ty};animation-delay:${0.7 + Math.random()*0.3}s;animation-duration:${0.8+Math.random()*0.4}s;box-shadow:0 0 6px ${color}"></div>`;
  }).join('');

  overlay.innerHTML = `
    <div style="position:relative;text-align:center">
      ${particles}
      <span class="ghost-fly-char">üëª</span>
      <div id="abandonMsg" style="font-family:'Syne',sans-serif;font-weight:800;font-size:18px;color:#a060ff;margin-top:20px;opacity:0;transition:opacity 0.6s">
        Ghost released‚Ä¶
      </div>
      <div style="font-family:'Share Tech Mono',monospace;font-size:12px;color:#6050a0;margin-top:8px;opacity:0;transition:opacity 0.6s" id="abandonSub">
        50% of staked $GHOST burned forever
      </div>
    </div>`;
  document.body.appendChild(overlay);

  // Fade in the text message after 1.2s
  setTimeout(() => {
    document.getElementById('abandonMsg').style.opacity = '1';
    document.getElementById('abandonSub').style.opacity = '1';
  }, 1200);

  // Step 3: After animation (2.8s), clean up and show aftermath
  await new Promise(r => setTimeout(r, 2800));
  overlay.remove();

  // Step 4: Reset state to show "no vault" / aftermath
  const stakedAmt = ghostState.ghost.stakedGhost || 0;
  const burnedAmt = Math.floor(stakedAmt * 0.5);
  const returnedAmt = stakedAmt - burnedAmt;

  ghostState.ghost = {
    status: 'abandoned',
    stakedGhost: 0,
    pingCount: 0,
    beneficiaries: [],
    wholeVaultShares: [],
  };
  ghostState.walletConnected = true;
  saveSession();

  // Lock nav items
  document.querySelectorAll('.db-nav-item').forEach(n => {
    if (!n.onclick?.toString().includes('watcher') && !n.onclick?.toString().includes('closeDashboard')) {
      n.classList.add('db-nav-locked');
    }
  });

  // Show aftermath screen on overview
  const overviewPage = document.getElementById('db-page-overview');
  document.querySelectorAll('.db-page').forEach(p => p.classList.remove('active'));
  document.querySelectorAll('.db-nav-item').forEach(n => n.classList.remove('active'));
  overviewPage.classList.add('active');
  document.getElementById('nav-overview')?.classList.remove('db-nav-locked');
  document.getElementById('nav-overview')?.classList.add('active');

  overviewPage.innerHTML = `
    <div class="db-page-title">Ghost Abandoned</div>
    <div class="db-page-sub">Your vault has been closed</div>
    <div style="animation:aftermath-fade-in 0.8s ease-out both">
      <div style="background:rgba(102,51,255,0.04);border:1px solid rgba(102,51,255,0.15);border-radius:10px;padding:32px;margin-bottom:20px;text-align:center">
        <div style="font-size:56px;margin-bottom:16px;opacity:0.4">üëª</div>
        <div style="font-family:'Syne',sans-serif;font-weight:800;font-size:22px;color:#a060ff;margin-bottom:8px">Your ghost is gone</div>
        <div style="font-family:'Share Tech Mono',monospace;font-size:13px;color:#7060a0;line-height:1.7">
          The vault has been closed on-chain.<br>No assets were distributed to beneficiaries.
        </div>
      </div>

      <div style="display:grid;grid-template-columns:1fr 1fr;gap:12px;margin-bottom:20px">
        <div style="background:rgba(255,61,90,0.06);border:1px solid rgba(255,61,90,0.2);border-radius:8px;padding:20px;text-align:center">
          <div style="font-family:'Share Tech Mono',monospace;font-size:11px;color:rgba(255,96,128,0.6);margin-bottom:6px;letter-spacing:0.1em">BURNED FOREVER</div>
          <div style="font-family:'Syne',sans-serif;font-weight:800;font-size:20px;color:#ff6080">${burnedAmt.toLocaleString()} $GHOST</div>
          <div style="font-family:'Share Tech Mono',monospace;font-size:11px;color:#ff6080;margin-top:4px;opacity:0.6">50% penalty</div>
        </div>
        <div style="background:rgba(102,51,255,0.06);border:1px solid rgba(102,51,255,0.2);border-radius:8px;padding:20px;text-align:center">
          <div style="font-family:'Share Tech Mono',monospace;font-size:11px;color:rgba(160,96,255,0.6);margin-bottom:6px;letter-spacing:0.1em">RETURNED TO WALLET</div>
          <div style="font-family:'Syne',sans-serif;font-weight:800;font-size:20px;color:#a060ff">${returnedAmt.toLocaleString()} $GHOST</div>
          <div style="font-family:'Share Tech Mono',monospace;font-size:11px;color:#a060ff;margin-top:4px;opacity:0.6">50% recovered</div>
        </div>
      </div>

      <div style="background:rgba(102,51,255,0.04);border:1px solid rgba(102,51,255,0.1);border-radius:8px;padding:20px;margin-bottom:20px">
        <div style="font-family:'Syne',sans-serif;font-weight:700;font-size:14px;color:#b0a8d0;margin-bottom:12px">What happened on-chain</div>
        <div style="font-family:'Share Tech Mono',monospace;font-size:12px;color:#6050a0;line-height:2">
          <span style="color:#a060ff">‚úì</span> Vault PDA closed ‚Äî rent lamports returned<br>
          <span style="color:#ff6080">‚úì</span> ${burnedAmt.toLocaleString()} $GHOST sent to burn address<br>
          <span style="color:#a060ff">‚úì</span> ${returnedAmt.toLocaleString()} $GHOST returned to your wallet<br>
          <span style="color:#a060ff">‚úì</span> All vault assets (SOL, SPL tokens) returned to your wallet<br>
          <span style="color:#6050a0">‚úó</span> No beneficiary transfers executed
        </div>
      </div>

      <div style="text-align:center">
        <button onclick="dbSummonNew()" style="background:rgba(102,51,255,0.15);border:1px solid rgba(102,51,255,0.4);color:#a060ff;padding:12px 32px;border-radius:8px;cursor:pointer;font-family:'Syne',sans-serif;font-weight:700;font-size:15px;transition:all 0.2s" onmouseover="this.style.background='rgba(102,51,255,0.25)'" onmouseout="this.style.background='rgba(102,51,255,0.15)'">
          üëª Summon a New Ghost
        </button>
      </div>
    </div>`;

  // Helper to restart 
  window.dbSummonNew = function() {
    ghostState.ghost = { status: 'none', stakedGhost: 0, pingCount: 0, beneficiaries: [], wholeVaultShares: [] };
    saveSession();
    location.reload();
  };
}
</script>

</div>
</body>
</html>