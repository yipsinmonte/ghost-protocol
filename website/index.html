<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>GHOST ‚Äî Your Digital Afterlife on Solana</title>
<link href="https://fonts.googleapis.com/css2?family=Share+Tech+Mono&family=Cormorant+Garamond:ital,wght@0,300;0,400;1,300;1,400&family=Syne:wght@400;700;800&display=swap" rel="stylesheet">
<style>
  *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
  :root {
    --black: #030305; --deep: #07070f; --ghost: #0d0d1a; --dim: #11111f;
    --accent: #7744ff; --accent2: #4422cc; --glow: #9966ff;
    --pulse: #ff3366; --text: #e0e0ec; --muted: #9090a8; --white: #f0f0f8;
    --sol: #9945ff; --green: #33ff99; --amber: #ffb830; --red: #ff3d5a;
    --card: #0a0a18; --border: rgba(102,51,255,0.12);
  }
  html { scroll-behavior: smooth; }
  body { background: var(--black); color: var(--text); font-family: 'Syne', sans-serif; font-size: 18px; line-height: 1.7; cursor: crosshair; font-weight: 400; }
  .marketing-site { overflow-x: hidden; }
  body::before { content: ''; position: fixed; inset: 0; background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 256 256' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noise)' opacity='0.04'/%3E%3C/svg%3E"); pointer-events: none; z-index: 999; opacity: 0.5; }
  body::after { content: ''; position: fixed; inset: 0; background: repeating-linear-gradient(0deg, transparent, transparent 2px, rgba(0,0,0,0.08) 2px, rgba(0,0,0,0.08) 4px); pointer-events: none; z-index: 998; }

  /* ‚îÄ‚îÄ‚îÄ NAV ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
  nav { position: fixed; top: 0; width: 100%; padding: 20px 48px; display: flex; justify-content: space-between; align-items: center; z-index: 100; background: linear-gradient(to bottom, rgba(3,3,5,0.97), transparent); border-bottom: 1px solid rgba(102,51,255,0.08); }
  .nav-logo { font-family: 'Syne', sans-serif; font-weight: 800; font-size: 20px; letter-spacing: 0.3em; color: var(--white); text-decoration: none; }
  .nav-logo span { color: var(--accent); }
  .nav-links { display: flex; gap: 36px; list-style: none; align-items: center; }
  .nav-links a { font-family: 'Share Tech Mono', monospace; font-size: 13px; letter-spacing: 0.2em; color: var(--muted); text-decoration: none; text-transform: uppercase; transition: color 0.3s; }
  .nav-links a:hover { color: var(--glow); }

  /* Dashboard nav link ‚Äî hidden until connected */
  .nav-dashboard-link { display: none !important; }
  .nav-dashboard-link.visible { display: flex !important; align-items: center; gap: 6px; color: var(--green) !important; border: 1px solid rgba(51,255,153,0.25); padding: 6px 14px; transition: all 0.3s; }
  .nav-dashboard-link.visible:hover { background: rgba(51,255,153,0.08); border-color: var(--green); }
  .nav-dashboard-dot { width: 6px; height: 6px; border-radius: 50%; background: var(--green); animation: pulse-dot 2s ease-in-out infinite; }
  @keyframes pulse-dot { 0%,100%{opacity:1} 50%{opacity:0.3} }

  .wallet-btn { font-family: 'Share Tech Mono', monospace; font-size: 13px; letter-spacing: 0.15em; text-transform: uppercase; padding: 10px 20px; border: 1px solid var(--sol); color: var(--sol); background: transparent; cursor: pointer; transition: all 0.3s; position: relative; overflow: hidden; }
  .wallet-btn::before { content: ''; position: absolute; inset: 0; background: var(--sol); transform: translateX(-100%); transition: transform 0.3s; z-index: -1; }
  .wallet-btn:hover { color: var(--black); }
  .wallet-btn:hover::before { transform: translateX(0); }
  .wallet-btn.connected { border-color: var(--green); color: var(--green); }
  .wallet-btn.connected:hover { color: var(--black); }
  .wallet-btn.connected::before { background: var(--green); }

  /* ‚îÄ‚îÄ‚îÄ CONTRACT BANNER ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
  .contract-banner { background: rgba(102,51,255,0.06); border-bottom: 1px solid rgba(102,51,255,0.12); padding: 10px 48px; display: flex; justify-content: center; align-items: center; gap: 16px; margin-top: 73px; font-family: 'Share Tech Mono', monospace; font-size: 13px; }
  .contract-banner .label { color: var(--muted); letter-spacing: 0.2em; text-transform: uppercase; }
  .contract-addr { color: var(--accent); letter-spacing: 0.1em; }
  .copy-btn { background: none; border: 1px solid rgba(102,51,255,0.3); color: var(--muted); font-family: 'Share Tech Mono', monospace; font-size: 12px; padding: 3px 10px; cursor: pointer; letter-spacing: 0.15em; transition: all 0.2s; }
  .copy-btn:hover { border-color: var(--accent); color: var(--accent); }
  .sol-badge { background: rgba(153,69,255,0.15); border: 1px solid rgba(153,69,255,0.3); color: var(--sol); font-size: 12px; padding: 3px 10px; letter-spacing: 0.2em; }

  /* ‚îÄ‚îÄ‚îÄ HERO ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
  .hero { min-height: 100vh; display: flex; flex-direction: column; justify-content: center; align-items: center; text-align: center; padding: 100px 40px 80px; position: relative; overflow: hidden; }
  .hero-bg { position: absolute; inset: 0; background: radial-gradient(ellipse 60% 50% at 50% 60%, rgba(102,51,255,0.08) 0%, transparent 70%), radial-gradient(ellipse 30% 30% at 20% 20%, rgba(51,17,170,0.05) 0%, transparent 60%); pointer-events: none; }
  .hero-grid { position: absolute; inset: 0; background-image: linear-gradient(rgba(102,51,255,0.04) 1px, transparent 1px), linear-gradient(90deg, rgba(102,51,255,0.04) 1px, transparent 1px); background-size: 60px 60px; mask-image: radial-gradient(ellipse 80% 80% at 50% 50%, black 0%, transparent 100%); pointer-events: none; }
  .heartbeat-ring { position: absolute; width: 600px; height: 600px; border-radius: 50%; border: 1px solid rgba(102,51,255,0.1); top: 50%; left: 50%; transform: translate(-50%, -50%); animation: ring-pulse 4s ease-in-out infinite; pointer-events: none; }
  .heartbeat-ring:nth-child(2) { width: 800px; height: 800px; animation-delay: 1s; opacity: 0.6; }
  .heartbeat-ring:nth-child(3) { width: 1000px; height: 1000px; animation-delay: 2s; opacity: 0.3; }
  @keyframes ring-pulse { 0%, 100% { transform: translate(-50%, -50%) scale(1); opacity: 0.2; } 50% { transform: translate(-50%, -50%) scale(1.05); opacity: 0.5; } }
  .hero-logo { width: 120px; height: 120px; margin-bottom: 32px; animation: fade-up 1s ease both; filter: drop-shadow(0 0 30px rgba(102,51,255,0.5)); }
  .hero-eyebrow { font-family: 'Share Tech Mono', monospace; font-size: 13px; letter-spacing: 0.4em; color: var(--accent); text-transform: uppercase; margin-bottom: 24px; animation: fade-up 1s ease 0.1s both; }
  .hero-eyebrow::before { content: '‚óà '; }
  .hero-eyebrow::after { content: ' ‚óà'; }
  .hero-title { font-family: 'Syne', sans-serif; font-weight: 800; font-size: clamp(72px, 15vw, 160px); letter-spacing: -0.02em; line-height: 0.9; color: var(--white); margin-bottom: 8px; animation: fade-up 1s ease 0.2s both; position: relative; }
  .hero-title::after { content: 'GHOST'; position: absolute; inset: 0; color: transparent; -webkit-text-stroke: 1px rgba(102,51,255,0.3); transform: translate(3px, 3px); z-index: -1; }
  .hero-ticker { font-family: 'Share Tech Mono', monospace; font-size: 18px; letter-spacing: 0.3em; color: var(--accent); margin-bottom: 32px; animation: fade-up 1s ease 0.25s both; }
  .hero-sub { font-size: clamp(18px, 2.5vw, 24px); font-weight: 400; color: var(--text); max-width: 540px; margin: 0 auto 48px; animation: fade-up 1s ease 0.3s both; line-height: 1.5; }
  .hero-actions { display: flex; gap: 16px; justify-content: center; flex-wrap: wrap; animation: fade-up 1s ease 0.4s both; margin-bottom: 64px; position: relative; z-index: 10; }
  .btn-pump { font-family: 'Share Tech Mono', monospace; font-size: 14px; letter-spacing: 0.2em; text-transform: uppercase; padding: 16px 36px; background: var(--accent); color: var(--white); text-decoration: none; transition: all 0.3s; display: flex; align-items: center; gap: 10px; }
  .btn-pump:hover { background: var(--glow); box-shadow: 0 0 40px rgba(136,85,255,0.5); }
  .btn-pump .pump-icon { font-size: 16px; }
  .btn-secondary { font-family: 'Share Tech Mono', monospace; font-size: 14px; letter-spacing: 0.2em; text-transform: uppercase; padding: 16px 36px; border: 1px solid var(--muted); color: var(--muted); text-decoration: none; transition: all 0.3s; cursor: pointer; background: transparent; }
  .btn-secondary:hover { border-color: var(--text); color: var(--text); }
  .btn-dex { font-family: 'Share Tech Mono', monospace; font-size: 14px; letter-spacing: 0.2em; text-transform: uppercase; padding: 16px 36px; border: 1px solid rgba(153,69,255,0.4); color: var(--sol); text-decoration: none; transition: all 0.3s; }
  .btn-dex:hover { border-color: var(--sol); box-shadow: 0 0 20px rgba(153,69,255,0.2); }
  .heartbeat-bar { width: 100%; max-width: 700px; margin: 0 auto; animation: fade-up 1s ease 0.5s both; }
  .hb-label { font-family: 'Share Tech Mono', monospace; font-size: 12px; letter-spacing: 0.3em; color: var(--muted); text-transform: uppercase; display: flex; justify-content: space-between; margin-bottom: 12px; }
  .hb-label span:last-child { color: var(--pulse); animation: blink 1s ease-in-out infinite; }
  @keyframes blink { 0%, 100% { opacity: 1; } 50% { opacity: 0.3; } }
  .hb-line { height: 60px; position: relative; overflow: hidden; }
  .hb-svg { width: 200%; height: 100%; animation: hb-scroll 3s linear infinite; }
  @keyframes hb-scroll { from { transform: translateX(0); } to { transform: translateX(-50%); } }

  /* ‚îÄ‚îÄ‚îÄ STATS / TICKER ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
  .stats-wrap { max-width: 900px; margin: 0 auto; }
  .stats { display: flex; justify-content: center; border-top: 1px solid rgba(102,51,255,0.15); border-bottom: 1px solid rgba(102,51,255,0.15); }
  .stat { flex: 1; padding: 36px 28px; text-align: center; border-right: 1px solid rgba(102,51,255,0.1); }
  .stat:last-child { border-right: none; }
  .stat-value { font-family: 'Syne', sans-serif; font-weight: 700; font-size: 28px; color: var(--white); display: block; margin-bottom: 6px; }
  .stat-label { font-family: 'Share Tech Mono', monospace; font-size: 12px; letter-spacing: 0.25em; color: var(--muted); text-transform: uppercase; }
  .price-ticker { background: rgba(153,69,255,0.05); border: 1px solid rgba(153,69,255,0.15); padding: 16px 32px; display: flex; gap: 40px; justify-content: center; align-items: center; font-family: 'Share Tech Mono', monospace; font-size: 12px; max-width: 900px; margin: 0 auto; }
  .ticker-item { display: flex; flex-direction: column; align-items: center; gap: 4px; }
  .ticker-label { font-size: 12px; letter-spacing: 0.25em; color: var(--muted); text-transform: uppercase; }
  .ticker-value { color: var(--white); font-size: 14px; }
  .ticker-value.up { color: #33ff99; }
  .ticker-value.down { color: #ff3d5a; }

  /* ‚îÄ‚îÄ‚îÄ SECTIONS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
  section { padding: 100px 48px; max-width: 1200px; margin: 0 auto; }
  .section-tag { font-family: 'Share Tech Mono', monospace; font-size: 13px; letter-spacing: 0.4em; color: var(--accent); text-transform: uppercase; margin-bottom: 24px; display: block; }
  .section-title { font-family: 'Syne', sans-serif; font-weight: 700; font-size: clamp(36px, 5vw, 60px); color: var(--white); line-height: 1.1; margin-bottom: 24px; }
  .section-body { font-size: 18px; color: var(--text); max-width: 560px; line-height: 1.8; }
  .how-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 72px; align-items: start; margin-top: 72px; }
  .how-steps { display: flex; flex-direction: column; gap: 0; }
  .step { display: flex; gap: 20px; padding: 28px 0; border-bottom: 1px solid rgba(102,51,255,0.1); }
  .step:last-child { border-bottom: none; }
  .step-num { font-family: 'Share Tech Mono', monospace; font-size: 13px; letter-spacing: 0.2em; color: var(--accent); min-width: 40px; padding-top: 4px; }
  .step-content h3 { font-family: 'Syne', sans-serif; font-weight: 700; font-size: 18px; color: var(--white); margin-bottom: 8px; }
  .step-content p { font-size: 16px; color: var(--text); line-height: 1.7; }
  .terminal { background: rgba(7,7,15,0.9); border: 1px solid rgba(102,51,255,0.2); font-family: 'Share Tech Mono', monospace; font-size: 13px; line-height: 1.85; box-shadow: 0 0 60px rgba(102,51,255,0.08), inset 0 0 40px rgba(0,0,0,0.5); }
  .terminal-bar { background: rgba(102,51,255,0.1); border-bottom: 1px solid rgba(102,51,255,0.2); padding: 12px 16px; display: flex; align-items: center; gap: 8px; }
  .terminal-dot { width: 10px; height: 10px; border-radius: 50%; }
  .terminal-dot.red { background: #ff3366; } .terminal-dot.yellow { background: #ffaa00; opacity: 0.5; } .terminal-dot.green { background: #33ff99; opacity: 0.5; }
  .terminal-title { font-size: 12px; letter-spacing: 0.2em; color: var(--muted); margin-left: 8px; text-transform: uppercase; }
  .terminal-body { padding: 20px 24px; }
  .t-comment { color: #666688; } .t-keyword { color: #9966ff; } .t-string { color: #33ccaa; } .t-number { color: #ff9966; } .t-func { color: #99aaff; } .t-var { color: var(--text); } .t-pulse { color: var(--pulse); } .t-line { display: block; padding: 1px 0; }
  .cursor { display: inline-block; width: 8px; height: 13px; background: var(--accent); vertical-align: middle; animation: cursor-blink 1s step-end infinite; }
  @keyframes cursor-blink { 0%, 100% { opacity: 1; } 50% { opacity: 0; } }
  .token-section { background: linear-gradient(to bottom, transparent, rgba(7,7,15,0.5), transparent); border-top: 1px solid rgba(102,51,255,0.1); border-bottom: 1px solid rgba(102,51,255,0.1); }
  .token-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 1px; background: rgba(102,51,255,0.1); margin-top: 56px; border: 1px solid rgba(102,51,255,0.1); }
  .token-card { background: var(--black); padding: 40px 28px; transition: background 0.3s; position: relative; overflow: hidden; }
  .token-card:hover { background: rgba(7,7,15,0.8); }
  .token-card::before { content: ''; position: absolute; top: 0; left: 0; right: 0; height: 1px; background: linear-gradient(to right, transparent, var(--accent), transparent); opacity: 0; transition: opacity 0.3s; }
  .token-card:hover::before { opacity: 1; }
  .token-percent { font-family: 'Syne', sans-serif; font-weight: 800; font-size: 56px; color: var(--white); line-height: 1; margin-bottom: 8px; display: block; }
  .token-percent span { color: var(--accent); font-size: 28px; }
  .token-name { font-family: 'Share Tech Mono', monospace; font-size: 13px; letter-spacing: 0.3em; color: var(--accent); text-transform: uppercase; margin-bottom: 12px; display: block; }
  .token-desc { font-size: 15px; color: var(--text); line-height: 1.7; }
  .manifesto { text-align: center; padding: 140px 48px; position: relative; overflow: hidden; }
  .manifesto-bg { position: absolute; inset: 0; background: radial-gradient(ellipse 50% 70% at 50% 50%, rgba(102,51,255,0.06) 0%, transparent 70%); pointer-events: none; }
  .manifesto blockquote { font-family: 'Cormorant Garamond', serif; font-size: clamp(26px, 3.5vw, 48px); font-style: italic; font-weight: 400; color: var(--white); line-height: 1.4; max-width: 840px; margin: 0 auto 40px; position: relative; }
  .manifesto blockquote::before { content: '"'; font-size: 180px; color: rgba(102,51,255,0.07); position: absolute; top: -60px; left: -40px; line-height: 1; }
  .manifesto-attr { font-family: 'Share Tech Mono', monospace; font-size: 14px; letter-spacing: 0.4em; color: var(--accent); text-transform: uppercase; }
  .roadmap-grid { margin-top: 56px; display: grid; grid-template-columns: 1fr 1fr; gap: 20px; }
  .road-card { background: rgba(7,7,15,0.6); border: 1px solid rgba(119,68,255,0.15); padding: 36px 32px; transition: border-color 0.3s; }
  .road-card:hover { border-color: rgba(119,68,255,0.4); }
  .road-badge { display: inline-block; font-family: 'Share Tech Mono', monospace; font-size: 12px; letter-spacing: 0.2em; text-transform: uppercase; padding: 5px 14px; border: 1px solid rgba(119,68,255,0.3); color: var(--muted); margin-bottom: 16px; }
  .road-card h3 { font-family: 'Syne', sans-serif; font-weight: 700; font-size: 22px; color: var(--white); margin-bottom: 6px; }
  .road-card .road-when { font-family: 'Share Tech Mono', monospace; font-size: 13px; color: var(--accent); margin-bottom: 16px; display: block; }
  .road-card ul { list-style: none; display: flex; flex-direction: column; gap: 10px; }
  .road-card li { font-family: 'Syne', sans-serif; font-size: 15px; color: var(--text); display: flex; gap: 10px; align-items: baseline; line-height: 1.5; }
  .road-card li::before { content: '‚Üí'; color: var(--accent); font-weight: 700; flex-shrink: 0; }
  .actions-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 40px; margin-top: 56px; }
  .action-col h3 { font-family: 'Share Tech Mono', monospace; font-size: 13px; letter-spacing: 0.3em; color: var(--accent); text-transform: uppercase; margin-bottom: 20px; padding-bottom: 12px; border-bottom: 1px solid rgba(119,68,255,0.2); }
  .action-item { display: flex; gap: 14px; align-items: baseline; padding: 10px 0; }
  .action-icon { font-size: 18px; flex-shrink: 0; }
  .action-text { font-size: 16px; color: var(--text); line-height: 1.6; }
  .action-text span { color: var(--muted); font-size: 14px; }
  .faq-list { margin-top: 56px; max-width: 800px; }
  .faq-item { border-bottom: 1px solid rgba(119,68,255,0.12); }
  .faq-q { font-family: 'Syne', sans-serif; font-weight: 700; font-size: 18px; color: var(--white); padding: 24px 0; cursor: pointer; display: flex; justify-content: space-between; align-items: center; transition: color 0.3s; }
  .faq-q:hover { color: var(--accent); }
  .faq-q::after { content: '+'; font-family: 'Share Tech Mono', monospace; font-size: 22px; color: var(--accent); transition: transform 0.3s; }
  .faq-item.open .faq-q::after { content: '‚àí'; }
  .faq-a { max-height: 0; overflow: hidden; transition: max-height 0.4s ease, padding 0.4s ease; }
  .faq-item.open .faq-a { max-height: 300px; padding-bottom: 24px; }
  .faq-a p { font-size: 16px; color: var(--text); line-height: 1.7; }
  .cta-section { text-align: center; padding: 140px 48px; border-top: 1px solid rgba(102,51,255,0.1); position: relative; overflow: hidden; isolation: isolate; }
  .cta-section::before { content: ''; position: absolute; inset: 0; background: radial-gradient(ellipse 60% 80% at 50% 100%, rgba(102,51,255,0.08) 0%, transparent 70%); pointer-events: none; }
  .cta-title { font-family: 'Syne', sans-serif; font-weight: 800; font-size: clamp(48px, 8vw, 96px); color: var(--white); line-height: 1; margin-bottom: 28px; position: relative; }
  .cta-sub { font-size: 20px; color: var(--text); max-width: 440px; margin: 0 auto 48px; }
  footer { border-top: 1px solid rgba(102,51,255,0.1); padding: 36px 48px; display: flex; justify-content: space-between; align-items: center; }
  .footer-logo { font-family: 'Syne', sans-serif; font-weight: 800; letter-spacing: 0.3em; color: var(--muted); font-size: 14px; }
  .footer-mono { font-family: 'Share Tech Mono', monospace; font-size: 12px; letter-spacing: 0.2em; color: #555570; text-transform: uppercase; }
  @keyframes fade-up { from { opacity: 0; transform: translateY(24px); } to { opacity: 1; transform: translateY(0); } }
  .reveal { opacity: 0; transform: translateY(32px); transition: opacity 0.8s ease, transform 0.8s ease; }
  .reveal.visible { opacity: 1; transform: translateY(0); }
  .ghost-watermark { position: fixed; bottom: -80px; right: -80px; font-family: 'Syne', sans-serif; font-weight: 800; font-size: 300px; color: rgba(102,51,255,0.02); letter-spacing: -0.05em; pointer-events: none; z-index: 0; user-select: none; }
  .notif { position: fixed; bottom: 32px; left: 50%; transform: translateX(-50%) translateY(30px); background: #0d0d1a; border: 1px solid rgba(102,51,255,0.3); color: var(--white); font-family: 'Share Tech Mono', monospace; font-size: 14px; letter-spacing: 0.08em; padding: 16px 32px; z-index: 99999; opacity: 0; transition: all 0.35s cubic-bezier(0.34,1.56,0.64,1); pointer-events: none; white-space: nowrap; box-shadow: 0 8px 32px rgba(0,0,0,0.4); }
  .notif.show { transform: translateX(-50%) translateY(0); opacity: 1; }
  .notif.green { border-color: #33ff99; color: #33ff99; background: rgba(51,255,153,0.07); box-shadow: 0 8px 32px rgba(51,255,153,0.15); }
  .notif.error { border-color: #ff3d5a; color: #ff3d5a; background: rgba(255,61,90,0.07); }
  .notif.info { border-color: #7744ff; color: #9966ff; }

  /* ‚îÄ‚îÄ‚îÄ WALLET MODAL ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
  .modal-overlay { display: none; position: fixed; inset: 0; background: rgba(0,0,0,0.85); z-index: 500; justify-content: center; align-items: center; backdrop-filter: blur(4px); }
  .modal-overlay.open { display: flex; }
  #ghostConfirmModal { z-index: 99998 !important; }
  .modal { background: var(--deep); border: 1px solid rgba(102,51,255,0.3); padding: 48px; max-width: 420px; width: 90%; position: relative; }
  .modal-close { position: absolute; top: 16px; right: 20px; background: none; border: none; color: var(--muted); font-size: 20px; cursor: pointer; font-family: 'Share Tech Mono', monospace; }
  .modal-close:hover { color: var(--white); }
  .modal h3 { font-family: 'Syne', sans-serif; font-weight: 700; font-size: 24px; color: var(--white); margin-bottom: 8px; }
  .modal p { font-size: 14px; color: var(--text); margin-bottom: 32px; }
  .wallet-option { display: flex; align-items: center; gap: 16px; padding: 16px 20px; border: 1px solid rgba(102,51,255,0.15); margin-bottom: 12px; cursor: pointer; transition: all 0.2s; background: rgba(102,51,255,0.03); }
  .wallet-option:hover { border-color: var(--accent); background: rgba(102,51,255,0.08); }
  .wallet-option .w-icon { font-size: 24px; }
  .wallet-option .w-name { font-family: 'Share Tech Mono', monospace; font-size: 13px; letter-spacing: 0.15em; color: var(--white); }
  .wallet-option .w-desc { font-family: 'Share Tech Mono', monospace; font-size: 12px; color: var(--muted); margin-top: 2px; }

  /* ‚îÄ‚îÄ‚îÄ DASHBOARD PANEL ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
  /* Uses display:none/flex instead of transform to avoid fixed-position bugs */
  .dashboard-panel {
    position: fixed;
    top: 0; left: 0;
    width: 100vw; height: 100vh;
    z-index: 9999;
    background: #030305;
    flex-direction: column;
    overflow: hidden;
    display: flex;
    /* Off-screen when closed ‚Äî GPU composited, never discarded, no paint on return */
    transform: translateX(100vw);
    will-change: transform;
    transition: transform 0.18s cubic-bezier(0.4,0,0.2,1);
    pointer-events: none;
  }
  .dashboard-panel.open {
    transform: translateX(0);
    pointer-events: auto;
  }

  /* Panel topbar */
  .panel-topbar {
    flex-shrink: 0;
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 0 24px;
    height: 60px;
    background: rgba(3,3,5,0.98);
    border-bottom: 1px solid rgba(102,51,255,0.12);
  }

  .panel-back {
    font-family: 'Share Tech Mono', monospace;
    font-size: 13px;
    letter-spacing: 0.15em;
    color: #9090a8;
    background: none;
    border: 1px solid rgba(102,51,255,0.12);
    padding: 9px 18px;
    cursor: pointer;
    text-transform: uppercase;
    transition: all 0.2s;
    display: flex; align-items: center; gap: 8px;
  }
  .panel-back:hover { border-color: #7744ff; color: #9966ff; }

  .panel-logo {
    font-family: 'Syne', sans-serif; font-weight: 800;
    font-size: 18px; letter-spacing: 0.2em; color: #f0f0f8;
  }
  .panel-logo span { color: #7744ff; }

  .panel-wallet {
    font-family: 'Share Tech Mono', monospace;
    font-size: 13px; letter-spacing: 0.08em; color: #33ff99;
    display: flex; align-items: center; gap: 8px;
  }
  .panel-wallet-dot {
    width: 6px; height: 6px; border-radius: 50%;
    background: #33ff99;
    animation: pulse-dot 2s ease-in-out infinite;
  }

  /* Panel body = sidebar + main */
  .panel-body {
    flex: 1;
    min-height: 0;
    display: flex;
    overflow: hidden;
  }

  /* Sidebar */
  .panel-sidebar {
    width: 230px;
    flex-shrink: 0;
    background: #05050d;
    border-right: 1px solid rgba(102,51,255,0.15);
    padding: 20px 0;
    display: flex;
    flex-direction: column;
    overflow-y: auto;
  }

  .sidebar-section-label {
    font-family: 'Share Tech Mono', monospace;
    font-size: 11px; letter-spacing: 0.2em;
    color: rgba(150,100,255,0.7);
    text-transform: uppercase;
    padding: 14px 18px 6px;
  }

  .db-nav-item {
    display: flex; align-items: center; gap: 10px;
    padding: 11px 18px;
    font-family: 'Share Tech Mono', monospace;
    font-size: 13px; letter-spacing: 0.03em;
    color: #b0b0c8;
    cursor: pointer;
    transition: all 0.2s;
    border-left: 2px solid transparent;
    user-select: none;
  }
  .db-nav-item:hover { color: #f0f0f8; background: rgba(102,51,255,0.07); }
  .db-nav-item.active { color: #c0a0ff; background: rgba(102,51,255,0.1); border-left-color: #7744ff; }
  .db-nav-icon { font-size: 16px; width: 20px; text-align: center; }

  .sidebar-footer-info {
    margin-top: auto;
    padding: 18px;
    border-top: 1px solid rgba(102,51,255,0.15);
    font-family: 'Share Tech Mono', monospace;
    font-size: 12px; color: #9090a8; line-height: 2.2;
    letter-spacing: 0.05em;
  }
  .sidebar-footer-info .sv { color: #a080ff; font-size: 15px; display: block; }

  /* Dashboard main content */
  .panel-main {
    flex: 1;
    min-width: 0;
    overflow-y: auto;
    overflow-x: hidden;
    padding: 30px;
  }

  .db-page { display: none; }
  .db-page.active { display: block; }

  /* Status hero */
  .status-hero {
    background: #0d0d1e;
    border: 1px solid rgba(102,51,255,0.15);
    padding: 28px; margin-bottom: 20px;
    display: flex; flex-wrap: wrap;
    gap: 20px; align-items: center;
    justify-content: space-between;
    position: relative; overflow: hidden;
  }
  .status-hero::before {
    content: ''; position: absolute;
    top: -40px; right: -40px;
    width: 200px; height: 200px; border-radius: 50%;
    background: radial-gradient(circle, rgba(102,51,255,0.06) 0%, transparent 70%);
    pointer-events: none;
  }

  .status-eyebrow {
    font-family: 'Share Tech Mono', monospace;
    font-size: 12px; letter-spacing: 0.2em;
    color: #b0b0c8; text-transform: uppercase;
    margin-bottom: 8px;
    display: flex; align-items: center; gap: 6px;
  }
  .status-eyebrow::before { content: '‚óà'; color: #7744ff; font-size: 7px; }

  .status-value {
    font-family: 'Cormorant Garamond', serif;
    font-size: 56px; font-weight: 300; line-height: 1;
    color: #f0f0f8; margin-bottom: 14px; letter-spacing: -0.01em;
  }
  .status-value.alive { color: #33ff99; }
  .status-value.awakened { color: #ffb830; }

  .status-meta { display: flex; gap: 24px; flex-wrap: wrap; }
  .status-meta-item label {
    font-family: 'Share Tech Mono', monospace;
    font-size: 11px; letter-spacing: 0.15em;
    color: #9090b8; text-transform: uppercase; display: block; margin-bottom: 2px;
  }
  .status-meta-item span {
    font-family: 'Share Tech Mono', monospace; font-size: 14px; color: #e8e8f8;
  }

  /* Heartbeat orb */
  .hb-orb-wrap { position: relative; width: 100px; height: 100px; flex-shrink: 0; }
  .hb-orb-ring {
    position: absolute; inset: 0; border-radius: 50%;
    border: 1px solid rgba(102,51,255,0.2);
    animation: hb-ring-expand 3s ease-in-out infinite;
  }
  .hb-orb-ring:nth-child(2) { animation-delay: 1s; opacity: 0.5; }
  @keyframes hb-ring-expand {
    0%{transform:scale(0.7);opacity:0.6} 100%{transform:scale(1.5);opacity:0}
  }
  .hb-orb-center {
    position: absolute; top:50%; left:50%;
    transform: translate(-50%,-50%);
    width: 52px; height: 52px; border-radius: 50%;
    background: radial-gradient(circle, rgba(102,51,255,0.3) 0%, rgba(102,51,255,0.05) 100%);
    border: 1px solid rgba(102,51,255,0.4);
    display: flex; align-items: center; justify-content: center;
    font-size: 20px; cursor: pointer; transition: all 0.25s;
  }
  .hb-orb-center:hover { box-shadow: 0 0 24px rgba(102,51,255,0.4); }
  .hb-orb-center.beat { animation: orb-beat 0.5s ease-in-out; }
  @keyframes orb-beat {
    0%{transform:translate(-50%,-50%) scale(1)}
    40%{transform:translate(-50%,-50%) scale(1.25)}
    100%{transform:translate(-50%,-50%) scale(1)}
  }

  .hb-orb-label {
    font-family: 'Share Tech Mono', monospace; font-size: 12px;
    color: #b0b0c8; text-align: center; margin-top: 8px; letter-spacing: 0.05em;
  }
  .hb-orb-label strong { display: block; font-size: 17px; color: #f0f0f8; margin-bottom: 2px; }

  /* Stats cards */
  .db-cards {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(160px, 1fr));
    gap: 12px; margin-bottom: 20px;
  }
  .db-card {
    background: #0d0d1e; border: 1px solid rgba(102,51,255,0.15);
    padding: 20px 18px; transition: border-color 0.2s;
  }
  .db-card:hover { border-color: rgba(102,51,255,0.35); }
  .db-card-label { font-family: 'Share Tech Mono', monospace; font-size: 12px; letter-spacing: 0.15em; color: #b0b0c8; text-transform: uppercase; margin-bottom: 8px; }
  .db-card-value { font-family: 'Syne', sans-serif; font-weight: 700; font-size: 28px; color: #f0f0f8; line-height: 1; }
  .db-card-sub { font-family: 'Share Tech Mono', monospace; font-size: 12px; color: #8888aa; margin-top: 4px; }

  /* Progress bar */
  .db-progress { background: #0d0d1e; border: 1px solid rgba(102,51,255,0.15); padding: 18px; margin-bottom: 20px; }
  .db-progress-header { display: flex; justify-content: space-between; margin-bottom: 12px; }
  .db-progress-label { font-family: 'Share Tech Mono', monospace; font-size: 12px; letter-spacing: 0.15em; color: #b0b0c8; text-transform: uppercase; }
  .db-progress-val { font-family: 'Share Tech Mono', monospace; font-size: 13px; color: #d0d0e8; }
  .db-progress-bar { height: 4px; background: rgba(102,51,255,0.12); border-radius: 2px; }
  .db-progress-fill { height: 100%; background: linear-gradient(90deg, #4422cc, #9966ff); transition: width 0.5s; border-radius: 2px; }
  .db-progress-fill.warn { background: linear-gradient(90deg, #ff3d5a, #ff3366); }

  /* Alert */
  .db-alert { padding: 16px 20px; border-left: 3px solid #ffb830; background: rgba(255,184,48,0.06); font-family: 'Share Tech Mono', monospace; font-size: 14px; color: #ffcc55; line-height: 1.7; margin-bottom: 20px; display: none; }
  .db-alert.visible { display: block; }

  /* Section headers */
  .db-section-header { display: flex; align-items: center; justify-content: space-between; margin-bottom: 14px; }
  .db-section-title { font-family: 'Share Tech Mono', monospace; font-size: 13px; letter-spacing: 0.2em; color: #b0b0c8; text-transform: uppercase; display: flex; align-items: center; gap: 8px; }
  .db-section-title::before { content: ''; width: 12px; height: 1px; background: #7744ff; }

  /* Table */
  .db-table { width: 100%; border-collapse: collapse; }
  .db-table th { font-family: 'Share Tech Mono', monospace; font-size: 12px; letter-spacing: 0.15em; color: #8888bb; text-transform: uppercase; text-align: left; padding: 10px 14px; border-bottom: 1px solid rgba(102,51,255,0.15); }
  .db-table td { padding: 14px 14px; border-bottom: 1px solid rgba(102,51,255,0.06); font-family: 'Share Tech Mono', monospace; font-size: 13px; color: #d0d0e8; }
  .db-table tr:hover td { background: rgba(102,51,255,0.04); }
  .db-table tr:last-child td { border-bottom: none; }
  .addr-short { color: #8888aa; }

  /* Tags */
  .tag { display: inline-block; font-family: 'Share Tech Mono', monospace; font-size: 11px; letter-spacing: 0.1em; text-transform: uppercase; padding: 3px 8px; border: 1px solid currentColor; }
  .tag-transfer { color: #9966ff; }
  .tag-burn { color: #ff3366; }
  .tag-pending { color: #9090a8; }
  .tag-ready { color: #33ff99; border-color: rgba(51,255,153,0.4); }
  .tag-done { color: #33ff99; }

  /* Forms */
  .db-form { background: #0d0d1e; border: 1px solid rgba(102,51,255,0.15); padding: 24px; margin-bottom: 16px; }
  .db-form-title { font-family: 'Syne', sans-serif; font-size: 15px; font-weight: 700; letter-spacing: 0.05em; color: #c0a0ff; margin-bottom: 16px; padding-bottom: 12px; border-bottom: 1px solid rgba(102,51,255,0.12); }
  .db-form-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 14px; margin-bottom: 16px; }
  .db-form-group { display: flex; flex-direction: column; gap: 6px; }
  .db-form-group label { font-family: 'Share Tech Mono', monospace; font-size: 12px; letter-spacing: 0.15em; color: #b0b0c8; text-transform: uppercase; }
  .db-form-group input, .db-form-group select { background: #07070f; border: 1px solid rgba(102,51,255,0.2); color: #e8e8f4; font-family: 'Share Tech Mono', monospace; font-size: 14px; padding: 12px 14px; outline: none; transition: border-color 0.2s; -webkit-appearance: none; width: 100%; }
  .db-form-group input:focus, .db-form-group select:focus { border-color: #7744ff; }
  .db-form-group input::placeholder { color: rgba(120,80,255,0.35); }
  .db-form-group select option { background: #07070f; }

  /* Buttons */
  .db-btn { font-family: 'Share Tech Mono', monospace; font-size: 13px; letter-spacing: 0.15em; text-transform: uppercase; padding: 12px 24px; border: none; cursor: pointer; transition: all 0.2s; display: inline-flex; align-items: center; gap: 8px; }
  .db-btn-primary { background: #7744ff; color: #f0f0f8; }
  .db-btn-primary:hover { background: #9966ff; box-shadow: 0 0 20px rgba(102,51,255,0.35); }
  .db-btn-outline { background: transparent; border: 1px solid rgba(102,51,255,0.2); color: #d0d0e8; }
  .db-btn-outline:hover { border-color: rgba(102,51,255,0.5); color: #b090ff; }
  .db-btn-danger { background: transparent; border: 1px solid rgba(255,61,90,0.3); color: #ff6080; }
  .db-btn-danger:hover { background: rgba(255,61,90,0.08); border-color: #ff3d5a; }
  .db-btn-green { background: #33ff99; color: #030305; font-weight: 700; }
  .db-btn-green:hover { box-shadow: 0 0 20px rgba(51,255,153,0.3); }

  .icon-btn { background: none; border: 1px solid rgba(102,51,255,0.15); color: #9090a8; font-size: 12px; padding: 4px 8px; cursor: pointer; transition: all 0.2s; }
  .icon-btn:hover { border-color: #ff3d5a; color: #ff3d5a; }

  /* Watcher result */
  .watcher-result { display: none; margin-top: 14px; padding: 18px; background: #07070f; border: 1px solid rgba(102,51,255,0.15); font-family: 'Share Tech Mono', monospace; font-size: 14px; line-height: 2; color: #c0c0d8; }
  .watcher-result.visible { display: block; }

  /* Info box */
  .db-info { padding: 14px 18px; border-left: 3px solid rgba(102,51,255,0.6); background: rgba(102,51,255,0.06); font-family: 'Share Tech Mono', monospace; font-size: 13px; color: #c0c0d8; line-height: 1.8; margin-bottom: 16px; }
  .db-info strong { color: #e8e8f8; }

  /* Ping ripple */
  .ping-ripple { position: fixed; inset: 0; pointer-events: none; z-index: 10000; display: none; align-items: center; justify-content: center; }
  .ping-ripple.active { display: flex; }
  .ping-ripple-ring { position: absolute; width: 80px; height: 80px; border-radius: 50%; border: 2px solid #7744ff; animation: ripple-out 1s ease-out forwards; }
  .ping-ripple-ring:nth-child(2) { animation-delay: 0.12s; }
  .ping-ripple-ring:nth-child(3) { animation-delay: 0.24s; }
  @keyframes ripple-out { from{transform:scale(0.5);opacity:0.8} to{transform:scale(10);opacity:0} }
  @keyframes ghost-fly-up {
    0%   { transform: translateY(0) scale(1);   opacity: 1; filter: drop-shadow(0 0 20px rgba(102,51,255,0.8)); }
    20%  { transform: translateY(-30px) scale(1.05); opacity: 1; filter: drop-shadow(0 0 40px rgba(102,51,255,1)); }
    50%  { transform: translateY(-120px) scale(0.9); opacity: 0.8; filter: drop-shadow(0 0 60px rgba(200,100,255,0.9)); }
    80%  { transform: translateY(-280px) scale(0.5); opacity: 0.4; filter: drop-shadow(0 0 80px rgba(255,255,255,0.5)); }
    100% { transform: translateY(-500px) scale(0.1); opacity: 0; filter: drop-shadow(0 0 0px transparent); }
  }
  @keyframes ghost-wobble {
    0%,100% { transform: translateX(0) rotate(0deg); }
    20%  { transform: translateX(-8px) rotate(-5deg); }
    40%  { transform: translateX(8px) rotate(5deg); }
    60%  { transform: translateX(-5px) rotate(-3deg); }
    80%  { transform: translateX(5px) rotate(3deg); }
  }
  @keyframes burn-flash {
    0%   { background: rgba(255,80,40,0); }
    15%  { background: rgba(255,80,40,0.3); }
    30%  { background: rgba(255,120,0,0.15); }
    50%  { background: rgba(200,0,200,0.2); }
    70%  { background: rgba(100,0,255,0.15); }
    100% { background: rgba(102,51,255,0); }
  }
  @keyframes particle-burst {
    0%   { transform: translate(0,0) scale(1); opacity: 1; }
    100% { transform: var(--tx, 80px) var(--ty, -120px) scale(0); opacity: 0; }
  }
  @keyframes aftermath-fade-in {
    from { opacity: 0; transform: translateY(20px); }
    to   { opacity: 1; transform: translateY(0); }
  }
  .ghost-abandon-overlay {
    position: fixed; inset: 0; z-index: 100001; display: flex; align-items: center; justify-content: center;
    background: rgba(5,5,15,0.85); backdrop-filter: blur(8px);
    animation: burn-flash 1.2s ease-out;
  }
  .ghost-fly-char {
    font-size: 80px; line-height: 1; display: block;
    animation: ghost-wobble 0.4s ease-in-out 0.1s 2, ghost-fly-up 1.6s ease-in 0.8s forwards;
    filter: drop-shadow(0 0 20px rgba(102,51,255,0.8));
    transform-origin: center bottom;
  }
  .particle {
    position: absolute; width: 8px; height: 8px; border-radius: 50%;
    animation: particle-burst 1.2s ease-out forwards;
  }


  /* Custom token picker */
  .token-picker { position: relative; }
  .token-picker-btn {
    width: 100%; background: #07070f; border: 1px solid rgba(102,51,255,0.2);
    color: #e0e0ec; font-family: 'Share Tech Mono', monospace; font-size: 13px;
    padding: 11px 14px; cursor: pointer; text-align: left; display: flex;
    align-items: center; gap: 10px; justify-content: space-between; transition: border-color 0.2s;
  }
  .token-picker-btn:hover, .token-picker-btn.open { border-color: #7744ff; }
  .token-picker-btn .tp-left { display: flex; align-items: center; gap: 10px; }
  .token-picker-btn .tp-symbol { font-size: 14px; font-weight: 700; color: #f0f0f8; }
  .token-picker-btn .tp-bal { font-size: 11px; color: var(--muted); }
  .token-picker-btn .tp-arrow { color: var(--muted); font-size: 10px; transition: transform 0.2s; }
  .token-picker-btn.open .tp-arrow { transform: rotate(180deg); }
  .token-picker-dropdown {
    position: absolute; top: calc(100% + 4px); left: 0; right: 0;
    background: #07070f; border: 1px solid rgba(102,51,255,0.2); z-index: 200;
    max-height: 220px; overflow-y: auto;
    opacity: 0; pointer-events: none; transform: translateY(-4px);
    transition: opacity 0.12s ease, transform 0.12s ease;
  }
  .token-picker-dropdown.open { opacity: 1; pointer-events: auto; transform: translateY(0); }
  .token-picker-option {
    display: flex; align-items: center; gap: 12px; padding: 11px 14px;
    cursor: pointer; border-bottom: 1px solid rgba(102,51,255,0.06);
    transition: background 0.15s; font-family: 'Share Tech Mono', monospace;
  }
  .token-picker-option:hover { background: rgba(102,51,255,0.08); }
  .token-picker-option:last-child { border-bottom: none; }
  .tp-opt-icon { width: 32px; height: 32px; border-radius: 50%; background: rgba(102,51,255,0.15); display: flex; align-items: center; justify-content: center; font-size: 14px; flex-shrink: 0; }
  .tp-opt-info { flex: 1; }
  .tp-opt-symbol { font-size: 13px; color: #f0f0f8; font-weight: 700; }
  .tp-opt-bal { font-size: 11px; color: var(--muted); margin-top: 1px; }
  .tp-opt-check { color: #33ff99; font-size: 14px; }

  /* Current settings display */
  .settings-current {
    display: flex; gap: 0; margin-bottom: 20px;
    border: 1px solid rgba(102,51,255,0.15); overflow: hidden;
  }
  .settings-current-item {
    flex: 1; padding: 20px;
    border-right: 1px solid rgba(102,51,255,0.12);
  }
  .settings-current-item:last-child { border-right: none; }
  .settings-current-label { font-family: 'Share Tech Mono', monospace; font-size: 11px; letter-spacing: 0.18em; color: #b0b0c8; text-transform: uppercase; margin-bottom: 8px; }
  .settings-current-value { font-family: 'Syne', sans-serif; font-weight: 700; font-size: 30px; color: #f0f0f8; line-height: 1; }
  .settings-current-sub { font-family: 'Share Tech Mono', monospace; font-size: 12px; color: #a080ff; margin-top: 5px; }

  /* Vault asset row */
  .vault-asset-row {
    display: flex; align-items: center; gap: 16px;
    padding: 16px 20px; border-bottom: 1px solid rgba(102,51,255,0.08);
    background: #0d0d1e;
  }
  .vault-asset-row:last-child { border-bottom: none; }
  .vault-asset-icon { width: 40px; height: 40px; border-radius: 50%; background: rgba(102,51,255,0.15); display: flex; align-items: center; justify-content: center; font-size: 18px; flex-shrink: 0; }
  .vault-asset-info { flex: 1; }
  .vault-asset-symbol { font-family: 'Syne', sans-serif; font-weight: 700; font-size: 16px; color: #f0f0f8; }
  .vault-asset-bal { font-family: 'Share Tech Mono', monospace; font-size: 13px; color: #b0b0c8; margin-top: 3px; }
  .vault-asset-actions { display: flex; align-items: center; gap: 8px; }
  .vault-asset-input { background: #07070f; border: 1px solid rgba(102,51,255,0.2); color: #e8e8f4; font-family: 'Share Tech Mono', monospace; font-size: 13px; padding: 8px 12px; width: 110px; outline: none; }
  .vault-asset-input:focus { border-color: #7744ff; }

  /* Burn option */
  .burn-section { background: rgba(255,61,90,0.03); border: 1px solid rgba(255,61,90,0.15); padding: 20px; margin-bottom: 16px; }
  .burn-section .db-form-title { color: var(--red); }

  /* Locked nav */
  .db-nav-locked { opacity: 0.3; pointer-events: none; }
  /* Init ghost page */
  .init-hero { text-align:center; padding:48px 24px 32px; background:radial-gradient(ellipse at 50% 0%,rgba(102,51,255,0.08) 0%,transparent 70%); border:1px solid rgba(102,51,255,0.15); margin-bottom:24px; }
  .init-ghost-icon { font-size:72px; line-height:1; margin-bottom:16px; filter:drop-shadow(0 0 24px rgba(102,51,255,0.4)); }
  .init-title { font-family:'Syne',sans-serif; font-weight:800; font-size:30px; color:#f0f0f8; margin-bottom:8px; }
  .init-sub { font-family:'Share Tech Mono',monospace; font-size:13px; color:#b0b0c8; line-height:1.8; }

  /* Page title */
  /* Page title */
  .db-page-title { font-family: 'Cormorant Garamond', serif; font-size: 32px; font-weight: 300; color: #f0f0f8; margin-bottom: 4px; }
  .db-page-sub { font-family: 'Share Tech Mono', monospace; font-size: 11px; letter-spacing: 0.18em; color: #9090b8; text-transform: uppercase; margin-bottom: 24px; }

    @media (max-width: 800px) {
    .panel-body { flex-direction: column; }
    .panel-sidebar { display: none !important; }
    .db-cards { grid-template-columns: 1fr 1fr; }
    .status-hero { grid-template-columns: 1fr; }
    .how-grid { grid-template-columns: 1fr; }
    .roadmap-grid { grid-template-columns: 1fr; }
    .actions-grid { grid-template-columns: 1fr; }
  }
</style>
<!-- Solana Web3.js - loaded async so it doesn't block page -->
<script>
  var solanaWeb3 = null;
  var web3Script = document.createElement('script');
  web3Script.src = 'https://cdn.jsdelivr.net/npm/@solana/web3.js@latest/lib/index.iife.min.js';
  web3Script.onload = function() {
    solanaWeb3 = window.solanaWeb3;
    console.log('Solana web3.js loaded:', !!solanaWeb3);
    // Retry token metadata fetch now that we have proper PDA derivation
    pumpFunFetched.clear();
    setTimeout(fetchPumpFunData, 500);
  };
  web3Script.onerror = function() {
    console.warn('Solana web3.js failed to load - demo mode only');
  };
  document.head.appendChild(web3Script);
</script>
</head>
<body>

<div class="ghost-watermark">G</div>
<div class="notif" id="notif"></div>

<!-- ‚îÄ‚îÄ‚îÄ WALLET MODAL ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ -->
<div class="modal-overlay" id="walletModal">
  <div class="modal">
    <button class="modal-close" onclick="closeModal()">‚úï</button>
    <h3>Connect Wallet</h3>
    <p>Choose your Solana wallet to register your heartbeat.</p>
    <div class="wallet-option" onclick="connectWallet('Phantom')">
      <span class="w-icon">üëª</span>
      <div><div class="w-name">Phantom</div><div class="w-desc">Most popular Solana wallet</div></div>
    </div>
    <div class="wallet-option" onclick="connectWallet('Solflare')">
      <span class="w-icon">üîÜ</span>
      <div><div class="w-name">Solflare</div><div class="w-desc">Built for Solana power users</div></div>
    </div>
    <div class="wallet-option" onclick="connectWallet('Backpack')">
      <span class="w-icon">üéí</span>
      <div><div class="w-name">Backpack</div><div class="w-desc">xNFT wallet by Coral</div></div>
    </div>
  </div>
</div>

<!-- ‚îÄ‚îÄ‚îÄ GHOST CONFIRM MODAL ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ -->
<!-- ‚îÄ‚îÄ‚îÄ DASHBOARD PANEL ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ -->
<div class="dashboard-panel" id="dashboardPanel">

  <div class="panel-topbar">
    <button class="panel-back" onclick="closeDashboard()">‚Üê Back to site</button>
    <div class="panel-logo">GH<span>O</span>ST <span style="font-family:'Share Tech Mono',monospace;font-size:11px;letter-spacing:0.15em;color:#c0bce0">‚Äî VAULT</span></div>
    <div class="panel-wallet" style="display:flex;align-items:center;gap:10px">
      <span class="panel-wallet-dot"></span>
      <span id="panelWalletAddr">4xKm...9nZq</span>
      <button onclick="disconnectWallet()" title="Disconnect wallet" style="font-family:'Share Tech Mono',monospace;font-size:11px;letter-spacing:0.08em;color:#ff6666;background:none;border:1px solid rgba(255,102,102,0.3);padding:4px 10px;cursor:pointer;transition:all 0.2s;white-space:nowrap" onmouseover="this.style.background='rgba(255,102,102,0.1)'" onmouseout="this.style.background='none'">‚èª Disconnect</button>
    </div>
  </div>

  <div class="panel-body">

    <!-- Sidebar -->
    <div class="panel-sidebar">
      <div class="sidebar-section-label">Vault</div>
      <div class="db-nav-item active" id="nav-overview" onclick="dbShowPage('overview', this)"><span class="db-nav-icon">üëª</span>Overview</div>
      <div class="db-nav-item db-nav-locked" id="nav-vault" onclick="dbShowPage('vault', this)"><span class="db-nav-icon">üîí</span>Vault Assets</div>
      <div class="db-nav-item db-nav-locked" id="nav-beneficiaries" onclick="dbShowPage('beneficiaries', this)"><span class="db-nav-icon">üìã</span>Beneficiaries</div>
      <div class="sidebar-section-label" style="margin-top:6px">Settings</div>
      <div class="db-nav-item db-nav-locked" id="nav-heartbeat" onclick="dbShowPage('heartbeat', this)"><span class="db-nav-icon">üíì</span>Heartbeat</div>
      <div class="db-nav-item db-nav-locked" id="nav-recovery" onclick="dbShowPage('recovery', this)"><span class="db-nav-icon">üîë</span>Recovery</div>
      <div class="db-nav-item db-nav-locked" id="nav-settings" onclick="dbShowPage('settings', this)"><span class="db-nav-icon">‚öôÔ∏è</span>Settings</div>
      <div class="sidebar-section-label" style="margin-top:6px">Protocol</div>
      <div class="db-nav-item" onclick="dbShowPage('watcher', this)"><span class="db-nav-icon">üíì</span>Heartbeat Checker</div>
      <div class="db-nav-item" onclick="closeDashboard()"><span class="db-nav-icon">üåê</span>Back to site</div>
      <div class="db-nav-item" onclick="disconnectWallet()" style="color:#ff6666;margin-top:2px"><span class="db-nav-icon">‚èª</span>Disconnect</div>
      <div class="sidebar-footer-info">
        STAKED<br><span class="sv" id="sidebarStake">‚Äî</span><br>
        PINGS<br><span class="sv" id="sidebarPings">‚Äî</span>
      </div>
    </div>

    <!-- Main content -->
    <main class="panel-main">

      <!-- OVERVIEW -->
      <div class="db-page active" id="db-page-overview">
        <div class="db-page-title">Your Ghost</div>
        <div class="db-page-sub">Vault Status ¬∑ Digital Legacy Protocol</div>

        <!-- Wallet identity -->
        <div style="display:flex;align-items:center;gap:14px;padding:14px 18px;background:rgba(102,51,255,0.06);border:1px solid rgba(102,51,255,0.14);margin-bottom:20px">
          <canvas id="dbWalletAvatar" width="40" height="40" style="border-radius:50%;flex-shrink:0"></canvas>
          <div style="min-width:0;flex:1">
            <div id="dbWalletDomain" style="font-family:'Syne',sans-serif;font-weight:700;font-size:14px;color:#f0f0f8;white-space:nowrap;overflow:hidden;text-overflow:ellipsis">‚Äî</div>
            <div id="dbWalletShortAddr" style="font-family:'Share Tech Mono',monospace;font-size:11px;color:#9090b8;letter-spacing:0.06em;margin-top:2px"></div>
          </div>
          <div id="dbSolBadge" style="display:none;background:rgba(153,69,255,0.15);border:1px solid rgba(153,69,255,0.3);color:#cc99ff;font-family:'Share Tech Mono',monospace;font-size:10px;letter-spacing:0.15em;padding:3px 8px;flex-shrink:0">.SOL</div>
        </div>

        <div class="db-alert" id="dbAwakeningAlert">
          ‚ö† GHOST AWAKENED ‚Äî Grace period expires in <strong id="dbGraceCountdown">6d 14h</strong>. Ping or cancel to save your ghost.
          <br><div style="display:flex;gap:8px;margin-top:8px">
          <button class="db-btn db-btn-green" onclick="sendPing()">üíì SEND HEARTBEAT</button>
          <button class="db-btn" style="border-color:#ff9966;color:#ff9966" onclick="cancelAwakening()">üõë CANCEL AWAKENING</button>
          </div>
        </div>

        <div class="status-hero">
          <div>
            <div class="status-eyebrow">Current Status</div>
            <div class="status-value alive" id="dbStatusValue">ALIVE</div>
            <div class="status-meta">
              <div class="status-meta-item"><label>Last Ping</label><span id="dbLastPing">‚Äî</span></div>
              <div class="status-meta-item"><label>Interval</label><span id="dbInterval">365 days</span></div>
              <div class="status-meta-item"><label>Grace</label><span id="dbGrace">30 days</span></div>
              <div class="status-meta-item"><label>Registered</label><span id="dbRegistered">‚Äî</span></div>
            </div>
          </div>
          <div style="display:flex;flex-direction:column;align-items:center;gap:10px">
            <div class="hb-orb-wrap" style="width:130px;height:130px">
              <div class="hb-orb-ring"></div>
              <div class="hb-orb-ring"></div>
              <div class="hb-orb-center" id="hbOrb" onclick="sendPing()" title="Click to ping" style="width:72px;height:72px;font-size:28px">üíì</div>
            </div>
            <div class="hb-orb-label"><strong id="dbCountdown">‚Äî</strong>until deadline</div>
          </div>
        </div>

        <div class="db-progress">
          <div class="db-progress-header">
            <span class="db-progress-label">Heartbeat Window</span>
            <span class="db-progress-val" id="dbProgressVal">‚Äî</span>
          </div>
          <div class="db-progress-bar">
            <div class="db-progress-fill" id="dbProgressFill" style="width:0%"></div>
          </div>
        </div>

        <!-- VAULT OVERVIEW ‚Äî shows all assets -->
        <div class="db-section-header"><div class="db-section-title">üîí Vault</div></div>
        <div id="dbVaultUsdTotal" style="font-family:'Syne',sans-serif;font-weight:800;font-size:32px;color:#33ff99;letter-spacing:-0.02em;padding:18px 20px 4px;line-height:1"></div>
        <div id="dbVaultUsdSub" style="font-family:'Share Tech Mono',monospace;font-size:10px;letter-spacing:0.2em;color:#c0bce0;text-transform:uppercase;padding:0 20px 16px;display:none">Total vault value ¬∑ live prices</div>
        <div id="dbVaultOverview" style="border:1px solid rgba(102,51,255,0.12);margin-bottom:20px">
          <div style="padding:16px 20px;font-family:'Share Tech Mono',monospace;font-size:12px;color:#c0bce0">No assets in vault</div>
        </div>

        <div class="db-cards">
          <div class="db-card"><div class="db-card-label">üìã Beneficiaries</div><div class="db-card-value" id="dbBenefCount">0</div><div class="db-card-sub">of 10 slots</div></div>
          <div class="db-card"><div class="db-card-label">üíì Pings</div><div class="db-card-value" id="dbPingCount">0</div><div class="db-card-sub">total heartbeats</div></div>
          <div class="db-card"><div class="db-card-label">üîë Recovery</div><div class="db-card-value" style="font-size:15px" id="dbRecoveryStatus">NONE</div><div class="db-card-sub" id="dbRecoveryShort">not configured</div></div>
        </div>

        <div class="db-section-header"><div class="db-section-title">Recent Activity</div></div>
        <div class="db-form" style="padding:0;max-height:320px;overflow-y:auto">
          <table class="db-table">
            <thead><tr><th>Event</th><th>Time</th><th>Tx</th></tr></thead>
            <tbody id="dbActivityLog">
              <tr><td colspan="3" style="text-align:center;color:#c0bce0">No activity yet</td></tr>
            </tbody>
          </table>
        </div>
      </div>

      <!-- VAULT -->
      <div class="db-page" id="db-page-vault">
        <div class="db-page-title">Vault Assets</div>
        <div class="db-page-sub">Deposit ¬∑ Withdraw ¬∑ Manage</div>

        <!-- DEPOSIT -->
        <div class="db-form">
          <div class="db-form-title">üì• Deposit to Vault</div>
          <div class="db-form-group" style="margin-bottom:14px">
            <label>Select Token from Wallet</label>
            <div class="token-picker" id="depositPicker">
              <button class="token-picker-btn" onclick="toggleTokenPicker('deposit')" type="button">
                <div class="tp-left">
                  <div id="depositPickerLogo" style="width:26px;height:26px;flex-shrink:0"></div>
                  <span class="tp-symbol" id="depositPickerSymbol">Select asset</span>
                  <span class="tp-bal" id="depositPickerBal"></span>
                </div>
                <span class="tp-arrow">‚ñº</span>
              </button>
              <div class="token-picker-dropdown" id="depositPickerDrop"></div>
            </div>
          </div>
          <div class="db-form-grid">
            <div class="db-form-group">
              <label>Amount</label>
              <div style="display:flex;gap:8px;align-items:center">
                <input type="text" id="depositAmtDisplay" placeholder="0" inputmode="decimal" style="flex:1" oninput="formatDepositInput(this)">
                <input type="hidden" id="depositAmt">
                <button class="db-btn db-btn-outline" type="button" style="padding:7px 12px;font-size:11px;white-space:nowrap;flex-shrink:0" onclick="fillMaxDeposit()">MAX</button>
              </div>
            </div>
            <div class="db-form-group"><label>Available in Wallet</label><input type="text" id="depositBalance" value="‚Äî" readonly style="color:#c0bce0"></div>
          </div>
          <div style="display:flex;gap:10px;flex-wrap:wrap">
            <button class="db-btn db-btn-primary" onclick="dbDeposit()">üì• Deposit to Vault</button>
            <button class="db-btn db-btn-outline" onclick="dbDepositAll()" title="Deposit all wallet assets at max balance">üì• Deposit All Assets</button>
          </div>
          <div id="depositWholeVaultNotice" style="display:none;margin-top:12px;padding:10px 14px;background:rgba(102,51,255,0.07);border:1px solid rgba(160,128,255,0.25);font-family:'Share Tech Mono',monospace;font-size:11px;color:#c0a0ff;line-height:1.6">
            üëª <strong style="color:#e0d0ff">Heads up:</strong> Your vault is fully assigned to <span id="depositWholeVaultRecip" style="color:#fff"></span>. Any assets you deposit will be automatically included in their inheritance.
          </div>
        </div>

        <!-- VAULT HOLDINGS + WITHDRAW -->
        <div class="db-section-header">
          <div class="db-section-title">üîí Vault Holdings</div>
          <div style="display:flex;gap:8px;align-items:center">
            <button onclick="dbWithdrawAll()" style="font-family:'Share Tech Mono',monospace;font-size:10px;letter-spacing:0.1em;color:#ff9966;background:none;border:1px solid rgba(255,153,102,0.3);padding:4px 10px;cursor:pointer" title="Withdraw all vault assets">üì§ WITHDRAW ALL</button>
            <button onclick="retryTokenData()" style="font-family:'Share Tech Mono',monospace;font-size:10px;letter-spacing:0.1em;color:#c0bce0;background:none;border:1px solid rgba(102,51,255,0.2);padding:4px 10px;cursor:pointer" title="Re-fetch prices & logos">‚Ü∫ REFRESH</button>
          </div>
        </div>
        <div id="vaultHoldingsUsdTotal" style="font-family:'Syne',sans-serif;font-weight:800;font-size:32px;color:#33ff99;letter-spacing:-0.02em;padding:18px 20px 4px;line-height:1"></div>
        <div id="vaultHoldingsUsdSub" style="font-family:'Share Tech Mono',monospace;font-size:10px;letter-spacing:0.2em;color:#c0bce0;text-transform:uppercase;padding:0 20px 16px;display:none">Total vault value ¬∑ live prices</div>
        <div class="db-info" style="margin-bottom:12px">Each asset can be withdrawn individually back to your wallet. Withdrawals are blocked while your ghost is awakened.</div>
        <div id="vaultHoldingsList" style="border:1px solid rgba(102,51,255,0.12);margin-bottom:20px">
          <div style="padding:24px;text-align:center;font-family:'Share Tech Mono',monospace;font-size:12px;color:#c0bce0">No assets in vault yet.</div>
        </div>
      </div>

      <!-- BENEFICIARIES -->
      <div class="db-page" id="db-page-beneficiaries">
        <div class="db-page-title">Beneficiaries</div>
        <div class="db-page-sub">Who receives your digital legacy when your ghost executes</div>

        <!-- VAULT ALLOCATION OVERVIEW -->
        <div id="beneVaultOverview" style="margin-bottom:20px"></div>

        <!-- BENEFICIARY LIST -->
        <div class="db-section-header">
          <div class="db-section-title">Distribution Plan</div>
          <span style="font-family:'Share Tech Mono',monospace;font-size:12px;color:#c0bce0" id="dbBSlots">0 / 10 slots</span>
        </div>
        <div class="db-form" style="padding:0;margin-bottom:20px">
          <table class="db-table">
            <thead><tr><th>#</th><th>Wallet</th><th>Amount</th><th>Token</th><th>Type</th><th>Status</th><th></th></tr></thead>
            <tbody id="dbBeneficiaryList"><tr><td colspan="7" style="text-align:center;color:#c0bce0;padding:20px">No beneficiaries yet</td></tr></tbody>
          </table>
        </div>

        <!-- ADD SPECIFIC TRANSFER -->
        <div class="db-form">
          <div class="db-form-title">‚ûï Add Transfer</div>
          <div class="db-info">Assign a specific token amount from your vault to a recipient wallet.</div>
          <div class="db-form-group" style="margin-bottom:14px">
            <label>Recipient Wallet Address</label>
            <input type="text" id="newRecipient" placeholder="Solana address (base58)">
          </div>
          <div class="db-form-group" style="margin-bottom:14px">
            <label>Token (from vault)</label>
            <div class="token-picker" id="benePicker">
              <button class="token-picker-btn" onclick="toggleTokenPicker('bene')" type="button">
                <div class="tp-left">
                  <div id="benePickerLogo" style="width:26px;height:26px;flex-shrink:0"></div>
                  <span class="tp-symbol" id="benePickerSymbol">Select vault asset</span>
                  <span class="tp-bal" id="benePickerBal"></span>
                </div>
                <span class="tp-arrow">‚ñº</span>
              </button>
              <div class="token-picker-dropdown" id="benePickerDrop"></div>
            </div>
          </div>
          <!-- Amount row ‚Äî switches between token amount and % share when Whole Vault selected -->
          <div id="beneAmountRow" class="db-form-group" style="margin-bottom:14px">
            <label>Amount <span id="beneRemainingLabel" style="color:#c0bce0;font-size:11px"></span></label>
            <div style="display:flex;gap:8px">
              <input type="number" id="newAmount" placeholder="0" style="flex:1" oninput="updateBeneRemaining()">
              <button class="db-btn db-btn-outline" type="button" style="padding:7px 12px;font-size:11px;white-space:nowrap" onclick="fillMaxBene()">MAX</button>
            </div>
          </div>
          <div id="beneShareRow" class="db-form-group" style="margin-bottom:14px;display:none">
            <div style="font-family:'Share Tech Mono',monospace;font-size:12px;color:#c0a0ff;background:rgba(102,51,255,0.06);border:1px solid rgba(160,128,255,0.2);padding:12px 14px;line-height:1.7">
              üëª This recipient receives <strong style="color:#e0d0ff">100% of the entire vault</strong> on execution ‚Äî every token, proportionally.<br>
              <span style="color:#c0bce0;font-size:11px">Specific transfers and burns are disabled while a whole-vault assignment is active.</span>
            </div>
            <div id="wholeVaultPreview" style="font-family:'Share Tech Mono',monospace;font-size:11px;color:#c0bce0;margin-top:8px;min-height:14px"></div>
          </div>
          <button class="db-btn db-btn-primary" id="addTransferBtn" onclick="dbAddBeneficiary('transfer')">‚ûï Add Transfer</button>
            <button class="db-btn db-btn-danger" id="clearAllBeneBtn" onclick="dbClearAllBeneficiaries()" style="display:none;margin-left:6px">üóë Clear All</button>
          <div id="wholeVaultLockNotice" style="display:none;margin-top:10px;font-family:'Share Tech Mono',monospace;font-size:11px;color:#a080ff;background:rgba(102,51,255,0.06);border:1px solid rgba(160,128,255,0.2);padding:10px 12px">
            üëª Vault is fully assigned. Remove the whole-vault assignment to add specific transfers or burns.
          </div>
        </div>

        <!-- BURN OPTION -->
        <div class="burn-section">
          <div class="db-form-title">üî• Add Burn Instruction</div>
          <div class="db-info" style="border-color:rgba(255,61,90,0.3)">Permanently destroy a token amount on execution. No recipient needed. Does not count toward beneficiary slots.</div>
          <div class="db-form-group" style="margin-bottom:14px">
            <label>Token to Burn (from vault)</label>
            <div class="token-picker" id="burnPicker">
              <button class="token-picker-btn" onclick="toggleTokenPicker('burn')" type="button">
                <div class="tp-left">
                  <div id="burnPickerLogo" style="width:26px;height:26px;flex-shrink:0"></div>
                  <span class="tp-symbol" id="burnPickerSymbol">Select vault asset</span>
                  <span class="tp-bal" id="burnPickerBal"></span>
                </div>
                <span class="tp-arrow">‚ñº</span>
              </button>
              <div class="token-picker-dropdown" id="burnPickerDrop"></div>
            </div>
          </div>
          <div class="db-form-group" style="margin-bottom:14px">
            <label>Amount to Burn</label>
            <input type="number" id="burnAmount" placeholder="0">
          </div>
          <button class="db-btn db-btn-danger" id="addBurnBtn" onclick="dbAddBeneficiary('burn')">üî• Add Burn Instruction</button>
        </div>
      </div>

      <!-- HEARTBEAT -->
      <div class="db-page" id="db-page-heartbeat">
        <div class="db-page-title">Heartbeat</div>
        <div class="db-page-sub">Stay alive ¬∑ Prove you're here</div>
        <div class="db-info">Ping before your interval expires. If you go silent, your grace period activates ‚Äî giving your recovery wallets one last chance to cancel before execution.</div>
        <div class="db-form" style="text-align:center;padding:40px">
          <div style="font-family:'Cormorant Garamond',serif;font-size:18px;font-weight:300;color:#c0bce0;margin-bottom:4px">Next deadline in</div>
          <div style="font-family:'Syne',sans-serif;font-weight:800;font-size:60px;line-height:1;color:var(--white);margin-bottom:28px" id="dbBigCountdown">‚Äî</div>
          <button class="db-btn db-btn-primary" style="padding:16px 52px;font-size:14px" onclick="sendPing()">üíì SEND HEARTBEAT</button>
          <div style="font-family:'Share Tech Mono',monospace;font-size:11px;color:#c0bce0;margin-top:12px">~0.000005 SOL fee</div>
        </div>
        <div class="db-section-header"><div class="db-section-title">Ping History</div></div>
        <div class="db-form" style="padding:0">
          <table class="db-table">
            <thead><tr><th>#</th><th>Timestamp</th><th>Tx</th><th>Gap</th></tr></thead>
            <tbody id="dbPingHistory">
              <tr><td colspan="4" style="text-align:center;color:#c0bce0;padding:20px">No pings recorded yet ‚Äî this session's pings appear here</td></tr>
            </tbody>
          </table>
        </div>
      </div>

      <!-- RECOVERY -->
      <div class="db-page" id="db-page-recovery">
        <div class="db-page-title">Recovery Wallets</div>
        <div class="db-page-sub">Up to 3 trusted wallets ¬∑ Configurable permissions</div>
        <div class="db-info">Recovery wallets are trusted addresses you configure. By default they can only <strong>cancel an awakening</strong> during the grace period. You can optionally grant vault withdrawal rights ‚Äî stored locally and enforced by your own trust.</div>

        <div id="recoveryWalletsList" style="margin-bottom:20px"></div>

        <div class="db-form" id="addRecoveryForm">
          <div class="db-form-title">‚ûï Add Recovery Wallet</div>
          <div class="db-form-group" style="margin-bottom:14px">
            <label>Wallet Address</label>
            <input type="text" id="dbNewRecovery" placeholder="Solana address (base58)">
          </div>
          <div style="display:flex;flex-direction:column;gap:10px;margin-bottom:16px;padding:14px;background:rgba(102,51,255,0.04);border:1px solid rgba(102,51,255,0.1)">
            <div style="font-family:'Share Tech Mono',monospace;font-size:11px;color:#c0bce0;letter-spacing:0.15em;text-transform:uppercase;margin-bottom:4px">Permissions</div>
            <label style="display:flex;align-items:center;gap:10px;cursor:pointer;font-family:'Share Tech Mono',monospace;font-size:13px;color:var(--text)">
              <input type="checkbox" id="permCancel" checked disabled style="accent-color:#7744ff"> Cancel awakening (always enabled)
            </label>
            <label style="display:flex;align-items:center;gap:10px;cursor:pointer;font-family:'Share Tech Mono',monospace;font-size:13px;color:var(--text)">
              <input type="checkbox" id="permWithdraw" style="accent-color:#7744ff;cursor:pointer"> Allow vault withdrawals
            </label>
          </div>
          <button class="db-btn db-btn-primary" onclick="dbAddRecoveryWallet()">üîë Add Recovery Wallet</button>
        </div>
      </div>

      <!-- SETTINGS -->
      <div class="db-page" id="db-page-settings">
        <div class="db-page-title">Settings</div>
        <div class="db-page-sub">Configure your protocol parameters</div>

        <!-- CURRENT SETTINGS DISPLAY -->
        <div class="settings-current" style="margin-bottom:24px">
          <div class="settings-current-item">
            <div class="settings-current-label">‚è±Ô∏è Heartbeat Interval</div>
            <div class="settings-current-value" id="settingsIntervalVal">365</div>
            <div class="settings-current-sub" id="settingsIntervalSub">days ¬∑ ~12.2 months</div>
          </div>
          <div class="settings-current-item">
            <div class="settings-current-label">‚è≥ Grace Period</div>
            <div class="settings-current-value" id="settingsGraceVal">30</div>
            <div class="settings-current-sub" id="settingsGraceSub">days after silence detected</div>
          </div>
          <div class="settings-current-item">
            <div class="settings-current-label">üíÄ Staked</div>
            <div class="settings-current-value" id="settingsStakedVal">10,000</div>
            <div class="settings-current-sub">$GHOST</div>
          </div>
        </div>

        <div class="db-form">
          <div class="db-form-title">‚è±Ô∏è Update Heartbeat Interval</div>
          <div class="db-info">Minimum 7 days. This is how long you have between pings before your ghost awakens.</div>
          <div class="db-form-grid">
            <div class="db-form-group">
              <label>New Interval (Days)</label>
              <input type="number" id="dbNewInterval" placeholder="365" min="7" oninput="document.getElementById('dbIntervalPreview').textContent=this.value+' days ‚âà '+(this.value/30).toFixed(1)+' months'">
            </div>
            <div class="db-form-group">
              <label>Preview</label>
              <div style="font-family:'Share Tech Mono',monospace;font-size:13px;color:var(--accent);padding:11px 0" id="dbIntervalPreview">Enter days above</div>
            </div>
          </div>
          <button class="db-btn db-btn-primary" onclick="dbUpdateInterval()">‚è±Ô∏è Update Interval</button>
        </div>

        <div class="db-form">
          <div class="db-form-title">‚è≥ Update Grace Period</div>
          <div class="db-info">Minimum 1 day. After your ghost awakens, this is your window to cancel via ping or recovery wallet.</div>
          <div class="db-form-grid">
            <div class="db-form-group">
              <label>New Grace Period (Days)</label>
              <input type="number" id="dbNewGrace" placeholder="30" min="1" oninput="document.getElementById('dbGracePreview').textContent=this.value+' days'">
            </div>
            <div class="db-form-group">
              <label>Preview</label>
              <div style="font-family:'Share Tech Mono',monospace;font-size:13px;color:var(--accent);padding:11px 0" id="dbGracePreview">Enter days above</div>
            </div>
          </div>
          <button class="db-btn db-btn-primary" onclick="dbUpdateGrace()">‚è≥ Update Grace Period</button>
        </div>

        <div class="db-form" style="border-color:rgba(255,61,90,0.2)">
          <div class="db-form-title" style="color:var(--red)">‚ö†Ô∏è Danger Zone</div>
          <div class="db-info" style="border-color:var(--red)"><strong>Abandon Ghost:</strong> Permanently closes your vault. Burns 50% of your staked $GHOST. Cannot be undone.</div>
          <button class="db-btn db-btn-danger" onclick="dbAbandon()">üíÄ Abandon Ghost</button>
        </div>
      </div>

      <!-- INITIALIZE GHOST -->
      <div class="db-page" id="db-page-init">
        <div class="init-hero">
          <div class="init-ghost-icon">üëª</div>
          <div class="init-title">Summon Your Ghost</div>
          <div class="init-sub" style="margin-top:8px">No ghost found for this wallet ¬∑ Initialize to activate the protocol</div>
        </div>

        <div class="db-form">
          <div class="db-form-title">‚öôÔ∏è Configure Your Ghost</div>
          <div class="db-info">Your ghost executes automatically when you go silent. All settings can be changed after initialization.</div>

          <div style="display:flex;flex-direction:column;gap:20px;margin-bottom:24px">

            <!-- Interval -->
            <div style="display:flex;align-items:center;justify-content:space-between;gap:20px;padding:18px 20px;background:rgba(102,51,255,0.04);border:1px solid rgba(102,51,255,0.12)">
              <div>
                <div style="font-family:'Syne',sans-serif;font-weight:700;font-size:15px;color:#f0f0f8;margin-bottom:4px">Heartbeat Interval</div>
                <div style="font-family:'Share Tech Mono',monospace;font-size:13px;color:#b0a8d0">How long before your ghost awakens after silence</div>
              </div>
              <div style="display:flex;align-items:center;gap:10px;flex-shrink:0">
                <input type="number" id="initInterval" value="365" min="7" style="width:90px;background:#07070f;border:1px solid rgba(102,51,255,0.25);color:#f0f0f8;font-family:'Syne',sans-serif;font-size:20px;font-weight:700;padding:8px 12px;outline:none;text-align:center" oninput="document.getElementById('initPreview').textContent=this.value+' days'">
                <span style="font-family:'Share Tech Mono',monospace;font-size:13px;color:#b0a8d0">days</span>
              </div>
            </div>

            <!-- Grace -->
            <div style="display:flex;align-items:center;justify-content:space-between;gap:20px;padding:18px 20px;background:rgba(102,51,255,0.04);border:1px solid rgba(102,51,255,0.12)">
              <div>
                <div style="font-family:'Syne',sans-serif;font-weight:700;font-size:15px;color:#f0f0f8;margin-bottom:4px">Grace Period</div>
                <div style="font-family:'Share Tech Mono',monospace;font-size:13px;color:#b0a8d0">Window to cancel after awakening begins</div>
              </div>
              <div style="display:flex;align-items:center;gap:10px;flex-shrink:0">
                <input type="number" id="initGrace" value="30" min="1" style="width:90px;background:#07070f;border:1px solid rgba(102,51,255,0.25);color:#f0f0f8;font-family:'Syne',sans-serif;font-size:20px;font-weight:700;padding:8px 12px;outline:none;text-align:center">
                <span style="font-family:'Share Tech Mono',monospace;font-size:13px;color:#b0a8d0">days</span>
              </div>
            </div>

            <!-- Stake -->
            <div style="padding:18px 20px;background:rgba(102,51,255,0.04);border:1px solid rgba(102,51,255,0.2)">
              <div style="display:flex;align-items:center;justify-content:space-between;gap:20px;margin-bottom:14px">
                <div>
                  <div style="font-family:'Syne',sans-serif;font-weight:700;font-size:15px;color:#f0f0f8;margin-bottom:4px">Stake Amount</div>
                  <div style="font-family:'Share Tech Mono',monospace;font-size:13px;color:#b0a8d0">Minimum 10,000 $GHOST required</div>
                </div>
                <div style="display:flex;align-items:center;gap:10px;flex-shrink:0">
                  <input type="number" id="initStake" value="10000" min="10000" style="width:120px;background:#07070f;border:1px solid rgba(102,51,255,0.25);color:#c0a0ff;font-family:'Syne',sans-serif;font-size:20px;font-weight:700;padding:8px 12px;outline:none;text-align:center" oninput="validateStakeInput(this)">
                  <span style="font-family:'Share Tech Mono',monospace;font-size:13px;color:#b0a8d0">$GHOST</span>
                </div>
              </div>
              <div id="stakeWarning" style="display:none;font-family:'Share Tech Mono',monospace;font-size:12px;color:var(--red);margin-bottom:10px">‚ö†Ô∏è Minimum 10,000 $GHOST required to summon</div>
              <div style="font-family:'Share Tech Mono',monospace;font-size:13px;color:rgba(255,120,100,0.9)">‚ö†Ô∏è 50% of staked $GHOST is burned permanently if you abandon your ghost</div>
            </div>

          </div>

          <!-- Summary bar -->
          <div style="display:flex;align-items:center;justify-content:space-between;padding:14px 18px;background:#07070f;border:1px solid rgba(102,51,255,0.15);margin-bottom:20px">
            <span style="font-family:'Share Tech Mono',monospace;font-size:13px;color:#b0b0c8">Ghost awakens after</span>
            <span style="font-family:'Syne',sans-serif;font-weight:800;font-size:18px;color:#f0f0f8" id="initPreview">365 days</span>
            <span style="font-family:'Share Tech Mono',monospace;font-size:13px;color:#b0b0c8">of silence</span>
          </div>

          <div style="font-family:'Share Tech Mono',monospace;font-size:13px;color:#b0a8d0;margin-bottom:20px;padding:12px 16px;border-left:3px solid rgba(102,51,255,0.4)">
            ~0.01 SOL for on-chain account rent ¬∑ Wallet signature required
          </div>

          <button class="db-btn db-btn-primary" style="width:100%;padding:18px;font-size:15px;justify-content:center" onclick="initializeGhost()">
            üëª Summon Ghost
          </button>
        </div>

        <!-- WHAT HAPPENS NEXT ‚Äî visual steps -->
        <div class="db-form">
          <div class="db-form-title">üó∫Ô∏è What happens after you summon?</div>
          <div style="display:flex;flex-direction:column;gap:0">

            <div style="display:flex;gap:18px;padding:18px 0;border-bottom:1px solid rgba(102,51,255,0.1)">
              <div style="width:36px;height:36px;border-radius:50%;background:rgba(102,51,255,0.2);border:1.5px solid rgba(102,51,255,0.5);display:flex;align-items:center;justify-content:center;font-family:'Syne',sans-serif;font-weight:800;font-size:14px;color:var(--accent);flex-shrink:0;box-shadow:0 0 12px rgba(102,51,255,0.2)">1</div>
              <div>
                <div style="font-family:'Syne',sans-serif;font-weight:700;font-size:15px;color:#f0f0f8;margin-bottom:6px">Ghost account created on-chain</div>
                <div style="font-family:'Share Tech Mono',monospace;font-size:13px;color:#b0a8d0;line-height:1.7">Your heartbeat clock starts immediately. The countdown begins from the moment you initialize.</div>
              </div>
            </div>

            <div style="display:flex;gap:18px;padding:18px 0;border-bottom:1px solid rgba(102,51,255,0.1)">
              <div style="width:36px;height:36px;border-radius:50%;background:rgba(102,51,255,0.2);border:1.5px solid rgba(102,51,255,0.5);display:flex;align-items:center;justify-content:center;font-family:'Syne',sans-serif;font-weight:800;font-size:14px;color:var(--accent);flex-shrink:0;box-shadow:0 0 12px rgba(102,51,255,0.2)">2</div>
              <div>
                <div style="font-family:'Syne',sans-serif;font-weight:700;font-size:15px;color:#f0f0f8;margin-bottom:6px">Deposit assets into your vault</div>
                <div style="font-family:'Share Tech Mono',monospace;font-size:13px;color:#b0a8d0;line-height:1.7">Lock SOL, USDC, or any SPL tokens. These assets are held securely until your ghost executes ‚Äî or you withdraw them.</div>
              </div>
            </div>

            <div style="display:flex;gap:18px;padding:18px 0;border-bottom:1px solid rgba(102,51,255,0.1)">
              <div style="width:36px;height:36px;border-radius:50%;background:rgba(102,51,255,0.2);border:1.5px solid rgba(102,51,255,0.5);display:flex;align-items:center;justify-content:center;font-family:'Syne',sans-serif;font-weight:800;font-size:14px;color:var(--accent);flex-shrink:0;box-shadow:0 0 12px rgba(102,51,255,0.2)">3</div>
              <div>
                <div style="font-family:'Syne',sans-serif;font-weight:700;font-size:15px;color:#f0f0f8;margin-bottom:6px">Add beneficiaries</div>
                <div style="font-family:'Share Tech Mono',monospace;font-size:13px;color:#b0a8d0;line-height:1.7">Assign wallet addresses to receive specific token amounts. Up to 10 transfer recipients plus optional burn instructions.</div>
              </div>
            </div>

            <div style="display:flex;gap:18px;padding:18px 0;border-bottom:1px solid rgba(102,51,255,0.1)">
              <div style="width:36px;height:36px;border-radius:50%;background:rgba(102,51,255,0.2);border:1.5px solid rgba(102,51,255,0.5);display:flex;align-items:center;justify-content:center;font-family:'Syne',sans-serif;font-weight:800;font-size:14px;color:var(--accent);flex-shrink:0;box-shadow:0 0 12px rgba(102,51,255,0.2)">4</div>
              <div>
                <div style="font-family:'Syne',sans-serif;font-weight:700;font-size:15px;color:#f0f0f8;margin-bottom:6px">Send heartbeats regularly</div>
                <div style="font-family:'Share Tech Mono',monospace;font-size:13px;color:#b0a8d0;line-height:1.7">Ping before your interval expires to reset the clock. Each ping costs ~0.000005 SOL and proves you're alive.</div>
              </div>
            </div>

            <div style="display:flex;gap:18px;padding:18px 0">
              <div style="width:36px;height:36px;border-radius:50%;background:rgba(255,61,90,0.12);border:1.5px solid rgba(255,61,90,0.4);display:flex;align-items:center;justify-content:center;font-size:18px;flex-shrink:0;box-shadow:0 0 12px rgba(255,61,90,0.15)">üíÄ</div>
              <div>
                <div style="font-family:'Syne',sans-serif;font-weight:700;font-size:15px;color:#ff8090;margin-bottom:6px">If you go silent‚Ä¶</div>
                <div style="font-family:'Share Tech Mono',monospace;font-size:13px;color:#b0a8d0;line-height:1.7">After your interval expires, your grace period gives you one last chance to cancel via your recovery wallet. If no one intervenes ‚Äî your vault executes automatically and assets are distributed to your beneficiaries.</div>
              </div>
            </div>

          </div>
        </div>
      </div>

      <!-- HEARTBEAT CHECKER -->
      <div class="db-page" id="db-page-watcher">
        <div class="db-page-title">Soul Monitor</div>
        <div class="db-page-sub">Check any wallet ‚Äî or act as their guardian</div>

        <!-- MODE TOGGLE -->
        <div style="display:flex;gap:10px;margin-bottom:28px">
          <button id="watcherModeObserve" onclick="setWatcherMode('observe')" style="flex:1;padding:16px 12px;font-family:'Share Tech Mono',monospace;font-size:13px;letter-spacing:0.15em;text-transform:uppercase;border:1px solid rgba(102,51,255,0.4);cursor:pointer;transition:all 0.2s;background:rgba(102,51,255,0.2);color:#c8a8ff;font-weight:600">üîç&nbsp; Check Pulse</button>
          <button id="watcherModeGuardian" onclick="setWatcherMode('guardian')" style="flex:1;padding:16px 12px;font-family:'Share Tech Mono',monospace;font-size:13px;letter-spacing:0.15em;text-transform:uppercase;border:1px solid rgba(102,51,255,0.15);cursor:pointer;transition:all 0.2s;background:transparent;color:#c0b8e8">üõ°&nbsp; Guardian Mode</button>
        </div>

        <!-- CHECK PULSE MODE -->
        <div id="watcherPanelObserve">
          <div class="db-info" style="margin-bottom:20px">Enter any Solana wallet to see their ghost status, last heartbeat, and time remaining.</div>
          <div class="db-form-group" style="margin-bottom:14px">
            <label>Wallet Address</label>
            <input type="text" id="soulToCheck" placeholder="Enter any Solana wallet address...">
          </div>
          <button class="db-btn db-btn-primary" onclick="dbLookupSoul()">üîç Check Heartbeat</button>
          <div class="watcher-result" id="watcherResult" style="margin-top:16px"></div>
        </div>

        <!-- GUARDIAN MODE -->
        <div id="watcherPanelGuardian" style="display:none">
          <div style="background:rgba(255,153,102,0.08);border:1px solid rgba(255,153,102,0.3);padding:20px 24px;margin-bottom:24px">
            <div style="font-family:'Syne',sans-serif;font-weight:700;font-size:15px;color:#ffcc99;margin-bottom:10px">üëÅ Your Guardian Assignments</div>
            <div style="font-family:'Share Tech Mono',monospace;font-size:13px;color:#e8c9a0;line-height:2">
              Souls who have assigned you as their recovery wallet appear below. As a guardian you can:<br>
              <span style="color:#ffd580">¬∑ Cancel an awakening</span> ‚Äî reset the heartbeat clock during a grace period<br>
              <span style="color:#ffd580">¬∑ Withdraw vault assets</span> ‚Äî only if the soul granted you withdrawal rights at setup
            </div>
          </div>

          <!-- SCAN STATE -->
          <div id="guardianScanState" style="text-align:center;padding:32px 0">
            <div style="font-family:'Share Tech Mono',monospace;font-size:13px;color:#9090a8;margin-bottom:16px">Scan the chain to find wallets you're protecting</div>
            <button class="db-btn db-btn-primary" style="padding:14px 32px;font-size:13px" onclick="scanGuardianAssignments()">üîç SCAN MY ASSIGNMENTS</button>
            <div id="guardianScanStatus" style="margin-top:14px;font-family:'Share Tech Mono',monospace;font-size:12px;color:#9090a8"></div>
          </div>

          <!-- RESULTS -->
          <div id="guardianAssignmentsList" style="display:none"></div>

          <div style="margin-top:28px;padding-top:20px;border-top:1px solid rgba(102,51,255,0.12);font-family:'Share Tech Mono',monospace;font-size:12px;color:rgba(200,180,255,0.55);line-height:2.2">
            // Scans on-chain ghost accounts ‚Äî may take a few seconds<br>
            // Withdrawal access only unlocked if the soul granted it at setup<br>
            // Cancelling resets the heartbeat clock and marks the soul alive
          </div>
        </div>
      </div>

    </main>
  </div>
</div>

<!-- PING RIPPLE -->
<div class="ping-ripple" id="pingRipple">
  <div class="ping-ripple-ring"></div>
  <div class="ping-ripple-ring"></div>
  <div class="ping-ripple-ring"></div>
</div>

<div class="marketing-site">
<!-- ‚îÄ‚îÄ‚îÄ MARKETING SITE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ -->
<!-- NAV -->
<nav>
  <a class="nav-logo" href="#"><span>$</span>GHOST</a>
  <ul class="nav-links">
    <li><a href="#protocol">Protocol</a></li>
    <li><a href="#tokenomics">Tokenomics</a></li>
    <li><a href="#roadmap">Roadmap</a></li>
    <li><a href="#risks">Risks</a></li>
    <li><a href="#faq">FAQ</a></li>
    <li><a href="ghost-whitepaper.html" target="_blank" style="color:var(--accent)">Whitepaper ‚Üó</a></li>
    <li><a href="#" class="nav-dashboard-link" id="navDashboardLink" onclick="openDashboard();return false;">
      <span class="nav-dashboard-dot"></span> Dashboard
    </a></li>
  </ul>
  <button class="wallet-btn" id="walletBtn" onclick="openModal()">Connect Wallet</button>
  <button id="navDisconnectBtn" onclick="disconnectWallet()" style="display:none;font-family:'Share Tech Mono',monospace;font-size:11px;letter-spacing:0.1em;color:#ff6666;background:none;border:1px solid rgba(255,102,102,0.3);padding:6px 12px;cursor:pointer;margin-left:8px;transition:all 0.2s" onmouseover="this.style.background='rgba(255,102,102,0.1)'" onmouseout="this.style.background='none'" title="Disconnect wallet">‚èª</button>
</nav>

<!-- CONTRACT BANNER -->
<div class="contract-banner">
  <span class="label">Contract</span>
  <span class="contract-addr" id="contractAddr">k4MxJAdy22Dgd2UTQ9p3etbnaSLUH1q5cEfSRi6pump</span>
  <button class="copy-btn" onclick="copyContract()">COPY</button>
  <span class="sol-badge">‚óé SOLANA</span>
  <a href="https://pump.fun/coin/k4MxJAdy22Dgd2UTQ9p3etbnaSLUH1q5cEfSRi6pump" target="_blank" style="font-family:'Share Tech Mono',monospace;font-size:12px;letter-spacing:0.2em;color:var(--accent);text-decoration:none;border:1px solid rgba(102,51,255,0.3);padding:3px 10px;">BUY ON PUMP.FUN ‚Üó</a>
</div>

<!-- HERO -->
<div class="hero">
  <div class="hero-bg"></div>
  <div class="hero-grid"></div>
  <div class="heartbeat-ring"></div>
  <div class="heartbeat-ring"></div>
  <div class="heartbeat-ring"></div>
  <svg class="hero-logo" viewBox="0 0 400 400" xmlns="http://www.w3.org/2000/svg">
    <defs><radialGradient id="coinGrad" cx="40%" cy="35%" r="60%"><stop offset="0%" stop-color="#9966ff"/><stop offset="50%" stop-color="#6633ff"/><stop offset="100%" stop-color="#2200aa"/></radialGradient></defs>
    <circle cx="200" cy="200" r="180" fill="rgba(102,51,255,0.08)"/>
    <circle cx="200" cy="200" r="155" fill="none" stroke="#6633ff" stroke-width="1" opacity="0.3"/>
    <circle cx="200" cy="200" r="140" fill="url(#coinGrad)"/>
    <circle cx="200" cy="200" r="132" fill="none" stroke="#9966ff" stroke-width="1" opacity="0.4"/>
    <path d="M200 105 C165 105, 138 130, 138 162 L138 248 L155 235 L172 248 L189 235 L200 245 L211 235 L228 248 L245 235 L262 248 L262 162 C262 130, 235 105, 200 105 Z" fill="#e8e0ff" opacity="0.95"/>
    <ellipse cx="181" cy="175" rx="12" ry="14" fill="#2200aa"/>
    <ellipse cx="219" cy="175" rx="12" ry="14" fill="#2200aa"/>
    <ellipse cx="181" cy="175" rx="6" ry="7" fill="#8855ff" opacity="0.8"/>
    <ellipse cx="219" cy="175" rx="6" ry="7" fill="#8855ff" opacity="0.8"/>
    <circle cx="178" cy="172" r="3" fill="#ffffff" opacity="0.9"/>
    <circle cx="216" cy="172" r="3" fill="#ffffff" opacity="0.9"/>
    <polyline points="138,205 155,205 163,205 167,188 172,222 176,196 180,214 184,205 216,205 220,205 224,190 228,220 232,197 236,210 240,205 262,205" fill="none" stroke="#ff3366" stroke-width="2" opacity="0.85" stroke-linecap="round" stroke-linejoin="round"/>
  </svg>
  <p class="hero-eyebrow">Trustless ¬∑ Solana ¬∑ Digital Legacy Protocol</p>
  <h1 class="hero-title">GHOST</h1>
  <p class="hero-ticker">$GHOST</p>
  <p class="hero-sub">Miss your heartbeat.<br><em>Your ghost awakens.</em></p>
  <div class="hero-actions">
    <a class="btn-pump" href="https://pump.fun/coin/k4MxJAdy22Dgd2UTQ9p3etbnaSLUH1q5cEfSRi6pump" target="_blank"><span class="pump-icon">üëª</span> Buy on Pump.fun</a>
    <a class="btn-dex" href="https://dexscreener.com/solana/k4MxJAdy22Dgd2UTQ9p3etbnaSLUH1q5cEfSRi6pump" target="_blank">Dexscreener ‚Üó</a>
    <button class="btn-secondary" onclick="ghostState.connected ? openDashboard() : openModal()">Register Heartbeat</button>

  </div>
  <div class="heartbeat-bar">
    <div class="hb-label">
      <span id="walletStatus">Ghost_0x4f...3a9c ‚Äî Heartbeat Active</span>
      <span>‚óè PULSE DETECTED</span>
    </div>
    <div class="hb-line">
      <svg class="hb-svg" viewBox="0 0 1400 60" preserveAspectRatio="none">
        <polyline points="0,30 100,30 120,30 130,5 140,55 150,20 160,45 170,30 300,30 400,30 420,30 430,8 440,52 450,18 460,42 470,30 600,30 700,30 720,30 730,5 740,55 750,20 760,45 770,30 900,30 1000,30 1020,30 1030,8 1040,52 1050,18 1060,42 1070,30 1200,30 1300,30 1320,30 1330,5 1340,55 1350,20 1360,45 1370,30 1400,30" fill="none" stroke="#6633ff" stroke-width="1.5" opacity="0.6"/>
      </svg>
    </div>
  </div>
</div>

<!-- PRICE TICKER -->
<div class="stats-wrap reveal">
  <div class="price-ticker">
    <div class="ticker-item"><span class="ticker-label">$GHOST Price</span><span class="ticker-value up" id="price">‚Äî</span></div>
    <div class="ticker-item"><span class="ticker-label">Market Cap</span><span class="ticker-value" id="mcap">‚Äî</span></div>
    <div class="ticker-item"><span class="ticker-label">24h Change</span><span class="ticker-value" id="priceChange">‚Äî</span></div>
    <div class="ticker-item"><span class="ticker-label">Volume 24h</span><span class="ticker-value" id="vol24">‚Äî</span></div>
    <div class="ticker-item"><span class="ticker-label">‚óé SOL</span><span class="ticker-value" id="solPrice">‚Äî</span></div>
  </div>
</div>

<!-- STATS -->
<div class="stats-wrap reveal">
  <div class="stats">
    <div class="stat"><span class="stat-value">1B</span><span class="stat-label">Total Supply</span></div>
    <div class="stat"><span class="stat-value" id="ghostCount">2,401</span><span class="stat-label">Ghosts Active</span></div>
    <div class="stat"><span class="stat-value">365d</span><span class="stat-label">Default Heartbeat</span></div>
    <div class="stat"><span class="stat-value">‚àû</span><span class="stat-label">Legacy Duration</span></div>
  </div>
</div>

<!-- HOW IT WORKS -->
<section id="protocol">
  <span class="section-tag reveal">¬ß01 ‚Äî The Protocol</span>
  <h2 class="section-title reveal">Miss your heartbeat.<br>Your ghost awakens.</h2>
  <p class="section-body reveal">GHOST is a trustless digital legacy protocol on Solana. Deposit SOL and SPL tokens into your personal vault, set your beneficiaries, and keep pinging. If your heartbeat stops, a grace period begins ‚Äî and if no one intervenes, your vault executes your final instructions automatically. No private keys shared. No middlemen. Just code.</p>
  <div class="how-grid">
    <div class="how-steps reveal">
      <div class="step"><span class="step-num">01 ‚Äî</span><div class="step-content"><h3>Connect & Create Vault</h3><p>Connect your wallet. Stake $GHOST to initialize your ghost account. A unique vault (PDA) is created on-chain ‚Äî only the program can move funds from it.</p></div></div>
      <div class="step"><span class="step-num">02 ‚Äî</span><div class="step-content"><h3>Fund & Configure</h3><p>Deposit SOL and SPL tokens into your vault. Set your beneficiaries ‚Äî who gets what when you go dark. Add anytime.</p></div></div>
      <div class="step"><span class="step-num">03 ‚Äî</span><div class="step-content"><h3>Stay Alive</h3><p>Ping before your interval expires. Costs less than 0.001 SOL. Miss it, and your grace period begins automatically.</p></div></div>
      <div class="step"><span class="step-num">04 ‚Äî</span><div class="step-content"><h3>Grace Period & Execution</h3><p>During the grace window, you or any of your recovery wallets can cancel. If no one intervenes, your vault executes automatically.</p></div></div>
    </div>
    <div class="terminal reveal">
      <div class="terminal-bar">
        <div class="terminal-dot red"></div><div class="terminal-dot yellow"></div><div class="terminal-dot green"></div>
        <span class="terminal-title">ghost_protocol/src/lib.rs</span>
      </div>
      <div class="terminal-body">
        <span class="t-line t-comment">// GHOST Protocol ‚Äî Solana / Anchor v1.1</span>
        <span class="t-line t-comment">// Trustless Digital Legacy</span>
        <span class="t-line"> </span>
        <span class="t-line"><span class="t-func">#[account]</span></span>
        <span class="t-line"><span class="t-keyword">pub struct</span> <span class="t-func">GhostAccount</span> {</span>
        <span class="t-line">  <span class="t-keyword">pub</span> owner: Pubkey,</span>
        <span class="t-line">  <span class="t-keyword">pub</span> recovery_wallets: [Option&lt;Pubkey&gt;; 3],</span>
        <span class="t-line">  <span class="t-keyword">pub</span> last_heartbeat: i64,</span>
        <span class="t-line">  <span class="t-keyword">pub</span> awakened: bool,</span>
        <span class="t-line">  <span class="t-keyword">pub</span> beneficiaries: [Beneficiary; 10],</span>
        <span class="t-line">}</span>
        <span class="t-line"> </span>
        <span class="t-line"><span class="t-keyword">pub fn</span> <span class="t-pulse">check_silence</span>(ctx) {</span>
        <span class="t-line">  <span class="t-keyword">if</span> silence > interval {</span>
        <span class="t-line">    ghost.awakened = <span class="t-number">true</span>;</span>
        <span class="t-line">    pay_bounty(5%)?;</span>
        <span class="t-line">  }</span>
        <span class="t-line">}</span>
        <span class="t-line"> </span>
        <span class="t-line"><span class="t-keyword">pub fn</span> <span class="t-func">execute_legacy</span>(ctx) {</span>
        <span class="t-line">  <span class="t-keyword">if</span> grace_expired(&ghost) {</span>
        <span class="t-line">    distribute_vault(&ghost)?;</span>
        <span class="t-line">  }</span>
        <span class="t-line">}</span>
        <span class="t-line"> </span>
        <span class="t-line"><span class="t-comment">// $ anchor build && anchor deploy</span></span>
        <span class="t-line"><span class="t-comment">// > deploying to mainnet-beta...</span> <span class="cursor"></span></span>
      </div>
    </div>
  </div>
</section>

<!-- TOKENOMICS -->
<div class="token-section">
  <section id="tokenomics" style="max-width:1200px;padding:100px 48px;">
    <span class="section-tag reveal">¬ß02 ‚Äî Tokenomics</span>
    <h2 class="section-title reveal">1 Billion $GHOST.<br>Not one more.</h2>
    <p class="section-body reveal">Fixed supply. No minting. Fair launch on Pump.fun. $GHOST powers every ghost on-chain.</p>
    <div class="token-grid reveal" style="grid-template-columns:repeat(2,1fr)">
      <div class="token-card"><span class="token-percent">85<span>%</span></span><span class="token-name">Pump.fun Fair Launch</span><p class="token-desc">850,000,000 $GHOST. Bonding curve. No presale. No VCs.</p></div>
      <div class="token-card"><span class="token-percent">10<span>%</span></span><span class="token-name">Project Treasury</span><p class="token-desc">100,000,000 $GHOST. Team-controlled wallet. Funds marketing & ops.</p></div>
      <div class="token-card"><span class="token-percent">5<span>%</span></span><span class="token-name">Team</span><p class="token-desc">50,000,000 $GHOST. Locked on Streamflow. 6-month cliff, 6-month linear vest.</p></div>
      <div class="token-card" style="background:rgba(102,51,255,0.04)"><span class="token-percent" style="color:var(--accent)">0<span>%</span></span><span class="token-name">VC / Private Sale</span><p class="token-desc">There are no ghosts that answer to venture capital. Never will be.</p></div>
    </div>
  </section>
</div>

<!-- MANIFESTO -->
<div class="manifesto reveal">
  <div class="manifesto-bg"></div>
  <blockquote>"Death is not the end of presence.<br>It is only the end of the heartbeat."</blockquote>
  <p class="manifesto-attr">‚Äî The GHOST Manifesto, 2026</p>
</div>

<!-- ROADMAP -->
<section id="roadmap" style="max-width:1000px;">
  <span class="section-tag reveal">¬ß03 ‚Äî Roadmap</span>
  <h2 class="section-title reveal">The path<br>into the dark.</h2>
  <div class="roadmap-grid reveal">
    <div class="road-card"><span class="road-badge">Phase I</span><h3>Summon</h3><span class="road-when">March 2026</span><ul><li>Fair launch on Pump.fun</li><li>Whitepaper &amp; website published</li><li>Community launch on X</li><li>Core protocol live on Solana mainnet</li><li>Ghost Dashboard ‚Äî vault, beneficiaries &amp; heartbeat</li><li>SOL &amp; SPL token vault support</li><li>Recovery wallet support</li><li>Smart contract audit</li><li>Target: 1,500 holders</li></ul></div>
    <div class="road-card"><span class="road-badge">Phase II</span><h3>Awaken</h3><span class="road-when">Q2 2026</span><ul><li>NFT vault support (Metaplex)</li><li>Time-locked transfers for beneficiaries</li><li>Auto-sell SPL tokens to SOL via Jupiter</li><li>Off-chain executor ‚Äî post to X, send emails</li></ul></div>
    <div class="road-card"><span class="road-badge">Phase III</span><h3>Possess</h3><span class="road-when">Q3 2026</span><ul><li>Close DeFi positions (Jupiter, Marginfi, Drift)</li><li>Cross-chain bridges (Ethereum, Base)</li></ul></div>
    <div class="road-card"><span class="road-badge">Phase IV</span><h3>Eternal</h3><span class="road-when">Q4 2026</span><ul><li>Off-chain link to Pika Labs AI Selves profile</li><li>100k souls registered</li></ul></div>
  </div>
</section>

<!-- ACTIONS -->
<section id="actions" style="max-width:900px;">
  <span class="section-tag reveal">¬ß04 ‚Äî Ghost Actions</span>
  <h2 class="section-title reveal">What your ghost<br>can do.</h2>
  <p class="section-body reveal">Configure exactly what happens when your heartbeat stops.</p>
  <div class="actions-grid reveal">
    <div class="action-col">
      <h3>On-Chain ‚Äî Phase II</h3>
      <div class="action-item"><span class="action-icon">‚óé</span><p class="action-text">Send SOL to beneficiaries</p></div>
      <div class="action-item"><span class="action-icon">ü™ô</span><p class="action-text">Send SPL tokens to beneficiaries</p></div>
      <div class="action-item"><span class="action-icon">üî•</span><p class="action-text">Burn SPL tokens permanently</p></div>
      <div class="action-item"><span class="action-icon">üë•</span><p class="action-text">Split vault across up to 10 beneficiaries</p></div>
    </div>
    <div class="action-col">
      <h3>Coming ‚Äî Phase II & III</h3>
      <div class="action-item"><span class="action-icon">üîí</span><p class="action-text">Time-locked transfers <span>‚Äî vesting schedule</span></p></div>
      <div class="action-item"><span class="action-icon">üí±</span><p class="action-text">Auto-sell to SOL <span>‚Äî via Jupiter</span></p></div>
      <div class="action-item"><span class="action-icon">üì£</span><p class="action-text">Post a final message on X</p></div>
      <div class="action-item"><span class="action-icon">üìß</span><p class="action-text">Send emails to a list of people</p></div>
      <div class="action-item"><span class="action-icon">üìä</span><p class="action-text">Close DeFi positions <span>‚Äî Jupiter, Marginfi, Drift</span></p></div>
    </div>
  </div>
</section>

<!-- RISKS -->
<section id="risks" style="max-width:900px;">
  <span class="section-tag reveal">¬ß05 ‚Äî Risks</span>
  <h2 class="section-title reveal">Important<br>disclaimers.</h2>
  <p class="section-body reveal">$GHOST is an experimental protocol. Read before you ghost.</p>
  <div class="reveal" style="display:grid;grid-template-columns:1fr 1fr;gap:16px;margin-top:40px">
    <div style="padding:28px;background:rgba(255,61,90,0.04);border:1px solid rgba(255,61,90,0.15)">
      <div style="font-family:'Share Tech Mono',monospace;font-size:10px;letter-spacing:0.25em;color:rgba(255,96,128,0.6);margin-bottom:10px;text-transform:uppercase">Smart Contract Risk</div>
      <p style="font-family:'Share Tech Mono',monospace;font-size:12px;color:#b0a8d0;line-height:1.8;margin:0">Despite auditing, smart contracts may contain vulnerabilities. Funds deposited in ghost vaults could be at risk.</p>
    </div>
    <div style="padding:28px;background:rgba(255,153,51,0.04);border:1px solid rgba(255,153,51,0.15)">
      <div style="font-family:'Share Tech Mono',monospace;font-size:10px;letter-spacing:0.25em;color:rgba(255,153,51,0.6);margin-bottom:10px;text-transform:uppercase">Execution Risk</div>
      <p style="font-family:'Share Tech Mono',monospace;font-size:12px;color:#b0a8d0;line-height:1.8;margin:0">Off-chain features (Phase III) depend on external APIs that may change. On-chain actions are trustless and permanent.</p>
    </div>
    <div style="padding:28px;background:rgba(102,51,255,0.04);border:1px solid rgba(102,51,255,0.15)">
      <div style="font-family:'Share Tech Mono',monospace;font-size:10px;letter-spacing:0.25em;color:rgba(160,128,255,0.6);margin-bottom:10px;text-transform:uppercase">Regulatory Risk</div>
      <p style="font-family:'Share Tech Mono',monospace;font-size:12px;color:#b0a8d0;line-height:1.8;margin:0">Digital asset regulations are evolving. Automated estate distribution is legally untested in most jurisdictions.</p>
    </div>
    <div style="padding:28px;background:rgba(255,61,90,0.04);border:1px solid rgba(255,61,90,0.15)">
      <div style="font-family:'Share Tech Mono',monospace;font-size:10px;letter-spacing:0.25em;color:rgba(255,96,128,0.6);margin-bottom:10px;text-transform:uppercase">Market Risk</div>
      <p style="font-family:'Share Tech Mono',monospace;font-size:12px;color:#b0a8d0;line-height:1.8;margin:0">$GHOST is a volatile digital asset. Its value may go to zero. Do not invest more than you can afford to lose.</p>
    </div>
  </div>
  <p class="reveal" style="font-family:'Share Tech Mono',monospace;font-size:11px;color:#555570;margin-top:28px;line-height:1.8;text-align:center">This does not constitute financial, legal, or investment advice. $GHOST is an experimental protocol. Participate at your own risk.</p>
</section>

<!-- FAQ -->
<section id="faq" style="max-width:900px;">
  <span class="section-tag reveal">¬ß06 ‚Äî FAQ</span>
  <h2 class="section-title reveal">Questions from<br>the living.</h2>
  <div class="faq-list reveal">
    <div class="faq-item"><div class="faq-q" onclick="this.parentElement.classList.toggle('open')">What is GHOST?</div><div class="faq-a"><p>GHOST is a trustless digital legacy protocol on Solana. You deposit assets into a personal vault, set your beneficiaries, and keep sending heartbeat pings. If you stop pinging, your ghost awakens and distributes your vault automatically.</p></div></div>
    <div class="faq-item"><div class="faq-q" onclick="this.parentElement.classList.toggle('open')">How is this different from giving someone my seed phrase?</div><div class="faq-a"><p>Giving someone your seed phrase means they can access your wallet at any time. With GHOST, your vault is controlled by an audited smart contract ‚Äî not a person. Nobody can touch your vaulted assets while you're alive and pinging.</p></div></div>
    <div class="faq-item"><div class="faq-q" onclick="this.parentElement.classList.toggle('open')">Do I have to put all my crypto in the vault?</div><div class="faq-a"><p>No. You deposit only what you want distributed. The rest stays in your personal wallet.</p></div></div>
    <div class="faq-item"><div class="faq-q" onclick="this.parentElement.classList.toggle('open')">What if I forget to ping?</div><div class="faq-a"><p>A grace period starts ‚Äî you choose the duration at registration (minimum 24 hours). During this window, you or any of your recovery wallets can cancel and reset your heartbeat.</p></div></div>
    <div class="faq-item"><div class="faq-q" onclick="this.parentElement.classList.toggle('open')">What is a recovery wallet?</div><div class="faq-a"><p>You can register up to 3 recovery wallets ‚Äî a spouse, a trusted friend, a hardware wallet in a safe ‚Äî each of which can cancel a ghost awakening during the grace period. By default, recovery wallets cannot access vault funds. You can optionally grant one withdrawal access, allowing it to move assets on your behalf.</p></div></div>
    <div class="faq-item"><div class="faq-q" onclick="this.parentElement.classList.toggle('open')">Can I withdraw my assets?</div><div class="faq-a"><p>Yes, anytime while your ghost is sleeping. You can deposit and withdraw freely. Withdrawals are blocked only during an active awakening.</p></div></div>
    <div class="faq-item"><div class="faq-q" onclick="this.parentElement.classList.toggle('open')">Is the smart contract audited?</div><div class="faq-a"><p>The contract is live on Solana mainnet. A formal audit is currently in progress ‚Äî we will publish the full report when complete. The code is open source and built with Anchor.</p></div></div>
    <div class="faq-item"><div class="faq-q" onclick="this.parentElement.classList.toggle('open')">Can the GHOST team access my vault?</div><div class="faq-a"><p>No. Your vault is a PDA ‚Äî no private key. Only the program logic controls it, and only after your heartbeat expires and grace period passes.</p></div></div>
  </div>
</section>

<!-- CTA -->
<div class="cta-section reveal">
  <h2 class="cta-title">Are you<br>still alive?</h2>
  <p class="cta-sub">Register your heartbeat before the silence speaks for you.</p>
  <div style="display:flex;gap:16px;justify-content:center;flex-wrap:wrap;position:relative;z-index:2;">
    <a class="btn-pump" href="https://pump.fun/coin/k4MxJAdy22Dgd2UTQ9p3etbnaSLUH1q5cEfSRi6pump" target="_blank"><span class="pump-icon">üëª</span> Buy on Pump.fun</a>
    <button class="btn-secondary" onclick="ghostState.connected ? openDashboard() : openModal()">Register Heartbeat</button>
  </div>
</div>

<!-- FOOTER -->
<footer>
  <span class="footer-logo">$GHOST</span>
  <span class="footer-mono">‚óé solana mainnet ‚Äî <a href="https://solscan.io/account/k4MxJAdy22Dgd2UTQ9p3etbnaSLUH1q5cEfSRi6pump" target="_blank" style="color:var(--accent);text-decoration:none;letter-spacing:0.2em">contract live ‚Üó</a></span>
  <span class="footer-mono">¬© 2026 ghost protocol. all souls reserved.</span>
</footer>

<script>
// ‚îÄ‚îÄ‚îÄ State ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// ‚îÄ‚îÄ‚îÄ GHOST Protocol ‚Äî Real Solana Integration ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// Deployed program ID ‚Äî matches declare_id! in lib.rs
const PROGRAM_ID = '3Es13GXc4qwttE6uSgAAfi1zvBD3qzLkZpY21KfT3sZ3';
const RPC_URL = 'https://mainnet.helius-rpc.com/?api-key=5a9a7cb2-8ee9-4656-bd60-6b5b11a3e92d';
const HELIUS_API = 'https://mainnet.helius-rpc.com/?api-key=5a9a7cb2-8ee9-4656-bd60-6b5b11a3e92d';
const RPC_FALLBACKS = [];

async function rpcFetch(body) {
  const r = await fetch(RPC_URL, {method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(body)});
  if (r.ok) return r.json();
  return null;
}
const GHOST_SEED = 'ghost';
const VAULT_SEED = 'vault';

const ghostState = {
  connected: false,
  walletName: null,
  walletAddress: null,
  publicKey: null,
  provider: null,
  ghostPda: null,
  vaultPda: null,
  ghostStakeVault: null,
  ghost: {
    status: 'none',
    lastHeartbeat: null,
    intervalSeconds: 365 * 86400,
    gracePeriodSeconds: 30 * 86400,
    awakenedAt: null,
    executed: false,
    stakedGhost: 0,
    pingCount: 0,
    vaultBalance: 0,
    recoveryWallet: null,
    beneficiaries: []
  }
};

// ‚îÄ‚îÄ‚îÄ Session persistence (survives refresh, not new tab) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function _sessionKey(addr) {
  // Per-wallet key so switching wallets loads correct state
  return 'ghostSession_' + (addr || ghostState.publicKey || ghostState.walletAddress || 'anon');
}
function saveSession() {
  // Only persist wallet identity + PDAs + UI prefs
  // All chain state (beneficiaries, vault tokens, activity log) is rebuilt from RPC on connect
  try {
    const key = _sessionKey();
    const s = {
      walletName: ghostState.walletName,
      walletAddress: ghostState.walletAddress,
      publicKey: ghostState.publicKey,
      ghostPda: ghostState.ghostPda,
      vaultPda: ghostState.vaultPda,
      ghostStakeVault: ghostState.ghostStakeVault || null,
      lastPage: _currentPage || 'overview',
    };
    localStorage.setItem(key, JSON.stringify(s));
    localStorage.setItem('ghostLastWallet', ghostState.publicKey || ghostState.walletAddress || '');
  } catch(e) {}
}

function loadSession() {
  // Restore wallet identity + PDAs only; all chain state fetched fresh from RPC
  // Returns false (no auto-restore) if user was never connected
  try {
    const lastWallet = localStorage.getItem('ghostLastWallet') || '';
    if (!lastWallet) return false; // never connected ‚Äî don't auto-open dashboard
    const key = _sessionKey(lastWallet);
    const raw = localStorage.getItem(key);
    if (!raw) return false;
    const s = JSON.parse(raw);
    // Require both walletAddress and publicKey ‚Äî absence means session is stale or corrupt
    if (!s.walletAddress || !s.publicKey) return false;
    ghostState.walletName = s.walletName || '';
    ghostState.walletAddress = s.walletAddress || '';
    ghostState.publicKey = s.publicKey || '';
    ghostState.connected = true;
    if (s.ghostPda) ghostState.ghostPda = s.ghostPda;
    if (s.vaultPda) ghostState.vaultPda = s.vaultPda;
    if (s.ghostStakeVault) ghostState.ghostStakeVault = s.ghostStakeVault;
    return s.lastPage || 'overview';
  } catch(e) { return false; }
}

let _currentPage = 'overview';

// ‚îÄ‚îÄ‚îÄ Marketing site utils ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const reveals = document.querySelectorAll('.reveal');
const observer = new IntersectionObserver((entries) => {
  entries.forEach((e, i) => { if (e.isIntersecting) setTimeout(() => e.target.classList.add('visible'), i * 80); });
}, { threshold: 0.08 });
reveals.forEach(el => observer.observe(el));

setInterval(() => {
  const g = document.getElementById('ghostCount');
  if (g && Math.random() > 0.5) g.textContent = (parseInt(g.textContent.replace(',','')) + 1).toLocaleString();
}, 3500);

// ‚îÄ‚îÄ‚îÄ Unified Live Price Cache ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// Jupiter Price API: free, no key, covers SOL + all SPL tokens by mint
const PRICE_CACHE = {}; // { mint: usdPrice }
const SOL_MINT   = 'So11111111111111111111111111111111111111112';
const USDC_MINT  = 'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v';
const USDT_MINT  = 'Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB';

// Map symbol ‚Üí mint for tokens we always want to price
const SYMBOL_TO_MINT = {
  'SOL':   SOL_MINT,
  'wSOL':  SOL_MINT,
  'USDC':  USDC_MINT,
  'USDT':  USDT_MINT,
  'mSOL':  'mSoLzYCxHdYgdzU16g5QSh3i5K3z3KZK7ytfqcJm7So',
  'bSOL':  'bSo13r4TkiE4KumL71LsHTPpL2euBYLFx6h9HP3piy1',
  'ETH':   '7vfCXTUXx5WJV5JADk17DUJ4ksgau7utNKj4b963voxs',
  'BONK':  'DezXAZ8z7PnrnRJjz3wXBoRgixCa6xjnB7YaB1pPB263',
  'native': SOL_MINT, // native SOL
};

let ghostPriceUsd = 0;

function getTokenPrice(token) {
  // Mint-direct lookup first (handles 'native' for SOL)
  if (token.mint && PRICE_CACHE[token.mint] != null) return PRICE_CACHE[token.mint];
  // Symbol fallback only if no mint match
  const mappedMint = SYMBOL_TO_MINT[token.symbol];
  if (mappedMint && PRICE_CACHE[mappedMint] != null) return PRICE_CACHE[mappedMint];
  return 0;
}

function tokenColor(symbol) {
  if (!symbol) return 'var(--accent)';
  const s = symbol.toUpperCase();
  if (s === 'SOL' || s === 'WSOL' || s === 'MSOL' || s === 'BSOL') return '#9966ff';
  if (s === 'USDC' || s === 'USDT' || s === 'DAI') return '#33ff99';
  if (s === '$GHOST' || s === 'GHOST') return '#c0a0ff';
  if (s === 'ETH' || s === 'WETH') return '#a8b4ff';
  if (s === 'BTC' || s === 'WBTC') return '#ffaa44';
  if (s === 'BONK') return '#ff9933';
  // SPL / meme / unknown = warm amber
  return '#ffcc66';
}

// GHOST_MINT declared before fetchAllPrices to avoid TDZ error
const GHOST_MINT = 'k4MxJAdy22Dgd2UTQ9p3etbnaSLUH1q5cEfSRi6pump';
// DBD is the placeholder pump.fun token used during development, to be replaced by $GHOST
// It is only valid for: initial stake (initializeGhost) and 50% burn-back on abandonGhost
// It must NOT appear in vault holdings, bene picker, deposit, or guardian withdraw
const DBD_MINT = 'DBDr6LXRx8cHvdgzGmZkD2Hf8JkDhU3VvqvhVvQpump';
function isProtocolMint(mint) {
  if (!mint) return false;
  return mint === GHOST_MINT || mint === DBD_MINT;
}

async function fetchAllPrices() {
  // Jupiter Price API v3 via api.jup.ag (authenticated)
  const coreMints = [
    SOL_MINT,   // SOL
    USDC_MINT,  // USDC
    USDT_MINT,  // USDT
    'mSoLzYCxHdYgdzU16g5QSh3i5K3z3KZK7ytfqcJm7So', // mSOL
    'bSo13r4TkiE4KumL71LsHTPpL2euBYLFx6h9HP3piy1', // bSOL
    'DezXAZ8z7PnrnRJjz3wXBoRgixCa6xjnB7YaB1pPB263', // BONK
    '7vfCXTUXx5WJV5JADk17DUJ4ksgau7utNKj4b963voxs', // wETH
  ];

  // Also include any wallet/vault token mints
  const walletMints = [...(ghostState.walletTokens||[]), ...(ghostState.vaultTokens||[])]
    .map(t => t.mint).filter(m => m && m !== 'native');

  const allMints = [...new Set([...coreMints, ...walletMints])].filter(m => m !== GHOST_MINT);

  try {
    // Jupiter v1 ‚Äî open API, no auth, works from file:// and all origins
    // Try Helius price oracle first (works from any origin via Helius RPC key)
    // then fallback to DexScreener SOL price + hardcode
    let solFetched = false;
    try {
      const r = await fetch(`https://api.jup.ag/price/v3?ids=${allMints.join(',')}`, {
        headers: { 'x-api-key': '8bef3e9f-8dca-495b-8b42-6df346fda48e' }
      });
      if (r.ok) {
        const data = await r.json();
        for (const [id, info] of Object.entries(data || {})) {
          if (info?.usdPrice) {
            PRICE_CACHE[id] = parseFloat(info.usdPrice);
            if (id === SOL_MINT) { PRICE_CACHE['native'] = parseFloat(info.usdPrice); solFetched = true; }
          }
        }
        console.log('[Ghost] Prices loaded via Jupiter v3. SOL:', PRICE_CACHE[SOL_MINT]);
      }
    } catch(e) {}

    // Fallback: CoinGecko simple price (no key, CORS-open)
    if (!solFetched) {
      try {
        const r = await fetch('https://api.coingecko.com/api/v3/simple/price?ids=solana&vs_currencies=usd');
        if (r.ok) {
          const d = await r.json();
          const p = d?.solana?.usd;
          if (p > 0) { PRICE_CACHE[SOL_MINT] = p; PRICE_CACHE['native'] = p; solFetched = true; console.log('[Ghost] SOL via CoinGecko:', p); }
        }
      } catch(e) {}
    }
    // Last resort hardcode (SOL ~$170 at time of writing)
    if (!solFetched) { PRICE_CACHE[SOL_MINT] = 170; PRICE_CACHE['native'] = 170; console.log('[Ghost] SOL hardcoded fallback'); }
  } catch(e) {
    console.log('[Ghost] Jupiter v1 failed:', e.message);
    // Hardcode reasonable fallbacks
    // SOL fallback handled above in solFetched block
  }

  // USDC/USDT always $1
  PRICE_CACHE[USDC_MINT] = 1.0;
  PRICE_CACHE[USDT_MINT] = 1.0;

  // $GHOST via DexScreener
  await fetchGhostTokenPrice();

  // Debounced renders ‚Äî never overlap with quickPriceRefresh
  debounceRender('priceRender', () => {
    renderVaultOverview();
    if (document.getElementById('db-page-vault')?.classList.contains('active')) renderVaultHoldings();
    updateMarketingTicker();
  }, 60);
  fetchPumpFunData();
}

async function fetchGhostTokenPrice() {
  try {
    const res = await fetch(`https://api.dexscreener.com/latest/dex/tokens/${GHOST_MINT}`);
    const data = await res.json();
    // Handle both { pairs: [...] } and { pair: {...} }
    const pairs = data?.pairs || (data?.pair ? [data.pair] : []);
    const pair = pairs.sort((a,b) => (b.liquidity?.usd||0)-(a.liquidity?.usd||0))[0];
    console.log('[Ghost] DexScreener GHOST pairs:', pairs.length, 'priceUsd:', pair?.priceUsd, 'mcap:', pair?.marketCap, 'vol:', pair?.volume?.h24, 'change:', pair?.priceChange?.h24);
    if (!pair) return;
    const fmt = (n) => n >= 1e6 ? '$' + (n/1e6).toFixed(2) + 'M' : n >= 1e3 ? '$' + (n/1e3).toFixed(1) + 'K' : '$' + n.toFixed(2);

    if (pair.priceUsd) {
      ghostPriceUsd = parseFloat(pair.priceUsd);
      PRICE_CACHE[GHOST_MINT] = ghostPriceUsd;
      const priceEl = document.getElementById('price');
      if (priceEl) priceEl.textContent = ghostPriceUsd < 0.001 ? '$' + ghostPriceUsd.toFixed(8) : '$' + ghostPriceUsd.toFixed(6);
    }
    const mcap = pair.marketCap || pair.fdv || 0;
    const vol = pair.volume?.h24 || 0;
    const change = pair.priceChange?.h24 ?? null;

    const mcapEl = document.getElementById('mcap');
    if (mcapEl) mcapEl.textContent = mcap ? fmt(mcap) : '‚Äî';
    const volEl = document.getElementById('vol24');
    if (volEl) volEl.textContent = vol ? fmt(vol) : '‚Äî';
    const changeEl = document.getElementById('priceChange');
    if (changeEl) {
      changeEl.textContent = change !== null ? (change >= 0 ? '+' : '') + change.toFixed(2) + '%' : '‚Äî';
      changeEl.className = 'ticker-value ' + (change >= 0 ? 'up' : 'down');
    }
  } catch(e) { console.log('[Ghost] DexScreener error:', e.message); }
}

function updateMarketingTicker() {
  const solPrice = PRICE_CACHE[SOL_MINT];
  const fmt = (n) => n >= 1e6 ? '$' + (n/1e6).toFixed(2) + 'M' : n >= 1e3 ? '$' + (n/1e3).toFixed(1) + 'K' : '$' + n.toFixed(2);

  // $GHOST price from DexScreener
  if (ghostPriceUsd > 0) {
    const priceEl = document.getElementById('price');
    if (priceEl) priceEl.textContent = ghostPriceUsd < 0.001 ? '$' + ghostPriceUsd.toFixed(8) : '$' + ghostPriceUsd.toFixed(6);
  }

  // SOL price shown in ticker if we have it
  if (solPrice) {
    const solEl = document.getElementById('solPrice');
    if (solEl) solEl.textContent = '$' + solPrice.toFixed(2);
  }
}

// Defer initial price fetch so page renders first
setTimeout(fetchAllPrices, 500);

// ‚îÄ‚îÄ‚îÄ Render debounce ‚Äî prevents multiple rapid re-renders from overlapping ‚îÄ‚îÄ
const _renderDebounce = {};
function debounceRender(key, fn, delay = 80) {
  clearTimeout(_renderDebounce[key]);
  _renderDebounce[key] = setTimeout(fn, delay);
}

// ‚îÄ‚îÄ‚îÄ Smart auto-refresh ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// Prices only (fast, no logo fetching): every 8 seconds
// Full pump.fun metadata: every 30s (handled inside fetchAllPrices already)
let _priceRefreshPaused = false;
let _lastPriceRefresh = Date.now();

async function quickPriceRefresh() {
  if (_priceRefreshPaused) return;
  if (document.visibilityState !== 'visible') return; // don't hit APIs when tab hidden
  _lastPriceRefresh = Date.now();

  // Fetch Jupiter prices for all known mints
  const allMints = [...new Set([
    SOL_MINT, USDC_MINT, USDT_MINT,
    ...[...(ghostState.walletTokens||[]), ...(ghostState.vaultTokens||[])]
      .map(t => t.mint).filter(m => m && m !== 'native')
  ])];

  try {
    const r = await fetch(`https://api.jup.ag/price/v3?ids=${allMints.join(',')}`, {
      headers: { 'x-api-key': '8bef3e9f-8dca-495b-8b42-6df346fda48e' }
    });
    if (r.ok) {
      const data = await r.json();
      for (const [id, info] of Object.entries(data || {})) {
        if (info?.usdPrice) {
          PRICE_CACHE[id] = parseFloat(info.usdPrice);
          if (id === SOL_MINT) PRICE_CACHE['native'] = parseFloat(info.usdPrice);
        }
      }
      PRICE_CACHE[USDC_MINT] = 1.0;
      PRICE_CACHE[USDT_MINT] = 1.0;

      // Debounce renders ‚Äî avoid overlapping DOM writes
      debounceRender('priceRender', () => {
        renderVaultOverview();
        if (document.getElementById('db-page-vault')?.classList.contains('active')) renderVaultHoldings();
        updateMarketingTicker();
        // showNotif('‚ü≥ prices updated', 'info', 1000); // disabled
      }, 60);
    }
  } catch(e) { /* silent ‚Äî don't spam errors on quick refresh */ }
}

setInterval(quickPriceRefresh, 8000);
// Full refresh (logos + slow pump tokens) every 30s
setInterval(fetchAllPrices, 30000);

// ‚îÄ‚îÄ‚îÄ DexScreener for $GHOST marketing ticker ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

async function fetchTokenPrice() {
  // Legacy wrapper ‚Äî now handled by fetchAllPrices
  await fetchGhostTokenPrice();
  try {
    const res = await fetch(`https://api.dexscreener.com/latest/dex/tokens/${GHOST_MINT}`);
    const data = await res.json();
    // DexScreener returns either { pairs: [...] } or { pair: {...} } depending on endpoint
    const pairs = data?.pairs || (data?.pair ? [data.pair] : []);
    const pair = pairs.sort((a,b) => (b.liquidity?.usd||0)-(a.liquidity?.usd||0))[0];
    const fmt = (n) => n >= 1e6 ? '$' + (n/1e6).toFixed(2) + 'M' : n >= 1e3 ? '$' + (n/1e3).toFixed(1) + 'K' : '$' + n.toFixed(2);
    console.log('[Ghost] DexScreener ticker pairs:', pairs.length, 'pair keys:', pair ? Object.keys(pair) : 'none');
    if (pair) {
      const price = parseFloat(pair.priceUsd || 0);
      const mcap = pair.marketCap || pair.fdv || 0;
      const change = pair.priceChange?.h24 ?? null;
      const vol = pair.volume?.h24 || 0;
      const priceEl = document.getElementById('price');
      if (priceEl) priceEl.textContent = price < 0.001 ? '$' + price.toFixed(8) : '$' + price.toFixed(6);
      const mcapEl = document.getElementById('mcap');
      if (mcapEl) mcapEl.textContent = mcap ? fmt(mcap) : '‚Äî';
      const volEl = document.getElementById('vol24');
      if (volEl) volEl.textContent = vol ? fmt(vol) : '‚Äî';
      const changeEl = document.getElementById('priceChange');
      if (changeEl) {
        changeEl.textContent = change !== null ? (change >= 0 ? '+' : '') + change.toFixed(2) + '%' : '‚Äî';
        changeEl.className = 'ticker-value ' + (change >= 0 ? 'up' : 'down');
      }
    } else {
      ['price','mcap','priceChange','vol24'].forEach(id => { const el = document.getElementById(id); if(el) el.textContent = '‚Äî'; });
      const priceEl = document.getElementById('price');
      if (priceEl) priceEl.textContent = 'Not listed';
    }
  } catch(e) { console.log('DexScreener error:', e); }
  renderVaultOverview();
}

function copyContract() {
  const addr = document.getElementById('contractAddr').textContent;
  navigator.clipboard?.writeText(addr).catch(() => {});
  showNotif('Contract address copied to clipboard');
}

function showNotif(msg, type = '', duration = 3500) {
  const n = document.getElementById('notif');
  n.textContent = msg;
  n.className = 'notif show' + (type ? ' ' + type : '');
  clearTimeout(n._timer);
  n._timer = setTimeout(() => { n.className = 'notif'; }, duration);
}

// ‚îÄ‚îÄ‚îÄ Wallet Modal ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function openModal() { document.getElementById('walletModal').classList.add('open'); }
function closeModal() { document.getElementById('walletModal').classList.remove('open'); }

// ‚îÄ‚îÄ‚îÄ Ghost-styled confirm dialog ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
let _ghostConfirmResolve = null;
function ghostConfirm({ icon='üëª', title='Confirm', message='', okLabel='CONFIRM', danger=false }={}) {
  return new Promise(resolve => {
    _ghostConfirmResolve = resolve;
    document.getElementById('ghostConfirmIcon').textContent = icon;
    document.getElementById('ghostConfirmTitle').textContent = title;
    document.getElementById('ghostConfirmMsg').textContent = message;
    const btn = document.getElementById('ghostConfirmOkBtn');
    btn.textContent = okLabel;
    if (danger) {
      btn.style.cssText = 'font-family:\'Share Tech Mono\',monospace;font-size:11px;letter-spacing:0.1em;padding:9px 22px;cursor:pointer;background:rgba(255,51,102,0.12);border:1px solid rgba(255,51,102,0.45);color:#ff6688;transition:all 0.2s';
    } else {
      btn.style.cssText = 'font-family:\'Share Tech Mono\',monospace;font-size:11px;letter-spacing:0.1em;padding:9px 22px;cursor:pointer;background:rgba(102,51,255,0.15);border:1px solid rgba(102,51,255,0.5);color:#c0a0ff;transition:all 0.2s';
    }
    const _gcm = document.getElementById('ghostConfirmModal'); _gcm.style.display='flex';
  });
}
function _ghostConfirmAccept() {
  document.getElementById('ghostConfirmModal').style.display='none';
  if (_ghostConfirmResolve) { _ghostConfirmResolve(true); _ghostConfirmResolve = null; }
}
function _ghostConfirmReject() {
  document.getElementById('ghostConfirmModal').style.display='none';
  if (_ghostConfirmResolve) { _ghostConfirmResolve(false); _ghostConfirmResolve = null; }
}
document.getElementById('walletModal').addEventListener('click', function(e) {
  if (e.target === this) closeModal();
});

async function connectWallet(name) {
  closeModal();
  let provider = null;
  if (name === 'Phantom') {
    provider = window.phantom?.solana || window.solana;
  } else if (name === 'Solflare') {
    provider = window.solflare;
  } else if (name === 'Backpack') {
    provider = window.backpack?.solana || window.xnft?.solana;
  } else if (name === 'OKX') {
    provider = window.okxwallet?.solana;
  }
  // No silent fallthrough ‚Äî if the chosen wallet isn't installed, say so clearly
  if (!provider) {
    showNotif('\u26A0\uFE0F ' + name + ' not detected. Please install it and refresh.', 'error');
    return;
  }
  try {
    showNotif('Connecting to ' + name + '...', '');
    // Always disconnect first to force the wallet to show the approve popup
    try { await provider.disconnect(); } catch(e) {}
    // Small delay so Phantom processes the disconnect before we call connect
    await new Promise(r => setTimeout(r, 200));
    // onlyIfTrusted: false ‚Üí always shows the approve popup
    const resp = await provider.connect({ onlyIfTrusted: false });
    const pubkey = resp.publicKey.toString();
    // Sign BEFORE any UI update ‚Äî cancelling sign leaves UI untouched (not connected)
    try {
      const authMsg = new TextEncoder().encode('Authenticate with GHOST Protocol ‚Äî ' + new Date().toISOString());
      await provider.signMessage(authMsg, 'utf8');
    } catch(signErr) {
      try { await provider.disconnect(); } catch(e) {}
      throw new Error('Authentication cancelled ‚Äî approve the sign request to connect.');
    }
    // Sign succeeded ‚Äî update state and UI
    ghostState.connected = true;
    ghostState.walletName = name;
    ghostState.walletAddress = pubkey.slice(0,4) + '...' + pubkey.slice(-4);
    ghostState.publicKey = pubkey;
    ghostState.provider = provider;
    const _onAccountChange = () => {
      showNotif('üëª Wallet account changed ‚Äî please reconnect.', '');
      disconnectWallet();
    };
    try { provider.off?.('accountChanged', _onAccountChange); provider.on?.('accountChanged', _onAccountChange); } catch(e) {}
    await deriveAndSetPDAs(pubkey);
    const btn = document.getElementById('walletBtn');
    btn.textContent = '‚óè ' + ghostState.walletAddress;
    btn.classList.add('connected');
    btn.onclick = openDashboard;
    document.getElementById('navDashboardLink').classList.add('visible');
    document.getElementById('panelWalletAddr').textContent = ghostState.walletAddress;
    document.getElementById('navDisconnectBtn').style.display = 'inline-block';
    const wsEl = document.getElementById('walletStatus');
    if (wsEl) wsEl.textContent = ghostState.walletAddress + ' ‚Äî Heartbeat Active';
    showNotif('\u2713 ' + name + ' connected!', 'green');
    saveSession();
    await fetchGhostAccount();
    setTimeout(() => {
      openDashboard();
      if (ghostState.ghost.status !== 'none') dbShowPage('overview', document.getElementById('nav-overview'));
    }, 600);
  } catch (err) {
    console.error('Wallet connect error:', err);
    showNotif('Connection failed: ' + (err.message || err), 'error');
  }
}

function connectWalletDemo(name) {
  ghostState.connected = true;
  ghostState.walletName = name + ' (demo)';
  const hex = () => Math.random().toString(16).substr(2, 4);
  const addr = hex() + hex() + hex() + hex() + hex() + hex() + hex() + hex();
  ghostState.walletAddress = addr.slice(0,4) + '...' + addr.slice(-4);
  ghostState.publicKey = addr;
  ghostState.ghost.status = 'none'; // must initialize first

  const btn = document.getElementById('walletBtn');
  btn.textContent = '‚óè ' + ghostState.walletAddress + ' [demo]';
  btn.classList.add('connected');
  btn.onclick = openDashboard;
  document.getElementById('navDashboardLink').classList.add('visible');
  document.getElementById('panelWalletAddr').textContent = ghostState.walletAddress + ' (demo)';
  document.getElementById('navDisconnectBtn').style.display = 'inline-block';
  const wsEl = document.getElementById('walletStatus');
  if (wsEl) wsEl.textContent = ghostState.walletAddress + ' ‚Äî Heartbeat Active';

  showNotif('‚úì Demo mode ‚Äî no wallet extension detected', 'green');
  saveSession();
  setTimeout(openDashboard, 600);
}

// ‚îÄ‚îÄ‚îÄ PDA Derivation ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
async function deriveAndSetPDAs(walletAddress) {
  try {
    // Use Solana web3.js from CDN to derive PDAs
    const { PublicKey } = solanaWeb3;
    const wallet = new PublicKey(walletAddress);
    const programId = new PublicKey(PROGRAM_ID);
    
    const [ghostPda] = PublicKey.findProgramAddressSync(
      [new TextEncoder().encode(GHOST_SEED), wallet.toBytes()],
      programId
    );
    const [vaultPda] = PublicKey.findProgramAddressSync(
      [new TextEncoder().encode(VAULT_SEED), wallet.toBytes()],
      programId
    );
    // Stake vault: the specific token account PDA holding staked $GHOST (seeds: ["stake_vault", owner])
    // It is protocol-locked and excluded from user vault display and withdrawals
    const [stakeVaultPda] = PublicKey.findProgramAddressSync(
      [new TextEncoder().encode('stake_vault'), wallet.toBytes()],
      programId
    );

    ghostState.ghostPda = ghostPda.toString();
    ghostState.vaultPda = vaultPda.toString();
    ghostState.ghostStakeVault = stakeVaultPda.toString();
    console.log('Ghost PDA:', ghostState.ghostPda);
    console.log('Vault PDA:', ghostState.vaultPda);
    console.log('Stake Vault:', ghostState.ghostStakeVault);
  } catch (err) {
    console.error('PDA derivation error:', err);
  }
}

function retryTokenData() {
  pumpFunFetched.clear();
  showNotif('Refreshing token data...', '');
  fetchAllPrices();
}

// ‚îÄ‚îÄ‚îÄ Unknown SPL token: price + logo ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const pumpFunFetched = new Set(); // logo fetched
const priceFetched = new Set(); // price fetched
const METAPLEX_PROGRAM = 'metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s';

// Pure-JS base58 decode
const B58_CHARS = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';
function b58Decode(s) {
  let n = BigInt(0);
  for (const c of s) n = n * 58n + BigInt(B58_CHARS.indexOf(c));
  // Convert to bytes, preserving leading zeros
  const bytes = [];
  let tmp = n;
  while (tmp > 0n) { bytes.unshift(Number(tmp & 0xffn)); tmp >>= 8n; }
  // Leading '1's in b58 = leading 0x00 bytes
  let leadingZeros = 0;
  for (const c of s) { if (c === '1') leadingZeros++; else break; }
  return new Uint8Array([...new Array(leadingZeros).fill(0), ...bytes]);
}

function b58Encode(bytes) {
  let n = BigInt(0);
  for (const b of bytes) n = n * 256n + BigInt(b);
  let result = '';
  while (n > 0n) { const r = Number(n % 58n); n /= 58n; result = B58_CHARS[r] + result; }
  let leadingOnes = '';
  for (const b of bytes) { if (b === 0) leadingOnes += '1'; else break; }
  return leadingOnes + (result || B58_CHARS[0]);
}

async function sha256(data) {
  return new Uint8Array(await crypto.subtle.digest('SHA-256', data));
}

// Derive Metaplex metadata PDA ‚Äî pure JS, no web3.js dependency
async function getMetadataPda(mintStr) {
  try {
    // Try web3.js first if loaded (most reliable)
    if (solanaWeb3?.PublicKey) {
      const [pda] = solanaWeb3.PublicKey.findProgramAddressSync(
        [
          new TextEncoder().encode('metadata'),
          b58Decode(METAPLEX_PROGRAM),
          b58Decode(mintStr)
        ],
        new solanaWeb3.PublicKey(METAPLEX_PROGRAM)
      );
      return pda.toString();
    }

    // Pure-JS fallback: SHA256-based PDA search
    const progBytes  = b58Decode(METAPLEX_PROGRAM);
    const mintBytes  = b58Decode(mintStr);
    const seedMeta   = new TextEncoder().encode('metadata');
    const seedPDA    = new TextEncoder().encode('ProgramDerivedAddress');

    for (let nonce = 255; nonce >= 0; nonce--) {
      // hash = SHA256(seeds... || nonce || program_id || "ProgramDerivedAddress")
      const combined = new Uint8Array([
        ...seedMeta, ...progBytes, ...mintBytes,
        nonce,
        ...progBytes,
        ...seedPDA
      ]);
      const hash = await sha256(combined);
      // Valid PDA must NOT be on ed25519 curve
      // Quick check: if top bit of last byte is 0 AND not all zeros, likely valid
      if (!isEd25519Point(hash)) {
        return b58Encode(hash);
      }
    }
  } catch(e) { console.log('[Ghost] PDA err:', e.message); }
  return null;
}

// Rough ed25519 curve check ‚Äî good enough for PDA finding
function isEd25519Point(bytes) {
  // ed25519 points: high bit of last byte is the sign bit
  // If the last byte has bit 7 set AND other conditions ‚Äî simplified rejection
  // In practice, nearly all SHA256 outputs are NOT on curve, so just return false
  // (web3.js does the real check; this fallback just needs to find ONE valid PDA)
  return false; // accept first hash as PDA candidate when web3.js unavailable
}

// Parse URI from raw Metaplex metadata bytes
function parseMetaplexUri(bytes) {
  try {
    // Layout: key(1) + update_auth(32) + mint(32) + name_len(4) + name + sym_len(4) + sym + uri_len(4) + uri
    let offset = 1 + 32 + 32;
    const view = new DataView(bytes.buffer);
    const nameLen = view.getUint32(offset, true); offset += 4 + nameLen;
    const symLen  = view.getUint32(offset, true); offset += 4 + symLen;
    const uriLen  = view.getUint32(offset, true); offset += 4;
    const uri = new TextDecoder().decode(bytes.slice(offset, offset + uriLen)).replace(/\0/g, '').trim();
    return (uri.startsWith('http') || uri.startsWith('ipfs')) ? uri : null;
  } catch(e) { return null; }
}

// Normalise any IPFS/Arweave URL to a reliable gateway
function normaliseUrl(url) {
  if (!url) return url;
  // Extract raw CID and use a working public gateway (cf-ipfs.com is dead)
  const IPFS_GW = 'https://gateway.pinata.cloud/ipfs/';
  return url
    .replace(/^ipfs:\/\//, IPFS_GW)
    .replace(/^https:\/\/cf-ipfs\.com\/ipfs\//, IPFS_GW)
    .replace(/^https:\/\/ipfs\.io\/ipfs\//, IPFS_GW)
    .replace(/^https:\/\/nftstorage\.link\/ipfs\//, IPFS_GW)
    .replace(/^https:\/\/w3s\.link\/ipfs\//, IPFS_GW)
    .replace(/^https:\/\/dweb\.link\/ipfs\//, IPFS_GW);
}

// ‚îÄ‚îÄ Diagnostic: call window.diagToken('mint') from console to see raw API data ‚îÄ‚îÄ
window.diagToken = async function(mint) {
  const solPrice = PRICE_CACHE[SOL_MINT] || 170;
  console.log('=== DIAG for', mint, '===');
  console.log('SOL price:', solPrice);

  const dex = await fetch(`https://api.dexscreener.com/latest/dex/tokens/${mint}`).then(r=>r.json()).catch(e=>({error:e.message}));
  console.log('DexScreener pairs:', dex?.pairs?.length, dex?.pairs?.[0] ? {priceUsd: dex.pairs[0].priceUsd, priceNative: dex.pairs[0].priceNative, liq: dex.pairs[0].liquidity?.usd, dex: dex.pairs[0].dexId, imageUrl: dex.pairs[0]?.info?.imageUrl} : 'none');

  const jup = await fetch(`https://api.jup.ag/price/v3?ids=${mint}`, {headers:{'x-api-key':'8bef3e9f-8dca-495b-8b42-6df346fda48e'}}).then(r=>r.json()).catch(e=>({error:e.message}));
  console.log('Jupiter v3:', jup?.[mint]);

  const helius = await fetch(HELIUS_API, {method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({jsonrpc:'2.0',id:'diag',method:'getAsset',params:{id:mint}})}).then(r=>r.json()).catch(e=>({error:e.message}));
  const asset = helius?.result;
  console.log('Helius interface:', asset?.interface, 'json_uri:', asset?.content?.json_uri, 'image:', asset?.content?.links?.image);

  const largest = await fetch(RPC_URL, {method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({jsonrpc:'2.0',id:'l',method:'getTokenLargestAccounts',params:[mint]})}).then(r=>r.json()).catch(e=>({error:e.message}));
  console.log('Largest accounts:', largest?.result?.value?.slice(0,3));
  console.log('=== END DIAG ===');
};

async function fetchPumpFunData() {
  const solPrice = PRICE_CACHE[SOL_MINT] || 170;

  const allTokens = [...(ghostState.walletTokens||[]), ...(ghostState.vaultTokens||[])];
  const candidates = [...new Map(
    allTokens.filter(t =>
        t.mint && t.mint.length > 20 && t.mint !== 'native'
        && t.mint !== SOL_MINT && t.mint !== USDC_MINT && t.mint !== USDT_MINT
        && (!pumpFunFetched.has(t.mint) || !priceFetched.has(t.mint))
      ).map(t => [t.mint, t])
  ).values()];

  if (candidates.length === 0) return;
  console.log('[Ghost] fetchPumpFunData candidates:', candidates.map(t=>t.symbol+'('+t.mint.slice(0,8)+'...)'));

  await Promise.all(candidates.map(async token => {
    const updateAll = (fn) =>
      [...(ghostState.walletTokens||[]), ...(ghostState.vaultTokens||[])]
        .filter(t => t.mint === token.mint).forEach(fn);

    // ‚îÄ‚îÄ Source 1: DexScreener pairs ‚îÄ‚îÄ
    try {
      const r = await fetch(`https://api.dexscreener.com/latest/dex/tokens/${token.mint}`);
      if (r.ok) {
        const d = await r.json();
        console.log('[Ghost] DexScreener raw pairs count:', d?.pairs?.length, 'for', token.symbol);
        // Try all pairs, pick best (highest liquidity)
        const pairs = (d?.pairs || []).sort((a,b) => (b.liquidity?.usd||0)-(a.liquidity?.usd||0));
        for (const pair of pairs) {
          console.log('[Ghost] Pair:', pair.dexId, 'priceUsd:', pair.priceUsd, 'priceNative:', pair.priceNative, 'liq:', pair.liquidity?.usd);
          if (pair.priceUsd && parseFloat(pair.priceUsd) > 0) {
            PRICE_CACHE[token.mint] = parseFloat(pair.priceUsd);
            console.log('[Ghost] DexScreener priceUsd:', token.symbol, PRICE_CACHE[token.mint]);
            break;
          }
          // priceNative is SOL price ‚Äî convert to USD
          if (pair.priceNative && parseFloat(pair.priceNative) > 0 && solPrice > 0) {
            PRICE_CACHE[token.mint] = parseFloat(pair.priceNative) * solPrice;
            console.log('[Ghost] DexScreener priceNative‚ÜíUSD:', token.symbol, PRICE_CACHE[token.mint]);
            break;
          }
        }
        const logo = pairs[0]?.info?.imageUrl || pairs[0]?.info?.header;
        if (logo) { updateAll(t => { t.logoUrl = logo; }); console.log('[Ghost] DexScreener logo:', logo); }
      }
    } catch(e) { console.log('[Ghost] DexScreener err:', e.message); }

    // ‚îÄ‚îÄ Source 2: DexScreener token-profiles endpoint (logo stored separately from pairs) ‚îÄ‚îÄ
    // This has the logo even for zero-volume tokens since it's set when DEX screener is paid
    if (!token.logoUrl) {
      try {
        const r = await fetch(`https://api.dexscreener.com/token-profiles/latest/v1`);
        if (r.ok) {
          const profiles = await r.json();
          const match = Array.isArray(profiles) && profiles.find(p => p.tokenAddress === token.mint);
          if (match?.icon) {
            updateAll(t => { t.logoUrl = match.icon; });
            console.log('[Ghost] DexScreener profile logo:', match.icon);
          }
        }
      } catch(e) {}

      // Also try direct token-boosts (paid dex screener tokens always have this)
      try {
        const r = await fetch(`https://api.dexscreener.com/token-boosts/latest/v1`);
        if (r.ok) {
          const boosts = await r.json();
          const match = Array.isArray(boosts) && boosts.find(p => p.tokenAddress === token.mint);
          if (match?.icon) {
            updateAll(t => { t.logoUrl = match.icon; });
            console.log('[Ghost] DexScreener boost logo:', match.icon);
          }
        }
      } catch(e) {}
    }

    // ‚îÄ‚îÄ Source 3: Helius getAsset ‚Üí json_uri ‚Üí off-chain image ‚îÄ‚îÄ
    if (!token.logoUrl) {
      try {
        const res = await fetch(HELIUS_API, {
          method: 'POST', headers: {'Content-Type':'application/json'},
          body: JSON.stringify({jsonrpc:'2.0', id:'ghost', method:'getAsset', params:{id: token.mint}})
        });
        if (res.ok) {
          const d = await res.json();
          const asset = d?.result;
          console.log('[Ghost] Helius asset interface:', asset?.interface, 'json_uri:', asset?.content?.json_uri);

          // Direct image (NFTs)
          const directImg = asset?.content?.links?.image || asset?.content?.files?.[0]?.cdn_uri;
          if (directImg) { updateAll(t => { t.logoUrl = normaliseUrl(directImg); }); }

          // Fungible tokens: fetch off-chain JSON at json_uri
          if (!token.logoUrl) {
            const jsonUri = asset?.content?.json_uri;
            if (jsonUri && (jsonUri.startsWith('http') || jsonUri.startsWith('ipfs'))) {
              const metaRes = await fetch(normaliseUrl(jsonUri));
              if (metaRes.ok) {
                const meta = await metaRes.json();
                const img = meta.image || meta.image_uri || meta.properties?.files?.[0]?.uri;
                if (img) { updateAll(t => { t.logoUrl = normaliseUrl(img); }); console.log('[Ghost] Helius image:', img); }
              }
            }
          }
          const sym = asset?.content?.metadata?.symbol;
          if (sym && token.symbol?.includes('...')) updateAll(t => { t.symbol = sym; t.name = asset?.content?.metadata?.name; });
        }
      } catch(e) { console.log('[Ghost] Helius getAsset err:', e.message); }
    }
    pumpFunFetched.add(token.mint); // logo sources exhausted

    // ‚îÄ‚îÄ Source 4: Jupiter v2 price ‚îÄ‚îÄ
    if (getTokenPrice(token) === 0) {
      try {
        const r = await fetch(`https://api.jup.ag/price/v3?ids=${token.mint}`, {
        headers: { 'x-api-key': '8bef3e9f-8dca-495b-8b42-6df346fda48e' }
      });
        if (r.ok) {
          const d = await r.json();
          const price = parseFloat(d?.[token.mint]?.usdPrice || 0);
          if (price > 0) { PRICE_CACHE[token.mint] = price; console.log('[Ghost] Jupiter v1 price:', price); }
        }
      } catch(e) {}
    }

    // ‚îÄ‚îÄ Source 5: On-chain price via token largest accounts (pool vault ratio) ‚îÄ‚îÄ
    // Works for any bonded token regardless of trading volume
    if (getTokenPrice(token) === 0) {
      try {
        // Get the largest token accounts ‚Äî pool vault holds the bulk of supply
        const largestRes = await rpcFetch({jsonrpc:'2.0',id:'lrg',method:'getTokenLargestAccounts',params:[token.mint]});
        const accounts = largestRes?.result?.value || [];
        console.log('[Ghost] Largest accounts for', token.symbol, ':', accounts.slice(0,3).map(a=>a.address.slice(0,8)+'='+a.uiAmountString));

        // Find the pool vault: a large holder whose owner is a DEX program (PumpSwap/Raydium)
        const PUMPSWAP = 'PSwapMdSai8tjrEXcxFeQth87xC4rRsa4VA5mhGhXkP';
        const RAYDIUM  = '675kPX9MHTjS2zt1qfr1NYHuzeLXfQM9H24wFSUt1Mp8';
        const WSOL     = 'So11111111111111111111111111111111111111112';

        for (const acct of accounts.slice(0, 5)) {
          const info = await rpcFetch({jsonrpc:'2.0',id:'ai',method:'getAccountInfo',
            params:[acct.address, {encoding:'jsonParsed'}]});
          const parsed = info?.result?.value?.data?.parsed?.info;
          if (!parsed) continue;
          const owner = parsed.owner;
          if (owner !== PUMPSWAP && owner !== RAYDIUM) continue;

          // This is a pool vault. Find the paired SOL/wSOL vault owned by same pool
          // The pool account = owner of this token account
          // Get all token accounts of the pool
          const poolAccts = await rpcFetch({jsonrpc:'2.0',id:'pa',method:'getTokenAccountsByOwner',
            params:[owner, {programId:'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA'}, {encoding:'jsonParsed'}]});
          const vaults = poolAccts?.result?.value || [];
          const solVault = vaults.find(v => v.account?.data?.parsed?.info?.mint === WSOL);
          const tokVault = vaults.find(v => v.account?.data?.parsed?.info?.mint === token.mint);
          const solAmt = parseFloat(solVault?.account?.data?.parsed?.info?.tokenAmount?.uiAmountString || 0);
          const tokAmt = parseFloat(tokVault?.account?.data?.parsed?.info?.tokenAmount?.uiAmountString || 0);
          console.log('[Ghost] Pool vaults ‚Äî SOL:', solAmt, token.symbol+':', tokAmt);

          if (solAmt > 0 && tokAmt > 0 && solPrice > 0) {
            const price = (solAmt / tokAmt) * solPrice;
            if (price > 0 && price < 10) {
              PRICE_CACHE[token.mint] = price;
              console.log('[Ghost] On-chain pool price:', price);
            }
          }
          break;
        }
      } catch(e) { console.log('[Ghost] On-chain price err:', e.message); }
    }
    if (getTokenPrice(token) > 0) priceFetched.add(token.mint);

    console.log('[Ghost] Final ‚Äî', token.symbol, '| price:', PRICE_CACHE[token.mint]||0, '| logo:', token.logoUrl||'none');
    // Re-render immediately once data is in
    renderVaultOverview();
    if (document.getElementById('db-page-vault')?.classList.contains('active')) renderVaultHoldings();
  }));

  populateAllPickers();
  renderVaultHoldings();
  renderVaultOverview();
}
async function fetchGhostAccount() {
  if (!ghostState.ghostPda) return;
  
  try {
    const response = await fetch(RPC_URL, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        jsonrpc: '2.0',
        id: 1,
        method: 'getAccountInfo',
        params: [ghostState.ghostPda, { encoding: 'base64' }]
      })
    });
    const data = await response.json();
    
    if (!data.result?.value) {
      ghostState.ghost.status = 'none';
      updateDashboardUI();
      showNotif('No ghost found. Initialize one to get started.', '');
      return;
    }
    
    const rawData = atob(data.result.value.data[0]);
    const bytes = new Uint8Array(rawData.length);
    for (let i = 0; i < rawData.length; i++) bytes[i] = rawData.charCodeAt(i);
    
    parseGhostAccount(bytes);
    updateDashboardUI();
    showNotif('‚úì Ghost account loaded from chain', 'green');

    // Pull on-chain tx history in the background (don't await ‚Äî non-blocking)
    fetchOnChainHistory().catch(e => console.warn('[Ghost] History fetch failed:', e));
  } catch (err) {
    console.error('Fetch ghost account error:', err);
    showNotif('Could not fetch ghost account', 'error');
  }
}

// Fetch on-chain transaction signatures for the ghost PDA and rebuild activity + ping history
const GHOST_DISC_LABELS = {
  '33ff88e28aafaed3': '\u{1F47B} Ghost summoned',
  'ad005eec4985e199': '\u{1F493} Heartbeat sent',
  '123e6e081a6af897': 'Vault Deposit',
  'b422252e9c00d3ee': 'Vault Withdrawal',
  '1690d0d70fa59d7a': '\u{1F6D1} Awakening cancelled',
  'd39335ad64b4f231': '\u{1F511} Recovery wallet updated',
  '69d66a8db4a67bee': '\u{1F3AF} Beneficiary added',
  '431b18998740ca4d': '\u274C Beneficiary removed',
  '51a633d59e549d6c': '\u2699\uFE0F Settings updated',
  'd9efe14bf40efc5b': 'Whole vault recipient set',
  '63a333690b0b3b22': 'Guardian Withdrawal',
  // v1.4 instructions
  '56e2173908f67822': '\u{1F5D1} All beneficiaries cleared',
  '7e7adb46bc7ef37e': '\u270F\uFE0F Beneficiary updated',
  '100a01cae999e4b4': '\u274C Guardian removed beneficiary',
  'eb374480b1fbb34b': '\u{1F5D1} Guardian cleared all beneficiaries',
  '62419b9a15df8b60': '\u{1F6D1} Guardian cancelled & cleared',
};
// Discriminators that indicate a guardian action (for angel icon tagging)
const GUARDIAN_DISCS = new Set([
  '63a333690b0b3b22', // recovery_withdraw
  '100a01cae999e4b4',
  'eb374480b1fbb34b',
  '62419b9a15df8b60',
]);
// v1.4 discriminator constants (used to build instructions)
const DISC_CLEAR_ALL_BENES       = [86, 226, 23, 57, 8, 246, 120, 34];
const DISC_GUARDIAN_CLEAR_ALL    = [235, 55, 68, 128, 177, 251, 179, 75];
const DISC_GUARDIAN_REMOVE_BENE  = [16, 10, 1, 202, 233, 153, 228, 180];
const DISC_GUARDIAN_CANCEL_CLEAR = [98, 65, 155, 154, 21, 223, 139, 96];
const DISC_UPDATE_BENEFICIARY    = [126, 122, 219, 70, 188, 126, 243, 126];
function b58ToDiscHex(s) {
  const B58='123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';
  let leading=0; for(const ch of s){if(ch==='1')leading++;else break;}
  let num=0n; for(const ch of s.slice(leading)){const i=B58.indexOf(ch);if(i<0)break;num=num*58n+BigInt(i);}
  const bytes=[]; while(num>0n){bytes.unshift(Number(num&0xffn));num>>=8n;}
  const full=[...new Array(leading).fill(0),...bytes];
  while(full.length<8)full.unshift(0);
  return full.slice(0,8).map(b=>b.toString(16).padStart(2,'0')).join('');
}
async function fetchOnChainHistory() {
  if (!ghostState.ghostPda) return;
  try {
    const addresses = [ghostState.ghostPda];
    if (ghostState.vaultPda) addresses.push(ghostState.vaultPda);
    const sigResults = await Promise.all(addresses.map(addr =>
      fetch(RPC_URL,{method:'POST',headers:{'Content-Type':'application/json'},
        body:JSON.stringify({jsonrpc:'2.0',id:'hist',method:'getSignaturesForAddress',
          params:[addr,{limit:50,commitment:'confirmed'}]})
      }).then(r=>r.json()).catch(()=>({result:[]}))
    ));
    const sigMap = new Map();
    for (const res of sigResults)
      for (const s of (res.result||[]))
        if (!s.err && !sigMap.has(s.signature)) sigMap.set(s.signature,s);
    const allSigs = [...sigMap.values()].sort((a,b)=>(b.blockTime||0)-(a.blockTime||0));
    if (allSigs.length===0) return;
    const sigs40 = allSigs.slice(0,40).map(s=>s.signature);
    let txList = [];
    try {
      const res = await fetch(RPC_URL,{method:'POST',headers:{'Content-Type':'application/json'},
        body:JSON.stringify({jsonrpc:'2.0',id:'batch',method:'getParsedTransactions',
          params:[sigs40,{maxSupportedTransactionVersion:0,commitment:'confirmed'}]})});
      const d = await res.json(); txList = Array.isArray(d.result)?d.result:[];
    } catch(e) {}
    if (txList.filter(Boolean).length===0) {
      for (const sig of sigs40.slice(0,20)) {
        try {
          const r=await fetch(RPC_URL,{method:'POST',headers:{'Content-Type':'application/json'},
            body:JSON.stringify({jsonrpc:'2.0',id:'tx',method:'getTransaction',
              params:[sig,{encoding:'jsonParsed',maxSupportedTransactionVersion:0}]})});
          const d=await r.json(); txList.push(d.result||null);
        } catch(e){txList.push(null);}
      }
    }
    // Decode a base58-encoded pubkey from raw instruction bytes at offset, returns short form
    function ixPubkeyShort(data58, byteOffset) {
      try {
        const B58='123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';
        let leading=0; for(const ch of data58){if(ch==='1')leading++;else break;}
        let num=0n; for(const ch of data58.slice(leading)){const i=B58.indexOf(ch);if(i<0)break;num=num*58n+BigInt(i);}
        const bytes=[]; while(num>0n){bytes.unshift(Number(num&0xffn));num>>=8n;}
        const full=[...new Array(leading).fill(0),...bytes];
        const pkBytes=full.slice(byteOffset, byteOffset+32);
        if(pkBytes.length<32||pkBytes.every(b=>b===0)) return null;
        let n=0n; for(const b of pkBytes) n=n*256n+BigInt(b);
        let r=''; let t=n; while(t>0n){const rem=Number(t%58n);r=B58[rem]+r;t=t/58n;}
        const leadOnes='1'.repeat(pkBytes.findIndex(b=>b!==0)||0);
        const pk=leadOnes+r;
        return pk.length>8 ? pk.slice(0,4)+'...'+pk.slice(-4) : pk;
      } catch(_){return null;}
    }
    function labelFromTx(tx) {
      if (!tx) return null;
      const top = tx.transaction?.message?.instructions||[];
      const inner = (tx.meta?.innerInstructions||[]).flatMap(g=>g.instructions||[]);
      let baseLabel=null, isDeposit=false, isWithdraw=false, matchHex=null, matchIx=null;
      for (const ix of [...top,...inner]) {
        if (ix.programId===PROGRAM_ID && ix.data) {
          try {
            const hex=b58ToDiscHex(ix.data);
            if (GHOST_DISC_LABELS[hex]) {
              baseLabel=GHOST_DISC_LABELS[hex]; matchHex=hex; matchIx=ix;
              isDeposit=hex==='123e6e081a6af897'; isWithdraw=hex==='b422252e9c00d3ee'; break;
            }
          } catch(e){}
        }
      }
      if (!baseLabel) return null;
      if (isDeposit||isWithdraw) {
        for (const ix of inner) {
          const p=ix.parsed;
          if (p&&(p.type==='transfer'||p.type==='transferChecked')) {
            const info=p.info||{};
            const amt=info.tokenAmount?.uiAmountString||info.amount;
            const mint=info.mint||'';
            const known=[...(ghostState.vaultTokens||[]),...(ghostState.walletTokens||[])].find(t=>t.mint===mint);
            const _wsolMint='So11111111111111111111111111111111111111112';
            const sym=known?.symbol||((mint===_wsolMint||mint==='native')?'SOL':mint?mint.slice(0,6):'');
            if (amt&&sym) {
              const n=parseFloat(amt);
              const fmt=n>=1000?n.toLocaleString(undefined,{maximumFractionDigits:2}):parseFloat(n.toPrecision(4)).toString();
              return (isDeposit?'Vault Deposit ':'Vault Withdrawal ')+fmt+' '+sym;
            }
          }
        }
      }
      // Beneficiary added/removed ‚Äî decode recipient pubkey from ix data (disc=8 bytes, recipient=next 32)
      if (matchIx && (matchHex==='69d66a8db4a67bee'||matchHex==='431b18998740ca4d')) {
        const short = ixPubkeyShort(matchIx.data, 8);
        if (short) return baseLabel + ' ¬∑ ' + short;
      }
      // Whole vault recipient set ‚Äî decode recipient from ix data (disc=8, Option tag=1, pubkey=32 ‚Üí offset 9)
      if (matchIx && matchHex==='d9efe14bf40efc5b') {
        const short = ixPubkeyShort(matchIx.data, 9);
        if (short) return 'Whole vault recipient ‚Üí ' + short;
        return 'Whole vault recipient set';
      }
      if (matchHex==='63a333690b0b3b22') {
        const _fp = tx.transaction?.message?.accountKeys?.[0]?.pubkey || tx.transaction?.message?.accountKeys?.[0] || '';
        const _fps = typeof _fp === 'string' && _fp.length > 8 ? _fp.slice(0,4)+'...'+_fp.slice(-4) : '';
        return 'Guardian Withdrawal' + (_fps ? ' ¬∑ by ' + _fps : '');
      }
      return baseLabel;
    }
    const builtActivity=[], rawPings=[];
    for (let i=0;i<txList.length;i++) {
      const tx=txList[i], s=allSigs[i];
      if (!s) continue;
      const ts=((tx?.blockTime||s.blockTime)||0)*1000;
      if (!ts) continue;
      let label=labelFromTx(tx)||'\u{1F4CB} On-chain action';
      // Check if this tx contains a guardian withdrawal disc
      let rowIcon = null;
      try {
        const allIx = [...(tx?.transaction?.message?.instructions||[]), ...(tx?.meta?.innerInstructions||[]).flatMap(g=>g.instructions||[])];
        for (const ix of allIx) {
          if (ix.programId===PROGRAM_ID && ix.data) {
            try { if (GUARDIAN_DISCS.has(b58ToDiscHex(ix.data))) { rowIcon='angel'; break; } } catch(_){}
          }
        }
      } catch(_) {}
      builtActivity.push({msg:label, tx:s.signature, ts, icon:rowIcon});
      if (label==='\u{1F493} Heartbeat sent') rawPings.push({ts,sig:s.signature});
    }
    const chronoPings=rawPings.sort((a,b)=>a.ts-b.ts);
    const builtPings=chronoPings.map((p,i)=>{
      const prev=chronoPings[i-1];
      return {num:i+1,ts:p.ts,tx:p.sig,gap:prev?formatDuration(p.ts-prev.ts):'\u2014'};
    });
    if (builtActivity.length>0){
      const _chainSigs = new Set(builtActivity.map(e=>e.tx).filter(Boolean));
      const _localOnly = (ghostState.activityLog||[]).filter(e => e._local && e.tx && !_chainSigs.has(e.tx));
      ghostState.activityLog = [..._localOnly, ...builtActivity];
      renderActivityLog();
    }
    if (builtPings.length>0){ghostState.pingHistory=[...builtPings].reverse();renderPingHistory();}
    console.log('[Ghost] History: '+builtActivity.length+' txs, '+builtPings.length+' pings');
  } catch(e){console.warn('[Ghost] fetchOnChainHistory error:',e);}
}


// Parse raw account bytes into ghostState
// Anchor account layout: 8 bytes discriminator, then fields
function parseGhostAccount(bytes) {
  const view = new DataView(bytes.buffer);
  let offset = 8; // skip discriminator

  // GhostAccount field order (matches lib.rs v1.5 exactly):
  // owner(32), recovery_wallets([Option<Pubkey>;3]=99), last_heartbeat(i64=8),
  // interval_seconds(i64=8), grace_period_seconds(i64=8),
  // awakened(bool=1), awakened_at(Option<i64>=9), executed(bool=1), executed_at(Option<i64>=9),
  // staked_ghost(u64=8), bump(u8=1), vault_bump(u8=1),
  // registered_at(i64=8), ping_count(u64=8), beneficiary_count(u8=1)

  try {
    // owner: Pubkey (32 bytes)
    offset += 32;
    // recovery_wallets: [Option<Pubkey>; 3] ‚Äî 3 slots √ó 33 bytes = 99 bytes fixed
    // Each slot: 1-byte tag (0=None, 1=Some) + 32-byte pubkey if Some
    const _B58rv = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';
    const recoveryWalletPubkeys = [];
    for (let _ri = 0; _ri < 3; _ri++) {
      const rTag = bytes[offset]; offset += 1;
      if (rTag === 1) {
        const pkBytes = bytes.slice(offset, offset + 32);
        let n = BigInt(0);
        for (const b of pkBytes) n = n * BigInt(256) + BigInt(b);
        let r = ''; let tmp = n;
        while (tmp > 0n) { const rem = tmp % 58n; r = _B58rv[Number(rem)] + r; tmp = tmp / 58n; }
        const pk = '1'.repeat(pkBytes.findIndex(b => b !== 0) === -1 ? 32 : Math.max(0, pkBytes.findIndex(b => b !== 0))) + r;
        recoveryWalletPubkeys.push(pk);
      }
      offset += 32; // always advance 32 bytes (tag already consumed above)
    }
    // last_heartbeat: i64
    const lastBeat = Number(view.getBigInt64(offset, true));
    offset += 8;
    // interval_seconds: i64
    const interval = Number(view.getBigInt64(offset, true));
    offset += 8;
    // grace_period_seconds: i64
    const grace = Number(view.getBigInt64(offset, true));
    offset += 8;
    // awakened: bool
    const awakened = bytes[offset] === 1;
    offset += 1;
    // awakened_at: Option<i64> - Borsh None=1byte, Some=9bytes
    const hasAwakenedAt = bytes[offset] === 1;
    offset += 1;
    const awakenedAt = hasAwakenedAt ? Number(view.getBigInt64(offset, true)) : null;
    if (hasAwakenedAt) offset += 8;
    // executed: bool
    const executed = bytes[offset] === 1;
    offset += 1;
    // executed_at: Option<i64> - Borsh None=1byte, Some=9bytes
    const exTag = bytes[offset]; offset += 1;
    if (exTag === 1) offset += 8;
    // staked_ghost: u64
    const staked = Number(view.getBigUint64(offset, true));
    offset += 8;
    // bump: u8, vault_bump: u8
    offset += 2;
    // registered_at: i64
    const registeredAt = Number(view.getBigInt64(offset, true));
    offset += 8;
    // ping_count: u64 (NOT u32 ‚Äî matches lib.rs pub ping_count: u64)
    const pingCount = Number(view.getBigUint64(offset, true));
    offset += 8;
    // beneficiary_count: u8
    const benefCount = bytes[offset];
    offset += 1;

    ghostState.ghost.intervalSeconds = interval;
    ghostState.ghost.gracePeriodSeconds = grace;
    // Chain is authoritative ‚Äî always use on-chain value when non-zero
    const chainHeartbeatMs = lastBeat * 1000;
    if (chainHeartbeatMs > 0) {
      ghostState.ghost.lastHeartbeat = chainHeartbeatMs;
    }
    if (recoveryWalletPubkeys.length > 0) ghostState.ghost.recoveryWallet = recoveryWalletPubkeys[0];
    ghostState.ghost.awakened = awakened;
    ghostState.ghost.awakenedAt = awakenedAt ? awakenedAt * 1000 : null;
    ghostState.ghost.executed = executed;
    ghostState.ghost.stakedGhost = staked / 1_000_000; // convert from base units to token units
    ghostState.ghost.pingCount = pingCount;
    ghostState.ghost.beneficiaryCount = benefCount;
    ghostState.ghost.registeredAt = registeredAt > 0 ? registeredAt * 1000 : null;

    // Decode beneficiaries[10] from chain ‚Äî 75 bytes each:
    // recipient(32) + amount(u64=8) + token_mint(Option<Pubkey>=33) + action(u8=1) + executed(bool=1) = 75
    const _B58c = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';
    function _bDecodePk(pkBytes) {
      let n = 0n; for (const b of pkBytes) n = n * 256n + BigInt(b);
      let r = ''; let t = n; while (t > 0n) { r = _B58c[Number(t % 58n)] + r; t = t / 58n; }
      const li = pkBytes.findIndex(b => b !== 0);
      return '1'.repeat(li < 0 ? 0 : li) + r;
    }
    const _SOL_MINT = 'So11111111111111111111111111111111111111112';
    const _chainBenefs = [];
    for (let _bi = 0; _bi < 10; _bi++) {
      const recipBytes = bytes.slice(offset, offset + 32); offset += 32;
      const amtRaw = view.getBigUint64(offset, true); offset += 8;
      const mintTag = bytes[offset]; offset += 1;
      let mintPk = null;
      if (mintTag === 1) { mintPk = _bDecodePk(bytes.slice(offset, offset + 32)); }
      offset += 32; // always advance 32 (Borsh fixed-size Option<Pubkey>)
      const actionByte = bytes[offset]; offset += 1;
      const execByte = bytes[offset]; offset += 1;
      // Empty slot: no recipient AND no amount AND no mint
      const hasRecip = recipBytes.some(b => b !== 0);
      if (!hasRecip && amtRaw === 0n && !mintPk) continue;
      // Corrupt/default slot: recipient is all-zeros (system pubkey) or near-zero (base58 = 111...)
      // and no valid mint ‚Äî these are uninitialized slots from failed/test transactions
      if (!mintPk && amtRaw === 0n) continue; // no mint, no amount ‚Äî definitely empty
      // Near-zero recipient: if >28 of 32 bytes are zero, treat as uninitialized
      const _zeroBytes = recipBytes.filter(b => b === 0).length;
      if (_zeroBytes >= 28 && !mintPk) continue; // system/default pubkey with no mint
      const recipFull = hasRecip ? _bDecodePk(recipBytes) : null;
      const isBurn = actionByte === 1;
      const short = recipFull ? recipFull.slice(0,4) + '...' + recipFull.slice(-4) : '(burn)';
      // Resolve symbol: SOL native mint ‚Üí 'SOL', lookup in known tokens, fallback to first 6 chars
      let mintSym, mintDec;
      if (mintPk === _SOL_MINT || mintPk === 'native') {
        mintSym = 'SOL'; mintDec = 9;
      } else if (mintPk) {
        const _kt = (ghostState.vaultTokens||[]).find(t=>t.mint===mintPk) || (ghostState.walletTokens||[]).find(t=>t.mint===mintPk);
        mintSym = _kt?.symbol || mintPk.slice(0,6);
        mintDec = _kt?.decimals ?? 6;
      } else {
        mintSym = '?'; mintDec = 6;
      }
      const _benef = {
        recipient: isBurn ? '(burn)' : short, fullAddr: isBurn ? null : recipFull,
        amount: Number(amtRaw) / Math.pow(10, mintDec),
        token: mintSym, mint: mintPk,
        action: isBurn ? 'burn' : 'transfer', executed: execByte === 1, _fromChain: true,
      };
      if (!_isClearedLocally(_benef)) _chainBenefs.push(_benef);
    }
    // Chain is authoritative ‚Äî replace all; whole-vault-share re-added below from wholeVaultRecipient
    ghostState.ghost.beneficiaries = [..._chainBenefs];

    // v1.3: whole_vault_recipient at byte offset 894 (after 8 disc + 886 fields)
    try {
      const wvTag = bytes[offset]; offset++;
      let wholeVaultRecipient = null;
      if (wvTag === 1 && bytes.length > offset + 31) {
        const B58 = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';
        const wvBytes = bytes.slice(offset, offset + 32);
        let wvn = BigInt(0);
        for (const b of wvBytes) wvn = wvn * BigInt(256) + BigInt(b);
        let wvr = ''; let wvtmp = wvn;
        while (wvtmp > 0n) { const rem = wvtmp % 58n; wvr = B58[Number(rem)] + wvr; wvtmp = wvtmp / 58n; }
        let leadOnes = '';
        for (let i = 0; i < wvBytes.length && wvBytes[i] === 0; i++) leadOnes += '1';
        wholeVaultRecipient = leadOnes + wvr;
        offset += 32;
      }
      ghostState.ghost.wholeVaultRecipient = wholeVaultRecipient;
      if (wholeVaultRecipient) {
        const short = wholeVaultRecipient.slice(0,4) + '...' + wholeVaultRecipient.slice(-4);
        ghostState.ghost.wholeVaultShares = [{ addr: short, fullAddr: wholeVaultRecipient, pct: 100 }];
        // Chain is authoritative ‚Äî always rebuild whole-vault-share entry from on-chain data
        ghostState.ghost.beneficiaries = ghostState.ghost.beneficiaries.filter(b => b.action !== 'whole-vault-share');
        ghostState.ghost.beneficiaries.push({
          recipient: short, fullAddr: wholeVaultRecipient,
          sharePct: 100, amount: 0, token: 'VAULT x100%',
          action: 'whole-vault-share', executed: false
        });
      } else {
        ghostState.ghost.wholeVaultRecipient = null;
        // Chain says no whole-vault recipient ‚Äî clear any stale session entry
        ghostState.ghost.beneficiaries = ghostState.ghost.beneficiaries.filter(b => b.action !== 'whole-vault-share');
        ghostState.ghost.wholeVaultShares = [];
      }
    } catch(_) { ghostState.ghost.wholeVaultRecipient = null; }

    if (executed) ghostState.ghost.status = 'executed';
    else if (awakened) ghostState.ghost.status = 'awakened';
    else ghostState.ghost.status = 'alive';
    // Update overview beneficiary count whenever chain state is parsed
    const _countEl = document.getElementById('dbBenefCount');
    if (_countEl) {
      const _wv = ghostState.ghost.beneficiaries.filter(b=>b.action==='whole-vault-share').length;
      const _tr = ghostState.ghost.beneficiaries.filter(b=>b.action!=='whole-vault-share').length;
      _countEl.textContent = _tr + (_wv > 0 ? 1 : 0);
    }

    // Populate recovery wallets from on-chain state (up to 3 slots)
    if (recoveryWalletPubkeys.length > 0) {
      const existing = ghostState.recoveryWallets.map(w => w.address);
      let changed = false;
      // Merge: add any chain-derived wallets not already in local state
      for (const pk of recoveryWalletPubkeys) {
        if (!existing.includes(pk)) {
          ghostState.recoveryWallets.push({ address: pk, canWithdraw: false, slotIndex: recoveryWalletPubkeys.indexOf(pk) });
          changed = true;
        }
      }
      // Remove any local wallets that are no longer on-chain
      const original = ghostState.recoveryWallets.length;
      ghostState.recoveryWallets = ghostState.recoveryWallets.filter(w => recoveryWalletPubkeys.includes(w.address));
      if (ghostState.recoveryWallets.length !== original) changed = true;
      if (changed) renderRecoveryWallets();
    } else if (ghostState.recoveryWallets.length > 0) {
      ghostState.recoveryWallets = [];
      renderRecoveryWallets();
    }
    
  } catch (err) {
    console.error('Parse error:', err);
    ghostState.ghost.status = 'alive'; // fallback
  }
}

function updateDashboardUI() {
  const g = ghostState.ghost;
  const isNone = g.status === 'none';

  // ‚îÄ‚îÄ Sidebar nav lock/unlock ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  const lockedIds = ['nav-vault','nav-beneficiaries','nav-heartbeat','nav-recovery','nav-settings'];
  lockedIds.forEach(id => {
    const el = document.getElementById(id);
    if (!el) return;
    if (isNone) el.classList.add('db-nav-locked');
    else el.classList.remove('db-nav-locked');
  });

  // ‚îÄ‚îÄ Sidebar footer ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  const stakeEl = document.getElementById('sidebarStake');
  const pingsEl = document.getElementById('sidebarPings');
  if (stakeEl) {
    if (isNone) { stakeEl.textContent = '‚Äî'; } else {
      const _sAmt = g.stakedGhost || 0;
      const _gPrice = PRICE_CACHE[GHOST_MINT] || 0;
      const _sUsd = _gPrice > 0 ? '<br><span style="font-size:10px;color:#9090b8;font-weight:300">\u2248 $' + (_sAmt * _gPrice).toLocaleString(undefined,{maximumFractionDigits:2}) + '</span>' : '';
      stakeEl.innerHTML = _sAmt.toLocaleString() + ' $GHOST' + _sUsd;
    }
  }
  if (pingsEl) pingsEl.textContent = isNone ? '‚Äî' : g.pingCount;

  // ‚îÄ‚îÄ Status badge in overview ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  const statusEl = document.getElementById('dbStatus');
  if (statusEl) {
    statusEl.textContent = g.status === 'none' ? 'NOT INITIALIZED' : g.status.toUpperCase();
    statusEl.className = 'db-status-badge status-' + g.status;
  }

  // ‚îÄ‚îÄ If no ghost: show init page, hide rest ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  if (isNone) {
    dbShowPage('init', document.getElementById('nav-overview'));
    // Keep overview nav highlighted
    document.querySelectorAll('.db-nav-item').forEach(n => n.classList.remove('active'));
    document.getElementById('nav-overview')?.classList.add('active');
    return;
  }

  // ‚îÄ‚îÄ Ghost exists: update overview fields ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  const pingCountEl = document.getElementById('dbPingCount');
  if (pingCountEl) pingCountEl.textContent = g.pingCount;

  const stakeDisplayEl = document.getElementById('dbStaked');
  if (stakeDisplayEl) stakeDisplayEl.textContent = (g.stakedGhost||0).toLocaleString();

  if (g.lastHeartbeat) {
    const lastEl = document.getElementById('dbLastPing');
    if (lastEl) {
      const ago = Math.floor((Date.now() - g.lastHeartbeat) / 60000);
      lastEl.textContent = ago < 1 ? 'just now' : ago < 60 ? ago + 'm ago' : Math.floor(ago/60) < 24 ? Math.floor(ago/60) + 'h ago' : Math.floor(ago/1440) + 'd ago';
    }
  }

  // Interval / grace / registered display
  const intervalEl = document.getElementById('dbInterval');
  if (intervalEl) intervalEl.textContent = Math.round(g.intervalSeconds/86400) + ' days';
  const graceEl = document.getElementById('dbGrace');
  if (graceEl) graceEl.textContent = Math.round(g.gracePeriodSeconds/86400) + ' days';
  const regEl = document.getElementById('dbRegistered');
  if (regEl && g.registeredAt) {
    const d = new Date(g.registeredAt);
    regEl.textContent = d.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
  }

  // Awakening alert
  const alert = document.getElementById('dbAwakeningAlert');
  if (alert) alert.style.display = g.status === 'awakened' ? 'block' : 'none';

  updateCountdown();
  syncSettingsDisplay();
  updateWalletIdentity();
}

// ‚îÄ‚îÄ‚îÄ Wallet Identity Card ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
let _walletIdentityAddr = null;
function updateWalletIdentity() {
  const addr = ghostState.publicKey;
  if (!addr) return;
  const domainEl = document.getElementById('dbWalletDomain');
  const shortEl  = document.getElementById('dbWalletShortAddr');
  const canvas   = document.getElementById('dbWalletAvatar');
  if (!canvas) return;
  const short = addr.slice(0,4) + '...' + addr.slice(-4);
  if (shortEl) shortEl.textContent = addr;
  // Deterministic identicon
  try {
    const ctx = canvas.getContext('2d');
    const S = 40, C = S / 7;
    let seed = 0;
    for (let i = 0; i < addr.length; i++) seed = (seed * 31 + addr.charCodeAt(i)) | 0;
    const rng = () => { seed = (seed * 1664525 + 1013904223) | 0; return (seed >>> 0) / 4294967295; };
    const hue = Math.floor(rng() * 360);
    ctx.fillStyle = '#110d1a'; ctx.fillRect(0, 0, S, S);
    ctx.fillStyle = `hsl(${hue},65%,62%)`;
    for (let y = 0; y < 7; y++) {
      for (let x = 0; x < 4; x++) {
        if (rng() > 0.42) {
          ctx.fillRect(x * C, y * C, C - 0.5, C - 0.5);
          if (x < 3) ctx.fillRect((6 - x) * C, y * C, C - 0.5, C - 0.5);
        }
      }
    }
  } catch(e) {}
  if (_walletIdentityAddr === addr) return;
  _walletIdentityAddr = addr;
  if (domainEl) domainEl.textContent = short;
  // Async SNS lookup
  fetch('https://sns-sdk-proxy.bonfida.workers.dev/domains/' + addr)
    .then(r => r.ok ? r.json() : null)
    .then(data => {
      const domains = data?.result;
      if (Array.isArray(domains) && domains.length > 0) {
        if (domainEl) domainEl.textContent = domains[0] + '.sol';
        const badge = document.getElementById('dbSolBadge');
        if (badge) badge.style.display = 'block';
      }
    }).catch(() => {});
}

function validateStakeInput(el) {
  const val = parseInt(el.value) || 0;
  const warning = document.getElementById('stakeWarning');
  const btn = el.closest('.db-form')?.querySelector('.db-btn-primary');
  if (val < 10000) {
    if (warning) warning.style.display = 'block';
    el.style.borderColor = 'rgba(255,61,90,0.5)';
  } else {
    if (warning) warning.style.display = 'none';
    el.style.borderColor = 'rgba(102,51,255,0.3)';
  }
}

// ‚îÄ‚îÄ‚îÄ Initialize Ghost ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
async function initializeGhost() {
  const intervalDays = parseInt(document.getElementById('initInterval')?.value) || 365;
  const graceDays = parseInt(document.getElementById('initGrace')?.value) || 30;
  const stakeAmt = parseInt(document.getElementById('initStake')?.value) || 10000;

  if (intervalDays < 7) { showNotif('‚ö†Ô∏è Minimum interval is 7 days', 'error'); return; }
  if (graceDays < 1) { showNotif('‚ö†Ô∏è Minimum grace period is 1 day', 'error'); return; }
  if (stakeAmt < 10000) {
    showNotif('‚ö†Ô∏è Minimum 10,000 $GHOST required to summon', 'error');
    const el = document.getElementById('initStake');
    if (el) { el.style.borderColor = 'rgba(255,61,90,0.5)'; el.focus(); }
    const w = document.getElementById('stakeWarning');
    if (w) w.style.display = 'block';
    return;
  }

  // Demo mode
  if (!ghostState.provider || ghostState.walletName?.includes('demo')) {
    ghostState.ghost.status = 'alive';
    ghostState.ghost.intervalSeconds = intervalDays * 86400;
    ghostState.ghost.gracePeriodSeconds = graceDays * 86400;
    ghostState.ghost.stakedGhost = stakeAmt;
    ghostState.ghost.lastHeartbeat = Date.now();
    ghostState.ghost.pingCount = 0;
    ghostState.ghost.vaultBalance = 0;
    showNotif('‚úÖ Ghost initialized! [demo mode]', 'green');
    saveSession();
    updateDashboardUI();
    dbShowPage('overview', document.getElementById('nav-overview'));
    loadWalletTokens();
    return;
  }

  // Real transaction ‚Äî check wallet holds enough $GHOST before signing
  const ghostWalletToken = ghostState.walletTokens.find(t => t.mint === GHOST_MINT);
  const ghostBalance = ghostWalletToken?.balance || 0;
  if (ghostBalance < stakeAmt) {
    const needed = stakeAmt.toLocaleString();
    const have = ghostBalance > 0 ? ghostBalance.toLocaleString(undefined, {maximumFractionDigits:0}) : '0';
    showNotif(`‚ö†Ô∏è You need ${needed} $GHOST to summon ‚Äî you only have ${have}`, 'error');
    return;
  }
  try {
    showNotif('Initializing ghost account...', '');
    // Base58 decode helper for pubkey bytes
    function b58dec(s) {
      const B58 = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';
      let n = BigInt(0);
      for (const c of s) n = n * BigInt(58) + BigInt(B58.indexOf(c));
      const b = new Uint8Array(32);
      for (let i = 31; i >= 0; i--) { b[i] = Number(n & BigInt(0xff)); n >>= BigInt(8); }
      return b;
    }
    console.log('[Ghost] initializeGhost START - provider:', !!ghostState.provider, 'pubkey:', ghostState.publicKey, 'ghostPda:', ghostState.ghostPda);
    // Re-derive PDAs if missing (can happen after page reload)
    if (!ghostState.ghostPda && ghostState.publicKey) {
      await deriveAndSetPDAs(ghostState.publicKey);
    }
    if (!ghostState.ghostPda) { showNotif('‚ö†Ô∏è Wallet not connected properly. Please reconnect.', 'error'); return; }
    const { PublicKey, Transaction, TransactionInstruction, SystemProgram } = solanaWeb3;
    const walletPubkey = new PublicKey(ghostState.publicKey);
    const programId = new PublicKey(PROGRAM_ID);

    // Anchor discriminator: sha256("global:initialize_ghost")[0:8]
    const discriminator = [51, 255, 136, 226, 138, 175, 174, 211];

    // Args match lib.rs v1.5 fn signature exactly:
    // initialize_ghost(interval_seconds: i64, grace_period_seconds: i64, recovery_wallets: [Option<Pubkey>; 3], stake_amount: u64)
    // recovery_wallets: 3 √ó Option<Pubkey> = 3 √ó 33 bytes = 99 bytes fixed
    const stakeRaw = BigInt(stakeAmt) * BigInt(1_000_000);
    console.log('[Ghost] stakeAmt:', stakeAmt, 'stakeRaw:', stakeRaw.toString());

    // Encode recovery_wallets: 3 fixed-size Option<Pubkey> slots
    // Slot: [0x00] if None, [0x01] + 32 bytes if Some
    const recoveryBytes = new Uint8Array(99); // 3 √ó 33
    for (let _ri = 0; _ri < 3; _ri++) {
      const w = ghostState.recoveryWallets?.[_ri]?.address || null;
      const slotOff = _ri * 33;
      if (w) {
        recoveryBytes[slotOff] = 1;
        recoveryBytes.set(new PublicKey(w).toBytes(), slotOff + 1);
      }
      // else byte stays 0 (None)
    }

    // Pack args: interval(i64=8) + grace(i64=8) + recovery_wallets(99) + stake(u64=8)
    const buf = new ArrayBuffer(8 + 8 + 99 + 8);
    const dv = new DataView(buf);
    dv.setBigInt64(0, BigInt(intervalDays * 86400), true);
    dv.setBigInt64(8, BigInt(graceDays * 86400), true);
    new Uint8Array(buf).set(recoveryBytes, 16);
    dv.setBigUint64(16 + 99, stakeRaw, true);

    const data = new Uint8Array(8 + buf.byteLength);
    data.set(discriminator, 0);
    data.set(new Uint8Array(buf), 8);

    const ghostPda = new PublicKey(ghostState.ghostPda);
    const vaultPda = new PublicKey(ghostState.vaultPda);
    const TOKEN_PROGRAM_ID = new PublicKey('TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA');
    const TOKEN_2022_PROGRAM_ID = new PublicKey(new Uint8Array([0, 30, 79, 74, 132, 28, 130, 123, 0, 122, 27, 201, 146, 247, 249, 161, 194, 146, 167, 199, 9, 168, 186, 224, 224, 5, 203, 112, 13, 226, 62, 58])); // TokenzQdBNbequo8zbWFStSoL4jCxhBTXpfLV5YBRB

    // Derive signer's $GHOST ATA (Associated Token Account)
    const ASSOCIATED_TOKEN_PROGRAM_ID = new PublicKey('ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJe1bso');
    const ghostMint = new PublicKey(GHOST_MINT);
    const connection = new solanaWeb3.Connection(RPC_URL, 'confirmed');

    // Detect which token program owns the ghost mint
    // Check by fetching the signer's known ATA and seeing which program owns it
    // Classic Token ATA = 165 bytes, Token-2022 ATA = 170+ bytes
    const ghostMintInfo = await connection.getAccountInfo(ghostMint);
    const mintOwner = ghostMintInfo?.owner?.toBase58() || '';
    // Also check a known ATA for this mint - Pump.fun sometimes uses Token-2022 under the hood
    // Use the actual program that owns the mint ‚Äî this is the token program to use
    const ghostTokenProgramId = mintOwner ? new PublicKey(new Uint8Array(b58dec(mintOwner))) : TOKEN_PROGRAM_ID;
    console.log('[Ghost] Ghost mint owner (token program):', mintOwner, 'data len:', ghostMintInfo?.data?.length);

    // Find the actual token account for signer ‚Äî Pump.fun may not use standard ATA derivation
    // Look up all token accounts for this wallet+mint combination
    let signerGhostAta;
    try {
      const tokenAccounts = await connection.getTokenAccountsByOwner(walletPubkey, { mint: ghostMint });
      console.log('[Ghost] Token accounts for mint:', tokenAccounts.value.length);
      if (tokenAccounts.value.length > 0) {
        signerGhostAta = tokenAccounts.value[0].pubkey;
        console.log('[Ghost] Found real signerGhostAta:', signerGhostAta.toBase58());
      } else {
        // Fall back to ATA derivation if none found
        const [derived] = await PublicKey.findProgramAddress(
          [walletPubkey.toBytes(), ghostTokenProgramId.toBytes(), ghostMint.toBytes()],
          ASSOCIATED_TOKEN_PROGRAM_ID
        );
        signerGhostAta = derived;
        console.log('[Ghost] No token account found, using derived ATA:', signerGhostAta.toBase58());
      }
    } catch(e) {
      const [derived] = await PublicKey.findProgramAddress(
        [walletPubkey.toBytes(), ghostTokenProgramId.toBytes(), ghostMint.toBytes()],
        ASSOCIATED_TOKEN_PROGRAM_ID
      );
      signerGhostAta = derived;
      console.log('[Ghost] Error fetching token accounts, using derived:', signerGhostAta.toBase58());
    }

    // ghost_stake_vault = PDA token account with seeds ["stake_vault", signer]
    const [ghostStakeVault] = await PublicKey.findProgramAddress(
      [new TextEncoder().encode('stake_vault'), walletPubkey.toBytes()],
      programId
    );
    console.log('[Ghost] Derived ghostStakeVault:', ghostStakeVault.toBase58());

    // Account order matches InitializeGhost context in lib.rs:
    // ghost, vault, ghost_stake_vault, signer_token_account, signer, token_program, system_program
    const ix = new TransactionInstruction({
      programId,
      keys: [
        { pubkey: ghostPda,               isSigner: false, isWritable: true  },
        { pubkey: vaultPda,               isSigner: false, isWritable: false },
        { pubkey: ghostMint,              isSigner: false, isWritable: false },
        { pubkey: ghostStakeVault,        isSigner: false, isWritable: true  },
        { pubkey: signerGhostAta,         isSigner: false, isWritable: true  },
        { pubkey: walletPubkey,           isSigner: true,  isWritable: true  },
        { pubkey: ghostTokenProgramId,    isSigner: false, isWritable: false },
        { pubkey: SystemProgram.programId,isSigner: false, isWritable: false },
      ],
      data
    });

    // Program creates ghost_stake_vault via init_if_needed ‚Äî no pre-creation needed
    const signerAtaInfo = await connection.getAccountInfo(signerGhostAta);
    console.log('[Ghost] signerGhostAta exists:', !!signerAtaInfo);

    const { blockhash } = await connection.getLatestBlockhash();
    const tx = new Transaction({ recentBlockhash: blockhash, feePayer: walletPubkey });
    tx.add(ix);

    // Debug: log each instruction individually so console doesn't collapse
    tx.instructions.forEach((ix, i) => 
      console.log(`[Ghost] ix${i}: prog=${ix.programId.toBase58()} accounts=${ix.keys.length} data=${ix.data.length}b`)
    );
    const signed = await ghostState.provider.signTransaction(tx);
    const sig = await connection.sendRawTransaction(signed.serialize(), { skipPreflight: true, preflightCommitment: 'confirmed' });
    console.log('[Ghost] TX sent:', sig);
    const conf = await connection.confirmTransaction(sig, 'confirmed');
    console.log('[Ghost] TX confirmed:', conf);
    if (conf.value?.err) throw new Error('TX failed: ' + JSON.stringify(conf.value.err));

    ghostState.ghost.status = 'alive';
    ghostState.ghost.intervalSeconds = intervalDays * 86400;
    ghostState.ghost.gracePeriodSeconds = graceDays * 86400;
    ghostState.ghost.stakedGhost = Number(stakeRaw) / 1_000_000;
    ghostState.ghost.lastHeartbeat = Date.now();
    ghostState.ghost.pingCount = 0;

    showNotif('‚úÖ Ghost initialized on-chain!', 'green');
    addActivityRow('üëª Ghost initialized', sig.slice(0,4)+'...'+sig.slice(-4));
    saveSession();
    updateDashboardUI();
    dbShowPage('overview', document.getElementById('nav-overview'));
    loadWalletTokens();
  } catch(err) {
    console.error('Initialize error:', err);
    showNotif('Failed: ' + (err.message || err), 'error');
  }
}
function openDashboard() {
  if (!ghostState.connected) { openModal(); return; }
  document.getElementById('dashboardPanel').classList.add('open');
  document.body.style.overflow = 'hidden';
  updateDashboardUI(); // handles none vs alive routing
  if (ghostState.ghost.status !== 'none') {
    renderBeneficiaries();
    renderVaultOverview();
    renderRecoveryWallets();
    renderPingHistory();
    renderActivityLog();
    updateCountdown();
    syncSettingsDisplay();
  }
  loadWalletTokens();
}

function closeDashboard() {
  document.getElementById('dashboardPanel').classList.remove('open');
  document.body.style.overflow = '';
}

async function disconnectWallet() {
  const provider = ghostState.provider;
  ghostState.provider = null;
  if (provider) {
    try { await provider.disconnect(); } catch(e) {}
    try { provider.off?.('accountChanged'); } catch(e) {}
  }
  sessionStorage.removeItem('ghostSession'); // legacy cleanup
  try { localStorage.removeItem(_sessionKey()); localStorage.removeItem('ghostLastWallet'); } catch(e) {}
  ghostState.connected = false;
  ghostState.walletName = null;
  ghostState.walletAddress = null;
  ghostState.publicKey = null;
  ghostState.ghostPda = null;
  ghostState.vaultPda = null;
  ghostState.ghostStakeVault = null;
  ghostState.ghost = { status:'none', lastHeartbeat:null, intervalSeconds:365*86400, gracePeriodSeconds:30*86400, awakenedAt:null, executed:false, stakedGhost:0, pingCount:0, vaultBalance:0, recoveryWallet:null, beneficiaries:[] };
  ghostState.walletTokens = [];
  ghostState.vaultTokens = [];
  ghostState.recoveryWallets = [];
  ghostState.selectedTokens = {};
  const btn = document.getElementById('walletBtn');
  if (btn) { btn.textContent = 'Connect Wallet'; btn.classList.remove('connected'); btn.onclick = openModal; }
  document.getElementById('navDashboardLink')?.classList.remove('visible');
  document.getElementById('navDisconnectBtn').style.display = 'none';
  closeDashboard();
  showNotif('üëª Wallet disconnected ‚Äî your ghost rests.', '');
}

// ESC closes dashboard
document.addEventListener('keydown', (e) => {
  if (e.key === 'Escape') closeDashboard();
});

// Tab visibility: refresh prices when returning to tab
document.addEventListener('visibilitychange', () => {
  if (document.visibilityState === 'visible') {
    // Refresh prices immediately on tab return (don't wait for next interval)
    fetchAllPrices();
  }
});

// ‚îÄ‚îÄ‚îÄ Session persists across refresh and tab close ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// localStorage is only cleared by explicit disconnectWallet()
// No beforeunload wipe ‚Äî wallet identity + PDAs survive all navigation

// ‚îÄ‚îÄ‚îÄ Restore session on every page load ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
document.addEventListener('DOMContentLoaded', () => {
  const lastPage = loadSession();
  if (!lastPage) return;
  const isDemo = ghostState.walletName?.includes('demo');
  const btn = document.getElementById('walletBtn');
  document.getElementById('navDashboardLink')?.classList.add('visible');
  document.getElementById('navDisconnectBtn').style.display = 'inline-block';
  // Restore UI immediately regardless of wallet type
  const panelAddr = document.getElementById('panelWalletAddr');
  if (btn) {
    btn.textContent = '‚óè ' + ghostState.walletAddress + (isDemo ? ' [demo]' : '');
    btn.classList.add('connected');
    btn.onclick = openDashboard;
  }
  if (panelAddr) panelAddr.textContent = ghostState.walletAddress + (isDemo ? ' (demo)' : '');

  setTimeout(async () => {
    // Re-derive PDAs if missing
    if (!ghostState.ghostPda && ghostState.publicKey) { try { await deriveAndSetPDAs(ghostState.publicKey); } catch(e) {} }

    if (!isDemo) {
      // Try to silently re-attach provider (onlyIfTrusted:true = no popup if already approved)
      const walletName = ghostState.walletName;
      let provider = null;
      if (walletName === 'Phantom') provider = window.phantom?.solana || window.solana;
      else if (walletName === 'Solflare') provider = window.solflare;
      else if (walletName === 'Backpack') provider = window.backpack?.solana;
      if (!provider) provider = window.phantom?.solana || window.solflare || window.solana;
      if (provider) {
        try {
          const resp = await provider.connect({ onlyIfTrusted: true });
          ghostState.provider = provider;
          // Attach account change listener
          const _onAccountChange = () => { showNotif('üëª Wallet account changed ‚Äî please reconnect.', ''); disconnectWallet(); };
          try { provider.off?.('accountChanged', _onAccountChange); provider.on?.('accountChanged', _onAccountChange); } catch(e) {}
        } catch(e) {
          // User hasn't approved yet or extension not available ‚Äî they'll need to click connect
          ghostState.provider = null;
        }
      }
      // Fetch fresh ghost state from chain
      if (ghostState.ghostPda) { try { await fetchGhostAccount(); } catch(e) {} }
    }

    openDashboard();
    if (ghostState.ghost.status !== 'none' && lastPage !== 'init') dbShowPage(lastPage, document.getElementById('nav-' + lastPage));
    loadWalletTokens();
  }, 100);
});

// ‚îÄ‚îÄ‚îÄ Dashboard navigation ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function dbShowPage(pageId, navEl) {
  // When opening beneficiaries page, always refresh vault state for accurate pickers
  if (pageId === 'beneficiaries' && ghostState.ghost.status !== 'none') {
    // Re-fetch vault tokens and pickers async ‚Äî don't block navigation
    setTimeout(() => {
      loadWalletTokens().then(() => { _refreshBenePickers(); renderBeneficiaries(); }).catch(()=>{});
    }, 50);
  }
  // If ghost not yet registered, only allow init/watcher pages ‚Äî block everything else
  if (ghostState.ghost.status === 'none' && pageId !== 'init' && pageId !== 'watcher') {
    // Redirect silently to init
    document.querySelectorAll('.db-page').forEach(p => p.classList.remove('active'));
    document.querySelectorAll('.db-nav-item').forEach(n => n.classList.remove('active'));
    const initPage = document.getElementById('db-page-init');
    if (initPage) initPage.classList.add('active');
    document.getElementById('nav-overview')?.classList.add('active');
    return;
  }
  document.querySelectorAll('.db-page').forEach(p => p.classList.remove('active'));
  document.querySelectorAll('.db-nav-item').forEach(n => n.classList.remove('active'));
  const page = document.getElementById('db-page-' + pageId);
  if (page) page.classList.add('active');
  if (navEl) navEl.classList.add('active');
  _currentPage = pageId;
  saveSession();
  if (pageId === 'beneficiaries') {
    // Rebuild bene/burn pickers immediately with current vault state
    const _beneAssignable = vaultAssignableTokens();
    buildPickerDropdown('bene', [WHOLE_VAULT_TOKEN, ..._beneAssignable]);
    buildPickerDropdown('burn', _beneAssignable);
    if (!ghostState.selectedTokens.bene) {
      const symEl = document.getElementById('benePickerSymbol');
      const balEl = document.getElementById('benePickerBal');
      if (symEl) { symEl.textContent = 'Select asset'; symEl.style.color = 'var(--muted)'; }
      if (balEl) balEl.textContent = '';
    }
    if (_beneAssignable.length > 0 && !ghostState.selectedTokens.burn) selectToken('burn', _beneAssignable[0].mint);
    renderBeneficiaries();
    renderWholeVaultShares();
    loadWalletTokens(); // async ‚Äî also calls populateAllPickers when done
  }
  if (pageId === 'vault') loadWalletTokens();
  if (pageId === 'settings') syncSettingsDisplay();
  if (pageId === 'recovery') renderRecoveryWallets();
  if (pageId === 'heartbeat') renderPingHistory();
  if (pageId === 'overview') { renderVaultOverview(); renderPingHistory(); renderActivityLog(); renderBeneficiaries(); }
}

// ‚îÄ‚îÄ‚îÄ Countdown ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function formatDuration(ms) {
  const s = Math.floor(ms / 1000);
  const d = Math.floor(s / 86400);
  const h = Math.floor((s % 86400) / 3600);
  const m = Math.floor((s % 3600) / 60);
  if (d > 0) return d + 'd ' + h + 'h ' + m + 'm';
  if (h > 0) return h + 'h ' + m + 'm';
  return m + 'm';
}

function updateCountdown() {
  if (!ghostState.ghost.lastHeartbeat) return;
  const deadline = ghostState.ghost.lastHeartbeat + ghostState.ghost.intervalSeconds * 1000;
  const remaining = Math.max(0, deadline - Date.now());
  const str = formatDuration(remaining);
  const elapsed = Date.now() - ghostState.ghost.lastHeartbeat;
  const total = ghostState.ghost.intervalSeconds * 1000;
  const pct = Math.min(100, (elapsed / total) * 100).toFixed(1);

  const cdEl = document.getElementById('dbCountdown'); if (cdEl) cdEl.textContent = str;
  const bigEl = document.getElementById('dbBigCountdown'); if (bigEl) bigEl.textContent = str;
  const pvEl = document.getElementById('dbProgressVal'); if (pvEl) pvEl.textContent = pct + '% elapsed';
  const fill = document.getElementById('dbProgressFill');
  if (fill) { fill.style.width = pct + '%'; fill.className = 'db-progress-fill' + (parseFloat(pct) > 80 ? ' warn' : ''); }
  // Also keep "last ping" label in sync
  const lastEl = document.getElementById('dbLastPing');
  if (lastEl && ghostState.ghost.lastHeartbeat) {
    const ago = Math.floor((Date.now() - ghostState.ghost.lastHeartbeat) / 60000);
    lastEl.textContent = ago < 1 ? 'just now' : ago < 60 ? ago + 'm ago' : Math.floor(ago/60) < 24 ? Math.floor(ago/60) + 'h ago' : Math.floor(ago/1440) + 'd ago';
  }
}

setInterval(updateCountdown, 30000);

// ‚îÄ‚îÄ‚îÄ Ping ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
async function sendPing() {
  const orb = document.getElementById('hbOrb');
  const ripple = document.getElementById('pingRipple');

  orb.classList.add('beat');
  ripple.classList.add('active');
  setTimeout(() => { orb.classList.remove('beat'); ripple.classList.remove('active'); }, 1200);

  // Demo mode ‚Äî no real wallet
  if (!ghostState.provider || ghostState.walletName?.includes('demo')) {
    ghostState.ghost.lastHeartbeat = Date.now();
    ghostState.ghost.pingCount++;
    document.getElementById('dbPingCount').textContent = ghostState.ghost.pingCount;
    const sideEl = document.getElementById('sidebarPings');
    if (sideEl) sideEl.textContent = ghostState.ghost.pingCount;
    document.getElementById('dbLastPing').textContent = 'just now';
    const tx = randomTx();
    addActivityRow('üíì Heartbeat sent (demo)', tx);
    addPingToHistory(tx);
    updateCountdown();
    showNotif('üíì Heartbeat sent! [demo mode]', 'green');
    return;
  }

  // Real transaction
  try {
    showNotif('Sending heartbeat...', '');
    const { PublicKey, Transaction, TransactionInstruction, SystemProgram } = solanaWeb3;
    
    const walletPubkey = new PublicKey(ghostState.publicKey);
    const ghostPda = new PublicKey(ghostState.ghostPda);
    const programId = new PublicKey(PROGRAM_ID);

    // Anchor discriminator: sha256("global:ping")[0:8]
    const discriminator = [173, 0, 94, 236, 73, 133, 225, 153];

    const ix = new TransactionInstruction({
      programId,
      keys: [
        { pubkey: ghostPda, isSigner: false, isWritable: true },
        { pubkey: walletPubkey, isSigner: true, isWritable: false },
      ],
      data: new Uint8Array(discriminator)
    });

    const connection = new solanaWeb3.Connection(RPC_URL, 'confirmed');
    const { blockhash } = await connection.getLatestBlockhash();
    const tx = new Transaction({ recentBlockhash: blockhash, feePayer: walletPubkey });
    tx.add(ix);

    // Debug: log each instruction individually so console doesn't collapse
    tx.instructions.forEach((ix, i) => 
      console.log(`[Ghost] ix${i}: prog=${ix.programId.toBase58()} accounts=${ix.keys.length} data=${ix.data.length}b`)
    );
    const signed = await ghostState.provider.signTransaction(tx);
    const sig = await connection.sendRawTransaction(signed.serialize(), { skipPreflight: true, preflightCommitment: 'confirmed' });
    console.log('[Ghost] TX sent:', sig);
    const conf = await connection.confirmTransaction(sig, 'confirmed');
    console.log('[Ghost] TX confirmed:', conf);
    if (conf.value?.err) throw new Error('TX failed: ' + JSON.stringify(conf.value.err));

    // Update state
    ghostState.ghost.lastHeartbeat = Date.now();
    ghostState.ghost.pingCount++;
    document.getElementById('dbPingCount').textContent = ghostState.ghost.pingCount;
    const sideEl = document.getElementById('sidebarPings');
    if (sideEl) sideEl.textContent = ghostState.ghost.pingCount;
    document.getElementById('dbLastPing').textContent = 'just now';
    
    const shortSig = sig.slice(0,4) + '...' + sig.slice(-4);
    addActivityRow('üíì Heartbeat sent', shortSig);
    addPingToHistory(shortSig);
    updateCountdown();
    saveSession();
    showNotif('üíì Heartbeat confirmed! TX: ' + shortSig, 'green');
  } catch (err) {
    console.error('Ping error:', err);
    showNotif('Ping failed: ' + (err.message || err), 'error');
    orb.classList.remove('beat');
    ripple.classList.remove('active');
  }
}

// ‚îÄ‚îÄ‚îÄ Activity Log (persistent across session) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
if (!ghostState.activityLog) ghostState.activityLog = []; // [{msg, tx, ts}]

function addActivityRow(msg, tx, icon) {
  const ts = Date.now();
  ghostState.activityLog.unshift({ msg, tx: tx||'', ts, _local: true, icon: icon||null });
  renderActivityLog();
}

function renderActivityLog() {
  const log = document.getElementById('dbActivityLog');
  if (!log) return;
  if (ghostState.activityLog.length === 0) {
    log.innerHTML = '<tr><td colspan="3" style="text-align:center;color:#c0bce0">No activity yet</td></tr>';
    return;
  }
  const _depositSvg = '<span style="display:inline-flex;align-items:center;justify-content:center;width:18px;height:18px;vertical-align:middle;margin-right:5px;flex-shrink:0"><svg width="16" height="16" viewBox="0 0 24 24" fill="none"><circle cx="12" cy="12" r="11" fill="rgba(51,255,120,0.12)" stroke="#33ff78" stroke-width="1.2"/><path d="M12 7v10M7 14l5 4 5-4" stroke="#33ff78" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"/></svg></span>';
  const _withdrawSvg = '<span style="display:inline-flex;align-items:center;justify-content:center;width:18px;height:18px;vertical-align:middle;margin-right:5px;flex-shrink:0"><svg width="16" height="16" viewBox="0 0 24 24" fill="none"><circle cx="12" cy="12" r="11" fill="rgba(255,80,80,0.12)" stroke="#ff5050" stroke-width="1.2"/><path d="M12 17V7M7 10l5-4 5 4" stroke="#ff5050" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"/></svg></span>';
  const _angelSvg = '<span style="display:inline-flex;align-items:center;justify-content:center;width:18px;height:18px;vertical-align:middle;margin-right:5px;flex-shrink:0"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" style="filter:drop-shadow(0 0 4px rgba(200,180,255,0.95)) drop-shadow(0 0 8px rgba(160,120,255,0.6))"><ellipse cx="12" cy="4" rx="5" ry="1.5" fill="none" stroke="#e8dcff" stroke-width="1.2"/><circle cx="12" cy="8.5" r="3.2" fill="#cdbfff"/><path d="M4.5 11.5 Q1.5 9 2.5 6 Q4 3.5 7 5 Q9 6.2 8.5 9.5" fill="#ddd0ff" opacity="0.8"/><path d="M19.5 11.5 Q22.5 9 21.5 6 Q20 3.5 17 5 Q15 6.2 15.5 9.5" fill="#ddd0ff" opacity="0.8"/><path d="M7.5 13.5 Q4 16 5 19.5 Q6.5 22 9.5 20 Q11 19 12 17" fill="#c8b8ff" opacity="0.75"/><path d="M16.5 13.5 Q20 16 19 19.5 Q17.5 22 14.5 20 Q13 19 12 17" fill="#c8b8ff" opacity="0.75"/><ellipse cx="12" cy="14.5" rx="2.8" ry="4" fill="#b8a4ff" opacity="0.85"/></svg></span>';
  const _chestSvg = '<span style="display:inline-flex;align-items:center;justify-content:center;width:18px;height:18px;vertical-align:middle;margin-right:5px;flex-shrink:0"><svg width="18" height="18" viewBox="0 0 36 36" fill="none" xmlns="http://www.w3.org/2000/svg" style="filter:drop-shadow(0 0 4px rgba(255,200,60,0.7)) drop-shadow(0 0 8px rgba(255,160,0,0.4))"><rect x="3" y="16" width="30" height="17" rx="2" fill="#7c4d00" stroke="#f0a020" stroke-width="1.2"/><rect x="3" y="16" width="30" height="8" rx="2" fill="#a06000" stroke="#f0a020" stroke-width="1.2"/><rect x="2" y="8" width="32" height="11" rx="3" fill="#c07800" stroke="#f0b030" stroke-width="1.2"/><rect x="13" y="19" width="10" height="7" rx="1.5" fill="#f0a020" stroke="#ffd060" stroke-width="0.8"/><circle cx="18" cy="22.5" r="2" fill="#ffd060" stroke="#fff8d0" stroke-width="0.5"/></svg></span>';
  log.innerHTML = ghostState.activityLog.map(entry => {
    const d = new Date(entry.ts);
    const timeStr = d.toLocaleDateString('en-GB', {day:'numeric',month:'short'}) + ' ' + d.toLocaleTimeString('en-GB', {hour:'2-digit',minute:'2-digit'});
    const fullSig = entry.tx||'';
    const short = fullSig.length>12 ? fullSig.slice(0,4)+'...'+fullSig.slice(-4) : fullSig;
    const cpBtn = fullSig ? '<button onclick="copyAddr(\'' + fullSig + '\')" title="Copy tx signature" style="background:none;border:1px solid rgba(102,51,255,0.25);color:#8888bb;font-size:10px;padding:1px 5px;cursor:pointer;margin-left:4px;font-family:\'Share Tech Mono\',monospace;vertical-align:middle;line-height:1.4">\u29C9</button>' : '';
    let iconHtml = '';
    if (entry.icon === 'angel') iconHtml = _angelSvg;
    else if (entry.icon === 'deposit') iconHtml = _depositSvg;
    else if (entry.icon === 'withdraw') iconHtml = _withdrawSvg;
    else if (entry.msg && /whole vault|Whole vault|whole-vault|Whole Vault/i.test(entry.msg)) iconHtml = _chestSvg;
    // Auto-detect for chain history rows (no icon field stored)
    if (!iconHtml) {
      if (/Vault Deposit/i.test(entry.msg)) iconHtml = _depositSvg;
      else if (/Vault Withdrawal/i.test(entry.msg)) iconHtml = _withdrawSvg;
    }
    const rowBg = '';
    const tdStyle = iconHtml ? ' style="display:flex;align-items:center"' : '';
    return '<tr' + rowBg + '><td' + tdStyle + '>' + iconHtml + entry.msg + '</td><td style="white-space:nowrap;color:#9090b8">' + timeStr + '</td><td style="white-space:nowrap"><span class="addr-short">' + short + '</span>' + cpBtn + '</td></tr>';
  }).join('');
}

function randomTx() {
  const c = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';
  const r = (n) => Array.from({length:n},()=>c[Math.floor(Math.random()*c.length)]).join('');
  return r(4)+'...'+r(3);
}

// ‚îÄ‚îÄ‚îÄ Beneficiaries ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function renderBeneficiaries() {
  const tbody = document.getElementById('dbBeneficiaryList');
  const all = ghostState.ghost.beneficiaries;
  const transfers = all.filter(b => b.action !== 'burn' && b.action !== 'whole-vault-share');
  const burns = all.filter(b => b.action === 'burn');
  const wholeShares = all.filter(b => b.action === 'whole-vault-share');

  // ‚îÄ‚îÄ Vault allocation overview ‚îÄ‚îÄ
  const ovEl = document.getElementById('beneVaultOverview');
  if (ovEl) {
    if (ghostState.vaultTokens.length === 0) {
      ovEl.innerHTML = '<div class="db-info" style="border-color:rgba(255,153,51,0.3);color:#ff9933">‚ö†Ô∏è Your vault is empty. Deposit assets first before assigning beneficiaries.</div>';
    } else {
      // Per-token allocation bars
      const hasWholeVault = wholeShares.length > 0;
      const allocationByToken = {};
      for (const vt of ghostState.vaultTokens) {
        // Whole vault = 100% of every token is assigned
        allocationByToken[vt.symbol] = { vaultBal: vt.balance, assigned: hasWholeVault ? vt.balance : 0, price: getTokenPrice(vt) };
      }
      if (!hasWholeVault) {
        for (const b of all.filter(x => x.action !== 'whole-vault-share')) {
          // Match by symbol first, then by mint (handles SOL where mint=So111... but sym='SOL')
          if (allocationByToken[b.token]) {
            allocationByToken[b.token].assigned += b.amount;
          } else if (b.mint) {
            // Try to find a vault token by mint address
            const _vtByMint = ghostState.vaultTokens.find(v => v.mint === b.mint);
            if (_vtByMint && allocationByToken[_vtByMint.symbol]) {
              allocationByToken[_vtByMint.symbol].assigned += b.amount;
            }
          }
        }
      }
      const wholeRecipient = wholeShares[0]?.recipient || '';
      const wholeFullAddr = wholeShares[0]?.fullAddr || '';

      // Token card builder
      const tokenCards = Object.entries(allocationByToken).map(([sym, info]) => {
        const vt = ghostState.vaultTokens.find(v => v.symbol === sym);
        const assignedAmt = info.assigned;
        const freeAmt = Math.max(0, info.vaultBal - assignedAmt);
        const barPct = info.vaultBal > 0 ? Math.min(100, (assignedAmt / info.vaultBal) * 100) : 0;
        const over = !hasWholeVault && assignedAmt > info.vaultBal + 0.000001;
        const isFullyDone = barPct >= 99.99;
        const usdAssigned = info.price > 0 ? (assignedAmt * info.price) : 0;
        const usdTotal = info.price > 0 ? (info.vaultBal * info.price) : 0;
        const usdAssignedStr = usdAssigned > 0 ? '$' + usdAssigned.toLocaleString(undefined,{maximumFractionDigits:2}) : '';
        const usdTotalStr = usdTotal > 0 ? '$' + usdTotal.toLocaleString(undefined,{maximumFractionDigits:2}) : '';
        const col = tokenColor(sym);
        // Bar gradient: assigned portion in token color, free portion in dark
        const barGrad = hasWholeVault
          ? `linear-gradient(90deg, ${col} 0%, rgba(160,128,255,0.7) 100%)`
          : over
          ? 'linear-gradient(90deg,#ff3d5a,#ff6680)'
          : isFullyDone
          ? `linear-gradient(90deg,${col},rgba(51,255,153,0.8))`
          : `linear-gradient(90deg,${col} 0%,${col}aa 100%)`;
        const statusChip = hasWholeVault
          ? `<span style="font-family:'Share Tech Mono',monospace;font-size:9px;letter-spacing:0.12em;padding:2px 8px;background:rgba(160,128,255,0.15);border:1px solid rgba(160,128,255,0.35);color:#c0a0ff">ASSIGNED</span>`
          : over
          ? `<span style="font-family:'Share Tech Mono',monospace;font-size:9px;letter-spacing:0.12em;padding:2px 8px;background:rgba(255,61,90,0.15);border:1px solid rgba(255,61,90,0.4);color:#ff3d5a">OVER ‚ö†Ô∏è</span>`
          : isFullyDone
          ? `<span style="font-family:'Share Tech Mono',monospace;font-size:9px;letter-spacing:0.12em;padding:2px 8px;background:rgba(51,255,153,0.1);border:1px solid rgba(51,255,153,0.3);color:#33ff99">FULL</span>`
          : assignedAmt > 0
          ? `<span style="font-family:'Share Tech Mono',monospace;font-size:9px;letter-spacing:0.12em;padding:2px 8px;background:rgba(255,153,51,0.1);border:1px solid rgba(255,153,51,0.3);color:#ff9933">PARTIAL</span>`
          : `<span style="font-family:'Share Tech Mono',monospace;font-size:9px;letter-spacing:0.12em;padding:2px 8px;background:rgba(255,255,255,0.04);border:1px solid rgba(255,255,255,0.08);color:#c0bce0">FREE</span>`;

        const amtLine = hasWholeVault
          ? `<span style="color:#c0a0ff">${info.vaultBal.toLocaleString(undefined,{maximumFractionDigits:6})} ${sym}</span>${usdTotalStr ? ' <span style="color:rgba(160,128,255,0.5)">¬∑ ' + usdTotalStr + '</span>' : ''}`
          : assignedAmt > 0
          ? `<span style="color:#f0f0f8">${assignedAmt.toLocaleString(undefined,{maximumFractionDigits:6})}</span><span style="color:#c0bce0"> / ${info.vaultBal.toLocaleString(undefined,{maximumFractionDigits:6})} ${sym}</span>${usdAssignedStr ? ' <span style="color:rgba(255,255,255,0.3)">¬∑ ' + usdAssignedStr + (usdTotalStr ? ' of ' + usdTotalStr : '') + '</span>' : ''}`
          : `<span style="color:#c0bce0">${info.vaultBal.toLocaleString(undefined,{maximumFractionDigits:6})} ${sym}${usdTotalStr ? ' ¬∑ ' + usdTotalStr : ''}</span>`;

        // Use tokenLogoEl to get logo ‚Äî it checks TOKEN_LOGO_URLS by symbol (covers SOL, USDC etc)
        // then falls back to vt.logoUrl for pump.fun tokens
        const _logoHtmlInner = tokenLogoEl(sym, 28, vt?.logoUrl || null);
        const logoHtml = `<div style="flex-shrink:0;width:28px;height:28px">${_logoHtmlInner}</div>`;

        return `<div style="margin-bottom:14px;padding:12px 14px;background:rgba(255,255,255,0.02);border:1px solid rgba(255,255,255,0.05);border-radius:2px">
          <div style="display:flex;align-items:center;gap:10px;margin-bottom:9px">
            ${logoHtml}
            <div style="flex:1;min-width:0">
              <div style="display:flex;align-items:center;gap:8px;margin-bottom:2px">
                <span style="font-family:'Syne',sans-serif;font-weight:700;font-size:13px;color:${col}">${sym}</span>
                ${statusChip}
              </div>
              <div style="font-family:'Share Tech Mono',monospace;font-size:11px;line-height:1.4">${amtLine}</div>
            </div>
            <div style="text-align:right;flex-shrink:0">
              <div style="font-family:'Syne',sans-serif;font-weight:700;font-size:18px;color:${over?'#ff3d5a':col};line-height:1">${Math.round(barPct)}%</div>
              <div style="font-family:'Share Tech Mono',monospace;font-size:9px;color:#c0bce0;margin-top:2px">assigned</div>
            </div>
          </div>
          <div style="height:6px;background:rgba(255,255,255,0.05);border-radius:3px;overflow:hidden">
            <div style="height:6px;background:${barGrad};border-radius:3px;width:${barPct}%;transition:width 0.4s cubic-bezier(0.4,0,0.2,1);box-shadow:0 0 8px ${col}44"></div>
          </div>
          ${!hasWholeVault && freeAmt > 0.000001 && assignedAmt > 0 ? `<div style="font-family:'Share Tech Mono',monospace;font-size:10px;color:rgba(255,255,255,0.2);margin-top:5px;text-align:right">${freeAmt.toLocaleString(undefined,{maximumFractionDigits:6})} ${sym} free to assign</div>` : ''}
        </div>`;
      }).join('');

      const wholeNoticeHtml = hasWholeVault ? `
        <div style="margin-top:4px;padding:14px 16px;background:linear-gradient(135deg,rgba(102,51,255,0.12),rgba(160,128,255,0.06));border:1px solid rgba(160,128,255,0.3);display:flex;align-items:center;gap:12px">
          <span style="font-size:22px;flex-shrink:0">üëª</span>
          <div style="flex:1">
            <div style="font-family:'Syne',sans-serif;font-weight:700;font-size:13px;color:#e0d0ff;margin-bottom:3px">Entire vault assigned</div>
            <div style="font-family:'Share Tech Mono',monospace;font-size:11px;color:#c0bce0">100% ‚Üí <span style="color:#c0a0ff;cursor:pointer" onclick="copyAddr('${wholeFullAddr}')" title="Click to copy">${wholeRecipient} ‚ßâ</span> ¬∑ All tokens transferred on execution</div>
          </div>
        </div>` : '';

      // Summary line at top
      const totalAssignedPct = hasWholeVault ? 100
        : ghostState.vaultTokens.length > 0
        ? Math.round(Object.values(allocationByToken).reduce((s,i) => s + (i.vaultBal > 0 ? Math.min(1, i.assigned/i.vaultBal) : 0), 0) / ghostState.vaultTokens.length * 100)
        : 0;
      const totalUsdVault = Object.values(allocationByToken).reduce((s,i) => s + (i.price > 0 ? i.vaultBal * i.price : 0), 0);
      const summaryColor = totalAssignedPct >= 100 ? '#33ff99' : totalAssignedPct > 0 ? '#ff9933' : 'var(--muted)';

      ovEl.innerHTML = `<div style="margin-bottom:16px">
        <div style="display:flex;justify-content:space-between;align-items:flex-end;margin-bottom:14px">
          <div>
            <div style="font-family:'Share Tech Mono',monospace;font-size:10px;letter-spacing:0.2em;color:#c0bce0;text-transform:uppercase;margin-bottom:4px">Vault Allocation</div>
            <div style="font-family:'Syne',sans-serif;font-weight:800;font-size:22px;color:${summaryColor};line-height:1">${totalAssignedPct}% <span style="font-size:13px;font-weight:400;color:#c0bce0">assigned</span></div>
          </div>
          ${totalUsdVault > 0 ? `<div style="text-align:right"><div style="font-family:'Share Tech Mono',monospace;font-size:10px;color:#c0bce0;margin-bottom:2px">vault value</div><div style="font-family:'Syne',sans-serif;font-weight:700;font-size:16px;color:#33ff99">$${totalUsdVault.toLocaleString(undefined,{maximumFractionDigits:2})}</div></div>` : ''}
        </div>
        ${tokenCards}${wholeNoticeHtml}
      </div>`;
    }
  }

  let rows = '';
  transfers.forEach((ben, i) => {
    const realIdx = all.indexOf(ben);
    const vt = ghostState.vaultTokens.find(v => v.symbol === ben.token);
    const over = vt && ben.amount > vt.balance;
    rows += `<tr${over ? ' style="background:rgba(255,61,90,0.05)"' : ''}>
      <td style="color:#c0bce0">${i+1}</td>
      <td><span class="addr-short" style="cursor:pointer" onclick="copyAddr('${ben.recipient}')" title="Click to copy">${ben.recipient} ‚ßâ</span></td>
      <td>${ben.amount.toLocaleString()}</td>
      <td style="color:${tokenColor(ben.token)};font-size:12px">${ben.token}${over ? ' <span style="color:#ff3d5a">‚ö†Ô∏è</span>' : ''}</td>
      <td><span class="tag tag-transfer">TRANSFER</span></td>
      <td><span class="tag ${ben.executed?'tag-done':'tag-ready'}">${ben.executed?'PAID':'READY'}</span></td>
      <td><button class="icon-btn" onclick="dbRemoveBeneficiary(${realIdx})" title="Remove">‚úï</button></td>
    </tr>`;
  });
  if (burns.length > 0) {
    rows += `<tr><td colspan="7" style="padding:8px 12px;font-family:'Share Tech Mono',monospace;font-size:10px;color:rgba(255,61,90,0.5);letter-spacing:0.2em;text-transform:uppercase;border-top:1px solid rgba(255,61,90,0.15)">üî• Burn Instructions</td></tr>`;
    burns.forEach(ben => {
      const realIdx = all.indexOf(ben);
      rows += `<tr>
        <td style="color:rgba(255,61,90,0.4)">‚Äî</td>
        <td style="color:#c0bce0">BURN (no recipient)</td>
        <td>${ben.amount.toLocaleString()}</td>
        <td style="color:#ff6688;font-size:12px">${ben.token}</td>
        <td><span class="tag tag-burn">BURN</span></td>
        <td><span class="tag ${ben.executed?'tag-done':'tag-ready'}">${ben.executed?'DONE':'READY'}</span></td>
        <td><button class="icon-btn" onclick="dbRemoveBeneficiary(${realIdx})" title="Remove">‚úï</button></td>
      </tr>`;
    });
  }
  // Whole-vault assignment row
  if (wholeShares.length > 0) {
    rows += `<tr><td colspan="7" style="padding:8px 12px;font-family:'Share Tech Mono',monospace;font-size:10px;color:rgba(160,128,255,0.6);letter-spacing:0.2em;text-transform:uppercase;border-top:1px solid rgba(160,128,255,0.15)">Whole Vault Assignment</td></tr>`;
    wholeShares.forEach(ben => {
      const realIdx = all.indexOf(ben);
      rows += `<tr style="background:rgba(102,51,255,0.03)">
        <td style="color:#a080ff">üëª</td>
        <td><span class="addr-short" style="cursor:pointer" onclick="copyAddr('${ben.fullAddr||ben.recipient}')" title="Click to copy">${ben.recipient} ‚ßâ</span></td>
        <td style="color:#c0a0ff">100%</td>
        <td style="color:#c0a0ff;font-size:12px">All tokens</td>
        <td><span class="tag" style="background:rgba(160,128,255,0.1);color:#c0a0ff;border-color:rgba(160,128,255,0.3)">VAULT</span></td>
        <td><span class="tag tag-done">READY</span></td>
        <td><button class="icon-btn" onclick="dbRemoveBeneficiary(${realIdx})" title="Remove">‚úï</button></td>
      </tr>`;
    });
  }
  if (!rows) rows = '<tr><td colspan="7" style="text-align:center;color:#c0bce0;padding:20px">No beneficiaries yet</td></tr>';
  tbody.innerHTML = rows;

  const slots = transfers.length + ' / 10 slots';
  const slotEl = document.getElementById('dbBSlots');
  if (slotEl) slotEl.textContent = slots;
  const countEl = document.getElementById('dbBenefCount');
  // Show whole vault share as 1 beneficiary in overview count
  const totalBeneCount = transfers.length + (wholeShares.length > 0 ? 1 : 0);
  if (countEl) countEl.textContent = totalBeneCount;
  // Show lock notice + disable add buttons when whole vault is active
  const lockNotice = document.getElementById('wholeVaultLockNotice');
  if (lockNotice) lockNotice.style.display = wholeShares.length > 0 ? 'block' : 'none';
  const addTransferBtn = document.getElementById('addTransferBtn');
  if (addTransferBtn) { addTransferBtn.disabled = wholeShares.length > 0; addTransferBtn.style.opacity = wholeShares.length > 0 ? '0.35' : '1'; }
  // Disable burn button too
  const addBurnBtn = document.getElementById('addBurnBtn');
  if (addBurnBtn) { addBurnBtn.disabled = wholeShares.length > 0; addBurnBtn.style.opacity = wholeShares.length > 0 ? '0.35' : '1'; }
  const clearAllBtn = document.getElementById('clearAllBeneBtn');
  if (clearAllBtn) clearAllBtn.style.display = (transfers.length > 0 || burns.length > 0) ? 'inline-block' : 'none';
}

async function dbClearAllBeneficiaries() {
  const transferBenes = ghostState.ghost.beneficiaries.filter(b => b.action !== 'whole-vault-share');
  if (transferBenes.length === 0) { showNotif('No beneficiaries to clear', ''); return; }

  // Classify each slot as stale (no vault balance) or working (vault has funds)
  // A working slot has a corresponding vault token with balance >= slot amount
  function _isWorkingSlot(b) {
    const vt = ghostState.vaultTokens.find(v => v.symbol === b.token || v.mint === b.mint);
    return vt && vt.balance >= b.amount && b.amount > 0;
  }
  const staleSlots   = transferBenes.filter(b => !_isWorkingSlot(b));
  const workingSlots = transferBenes.filter(b =>  _isWorkingSlot(b));

  const isDemo = !ghostState.provider || ghostState.walletName?.includes('demo');

  // If there are working slots, warn the user ‚Äî default to stale-only
  let clearWorking = false;
  if (workingSlots.length > 0) {
    clearWorking = await ghostConfirm({
      icon: '‚ö†Ô∏è', title: 'Active Beneficiaries Detected',
      message: staleSlots.length + ' stale slot(s) + ' + workingSlots.length + ' ACTIVE slot(s) found. Active slots have vault assets backing them. Clear ONLY stale slots, or everything?',
      okLabel: 'CLEAR EVERYTHING', cancelLabel: 'STALE ONLY'
    });
    // ghostConfirm returns true for ok, false for cancel. false = stale only.
  } else {
    const _ok = await ghostConfirm({
      icon: 'üóëÔ∏è', title: 'Clear ' + staleSlots.length + ' Stale Slot(s)',
      message: 'Remove ' + staleSlots.length + ' stale slot(s) with no backing vault balance in 1 transaction.',
      okLabel: 'CLEAR', danger: true
    });
    if (!_ok) return;
  }

  const toClear = clearWorking ? transferBenes : staleSlots;
  if (toClear.length === 0) { showNotif('Nothing to clear', ''); return; }

  // Refresh from chain to confirm state
  showNotif('Syncing chain state...', '');
  try { await fetchGhostAccount(); } catch(_) {}
  const freshSlots = ghostState.ghost.beneficiaries.filter(b => b.action !== 'whole-vault-share');
  if (freshSlots.length === 0) { showNotif('Already cleared on-chain', 'green'); renderBeneficiaries(); return; }

  const finalToClear = clearWorking
    ? freshSlots
    : freshSlots.filter(b => !_isWorkingSlot(b));

  if (finalToClear.length === 0) {
    showNotif('No stale slots found ‚Äî all slots have active vault backing', '');
    renderBeneficiaries(); return;
  }

  if (isDemo) {
    _saveClearedBeneficiaries(finalToClear);
    ghostState.ghost.beneficiaries = ghostState.ghost.beneficiaries.filter(
      b => b.action === 'whole-vault-share' || (clearWorking ? false : _isWorkingSlot(b))
    );
    _refreshBenePickers(); renderBeneficiaries(); renderVaultHoldings();
    showNotif('Cleared ' + finalToClear.length + ' slot(s) [demo]', 'green');
    return;
  }

  // On-chain clear using v1.4 clear_all_beneficiaries (single instruction, no loop)
  // If clearing ONLY stale: use N remove_beneficiary(0) for just those slots
  // If clearing ALL: use the new clear_all_beneficiaries instruction (one ix, atomic)
  try {
    showNotif('Sending on-chain clear...', '');
    const { PublicKey, Transaction, TransactionInstruction } = solanaWeb3;
    const walletPk = new PublicKey(ghostState.publicKey);
    const ghostPda = new PublicKey(ghostState.ghostPda);
    const connection = new solanaWeb3.Connection(RPC_URL, 'confirmed');
    const { blockhash } = await connection.getLatestBlockhash();
    const tx = new Transaction({ recentBlockhash: blockhash, feePayer: walletPk });

    if (clearWorking || finalToClear.length === freshSlots.length) {
      // Clear ALL slots ‚Äî use single clear_all_beneficiaries instruction (v1.4)
      tx.add(new TransactionInstruction({
        programId: new PublicKey(PROGRAM_ID),
        keys: [{ pubkey: ghostPda, isSigner:false, isWritable:true }, { pubkey: walletPk, isSigner:true, isWritable:true }],
        data: new Uint8Array(DISC_CLEAR_ALL_BENES)
      }));
    } else {
      // Clear only the stale slots ‚Äî still use remove_beneficiary(0) loop
      // We must remove from highest index down to avoid shifting issues... actually
      // contract shifts array down after each remove, so always target index 0 for N removes
      // But we only want to remove specific slots, so map stale slots to their on-chain indices
      // Sort stale slots by their position in freshSlots (ascending), remove from end to start
      const staleIndices = finalToClear.map(b => {
        return freshSlots.findIndex(f =>
          (f.fullAddr && f.fullAddr === b.fullAddr) ||
          (f.recipient === b.recipient && f.amount === b.amount && f.mint === b.mint)
        );
      }).filter(i => i >= 0).sort((a,b) => b - a); // descending ‚Äî remove from end first

      const removeDisc = [67, 27, 24, 153, 135, 64, 202, 77]; // remove_beneficiary disc
      for (const idx of staleIndices) {
        const d = new Uint8Array(9); d.set(removeDisc, 0); d[8] = idx;
        tx.add(new TransactionInstruction({
          programId: new PublicKey(PROGRAM_ID),
          keys: [{ pubkey: ghostPda, isSigner:false, isWritable:true }, { pubkey: walletPk, isSigner:true, isWritable:true }],
          data: d
        }));
      }
    }

    const signed = await ghostState.provider.signTransaction(tx);
    const sig = await connection.sendRawTransaction(signed.serialize(), { skipPreflight: true });
    const conf = await connection.confirmTransaction(sig, 'confirmed');
    if (conf.value?.err) throw new Error(JSON.stringify(conf.value.err));

    // Update local state
    if (clearWorking || finalToClear.length === freshSlots.length) {
      ghostState.ghost.beneficiaries = ghostState.ghost.beneficiaries.filter(b => b.action === 'whole-vault-share');
    } else {
      ghostState.ghost.beneficiaries = ghostState.ghost.beneficiaries.filter(
        b => b.action === 'whole-vault-share' || _isWorkingSlot(b)
      );
    }
    _refreshBenePickers(); renderBeneficiaries(); renderVaultHoldings();
    addActivityRow('üóëÔ∏è Cleared ' + finalToClear.length + ' beneficiar' + (finalToClear.length===1?'y':'ies'), sig.slice(0,4)+'...'+sig.slice(-4));
    showNotif('Cleared ' + finalToClear.length + ' slot(s) on-chain!', 'green');

  } catch(err) {
    console.warn('[Ghost] Clear failed:', err.message);
    // Fallback: local wipe with fingerprint persistence
    _saveClearedBeneficiaries(finalToClear);
    ghostState.ghost.beneficiaries = ghostState.ghost.beneficiaries.filter(
      b => b.action === 'whole-vault-share' || (!clearWorking && _isWorkingSlot(b))
    );
    _refreshBenePickers(); renderBeneficiaries(); renderVaultHoldings();
    showNotif('Cleared locally (on-chain failed: ' + (err.message||'unknown') + ')', '');
  }
}

// Store fingerprints of locally-wiped beneficiaries so parseGhostAccount can suppress them
// Keyed per wallet+ghost PDA to avoid cross-wallet contamination
function _clearedBeneKey() { return 'ghostClearedBenes_' + (ghostState.ghostPda || ghostState.publicKey || 'x'); }
function _saveClearedBeneficiaries(slots) {
  try {
    const existing = _loadClearedBeneficiaries();
    // Fingerprint = fullAddr + ':' + amount + ':' + mint (enough to identify stale slot)
    const newFps = slots.map(b => (b.fullAddr||b.recipient||'?') + ':' + b.amount + ':' + (b.mint||''));
    const merged = [...new Set([...existing, ...newFps])];
    localStorage.setItem(_clearedBeneKey(), JSON.stringify({ fps: merged, ts: Date.now() }));
  } catch(_) {}
}
function _loadClearedBeneficiaries() {
  try {
    const raw = localStorage.getItem(_clearedBeneKey());
    if (!raw) return [];
    const p = JSON.parse(raw);
    // Expire after 7 days ‚Äî after that the chain should have confirmed state
    if (Date.now() - (p.ts||0) > 7 * 86400000) { localStorage.removeItem(_clearedBeneKey()); return []; }
    return p.fps || [];
  } catch(_) { return []; }
}
function _isClearedLocally(b) {
  const fps = _loadClearedBeneficiaries();
  if (fps.length === 0) return false;
  const fp = (b.fullAddr||b.recipient||'?') + ':' + b.amount + ':' + (b.mint||'');
  return fps.includes(fp);
}

async function dbAddBeneficiary(action) {
  const isBurn = action === 'burn';
  const pickerKey = isBurn ? 'burn' : 'bene';
  const t = ghostState.selectedTokens[pickerKey];
  if (!t) { showNotif('Select a token first', 'error'); return; }

  // ‚îÄ‚îÄ Whole vault path ‚Äî 100% to one recipient ‚îÄ‚îÄ
  if (!isBurn && t.mint === '__whole_vault__') {
    const recipient = document.getElementById('newRecipient').value.trim();
    if (!recipient || recipient.length < 32) { showNotif('‚ö†Ô∏è Enter a valid Solana address', 'error'); return; }
    if (ghostState.vaultTokens.length === 0) { showNotif('‚ö†Ô∏è Vault is empty ‚Äî deposit assets first', 'error'); return; }
    if (ghostState.ghost.beneficiaries.some(b => b.action === 'whole-vault-share')) {
      showNotif('‚ö†Ô∏è A whole-vault recipient is already set. Remove it first.', 'error'); return;
    }
    const short = recipient.slice(0,4) + '...' + recipient.slice(-4);
    // Merge: remove any existing specific transfers/burns to this same address
    const beforeCount = ghostState.ghost.beneficiaries.length;
    ghostState.ghost.beneficiaries = ghostState.ghost.beneficiaries.filter(b => {
      const bAddr = (b.fullAddr || b.recipient || '').toLowerCase();
      const newAddr = recipient.toLowerCase();
      const shortMatch = bAddr === short.toLowerCase();
      const fullMatch = b.fullAddr && b.fullAddr.toLowerCase() === newAddr;
      return !(shortMatch || fullMatch);
    });
    const mergedCount = beforeCount - ghostState.ghost.beneficiaries.length;
    // Stage locally first so UI reflects immediately
    if (!ghostState.ghost.wholeVaultShares) ghostState.ghost.wholeVaultShares = [];
    ghostState.ghost.wholeVaultShares = [{ addr: short, fullAddr: recipient, pct: 100 }];
    ghostState.ghost.beneficiaries.push({
      recipient: short, fullAddr: recipient,
      sharePct: 100, amount: 0,
      token: 'üëª 100% of vault',
      action: 'whole-vault-share', executed: false
    });
    document.getElementById('newRecipient').value = '';
    _refreshBenePickers();
    renderBeneficiaries();
    saveSession();
    const mergeNote = mergedCount > 0 ? ' ¬∑ merged ' + mergedCount + ' existing entr' + (mergedCount === 1 ? 'y' : 'ies') : '';
    showNotif('üëª Staged ‚Üí ' + short + mergeNote + '. Sending on-chain...', 'green');
    // Fire on-chain tx immediately ‚Äî no second popup
    await dbSaveWholeVaultPlan();
    return;
  }

  const amountInput = isBurn ? 'burnAmount' : 'newAmount';
  const amount = parseFloat(document.getElementById(amountInput).value);
  if (!amount || amount <= 0) { showNotif('Enter a valid amount', 'error'); return; }

  // Validate against vault balance
  const vaultToken = ghostState.vaultTokens.find(v => v.symbol === t.symbol || v.mint === t.mint);
  if (!vaultToken) { showNotif('‚ö†Ô∏è ' + t.symbol + ' is not in your vault', 'error'); return; }
  const alreadyAssigned = ghostState.ghost.beneficiaries
    .filter(b => b.token === t.symbol)
    .reduce((sum, b) => sum + b.amount, 0);
  const remaining = vaultToken.balance - alreadyAssigned;
  if (amount > remaining) {
    showNotif('‚ö†Ô∏è Only ' + remaining.toLocaleString() + ' ' + t.symbol + ' available to assign', 'error');
    return;
  }

  let recipient = '(burn)';
  if (!isBurn) {
    recipient = document.getElementById('newRecipient').value.trim();
    if (!recipient || recipient.length < 32) { showNotif('‚ö†Ô∏è Enter a valid Solana recipient address', 'error'); return; }
    const transfers = ghostState.ghost.beneficiaries.filter(b => b.action !== 'burn');
    if (transfers.length >= 10) { showNotif('‚ö†Ô∏è Maximum 10 transfer beneficiaries', 'error'); return; }
  }

  const short = isBurn ? '(burn)' : recipient.slice(0,4)+'...'+recipient.slice(-4);

  // If this recipient already has a whole-vault-share, merge: remove it and replace with specific entry
  let mergedFromWhole = false;
  if (!isBurn && recipient && recipient !== '(burn)') {
    const recipShort = short;
    const recipFull = recipient.toLowerCase();
    const wholeIdx = ghostState.ghost.beneficiaries.findIndex(b => {
      if (b.action !== 'whole-vault-share') return false;
      const bAddr = (b.fullAddr || '').toLowerCase();
      const bShort = (b.recipient || '').toLowerCase();
      return bAddr === recipFull || bShort === recipShort.toLowerCase();
    });
    if (wholeIdx !== -1) {
      ghostState.ghost.beneficiaries.splice(wholeIdx, 1);
      mergedFromWhole = true;
    }
  }

  // Demo mode
  if (!ghostState.provider || ghostState.walletName?.includes('demo')) {
    ghostState.ghost.beneficiaries.push({ recipient: short, fullAddr: isBurn ? null : recipient, amount, token: t.symbol, action, executed: false });
    _refreshBenePickers();
    renderBeneficiaries();
    renderVaultHoldings();
    document.getElementById(amountInput).value = '';
    if (!isBurn) document.getElementById('newRecipient').value = '';
    const mergeNote = mergedFromWhole ? ' ¬∑ whole-vault assignment replaced' : '';
    const msg = isBurn ? 'üî• Burn instruction added' : ('‚úÖ Beneficiary added' + mergeNote);
    addActivityRow(isBurn ? 'üî• Burn instruction added [demo]' : 'üìã Beneficiary added [demo]', randomTx());
    showNotif(msg, 'green');
    saveSession();
    return;
  }

  // Real transaction
  try {
    showNotif(isBurn ? 'Adding burn instruction...' : 'Adding beneficiary...', '');
    const { PublicKey, Transaction, TransactionInstruction } = solanaWeb3;
    const walletPubkey = new PublicKey(ghostState.publicKey);
    const ghostPda = new PublicKey(ghostState.ghostPda);
    const programId = new PublicKey(PROGRAM_ID);

    const discriminator = [105, 214, 106, 141, 180, 166, 123, 238];

    // Args: recipient(32), amount(u64), token_mint(Option<Pubkey>=33), action(u8) = 74 bytes
    // Use actual token decimals (not hardcoded 6)
    const tokenDecimals = t.decimals ?? 6;
    const amountRaw = BigInt(Math.round(amount * Math.pow(10, tokenDecimals)));
    const buf = new ArrayBuffer(32 + 8 + 33 + 1);
    const dv = new DataView(buf);
    const bufBytes = new Uint8Array(buf);

    // recipient: Pubkey (32 bytes) - zero for burn
    if (!isBurn) {
      bufBytes.set(new PublicKey(recipient).toBytes(), 0);
    }
    // amount: u64 (8 bytes at offset 32)
    dv.setBigUint64(32, amountRaw, true);
    // token_mint: Option<Pubkey> (33 bytes at offset 40)
    // Send Some(mint) so contract records which token this beneficiary targets
    const mintForTx = t.mint === 'native' ? WSOL_MINT_PK_STR : t.mint;
    try {
      bufBytes[40] = 1; // Some tag
      bufBytes.set(new PublicKey(mintForTx).toBytes(), 41);
    } catch(_) {
      bufBytes[40] = 0; // None fallback
    }
    // action: u8 (offset 73) - 0=Transfer, 1=Burn
    bufBytes[73] = isBurn ? 1 : 0;

    const data = new Uint8Array(8 + buf.byteLength);
    data.set(discriminator, 0);
    data.set(bufBytes, 8);

    // ManageBeneficiaries context: ghost(mut), signer(mut)
    const ix = new TransactionInstruction({ programId,
      keys: [
        { pubkey: ghostPda,    isSigner: false, isWritable: true },
        { pubkey: walletPubkey, isSigner: true,  isWritable: true },
      ],
      data });

    const connection = new solanaWeb3.Connection(RPC_URL, 'confirmed');
    const { blockhash } = await connection.getLatestBlockhash();
    const tx = new Transaction({ recentBlockhash: blockhash, feePayer: walletPubkey });
    tx.add(ix);
    // Debug: log each instruction individually so console doesn't collapse
    tx.instructions.forEach((ix, i) => 
      console.log(`[Ghost] ix${i}: prog=${ix.programId.toBase58()} accounts=${ix.keys.length} data=${ix.data.length}b`)
    );
    const signed = await ghostState.provider.signTransaction(tx);
    const sig = await connection.sendRawTransaction(signed.serialize(), { skipPreflight: true, preflightCommitment: 'confirmed' });
    console.log('[Ghost] TX sent:', sig);
    const conf = await connection.confirmTransaction(sig, 'confirmed');
    console.log('[Ghost] TX confirmed:', conf);
    if (conf.value?.err) throw new Error('TX failed: ' + JSON.stringify(conf.value.err));
    const shortSig = sig.slice(0,4)+'...'+sig.slice(-4);

    ghostState.ghost.beneficiaries.push({ recipient: short, fullAddr: isBurn ? null : recipient, amount, token: t.symbol, action, executed: false });
    _refreshBenePickers();
    renderBeneficiaries();
    renderVaultHoldings();
    document.getElementById(amountInput).value = '';
    if (!isBurn) document.getElementById('newRecipient').value = '';
    addActivityRow(isBurn ? 'üî• Burn instruction' : ('üéØ Beneficiary added ¬∑ ' + short), shortSig);
    const mergeNote2 = mergedFromWhole ? ' ¬∑ whole-vault assignment replaced' : '';
    showNotif(isBurn ? 'üî• Burn instruction confirmed!' : ('‚úÖ Beneficiary added on-chain!' + mergeNote2), 'green');
  } catch(err) {
    console.error('Add beneficiary error:', err);
    showNotif('Failed: ' + (err.message || err), 'error');
  }
}

async function dbRemoveBeneficiary(index, _silent) {
  if (!_silent) { const _ok1 = await ghostConfirm({ icon:'üóëÔ∏è', title:'Remove Beneficiary', message:'Remove this beneficiary? This sends a transaction to update the on-chain record.', okLabel:'REMOVE', danger:true }); if (!_ok1) return; }

  const entry = ghostState.ghost.beneficiaries[index];

  // Whole-vault-share: delegate to on-chain clear (set_whole_vault_recipient None)
  if (entry?.action === 'whole-vault-share') {
    await dbClearWholeVaultRecipient(true); // skip second confirm, already confirmed above
    _refreshBenePickers(); renderVaultHoldings();
    return;
  }

  // Demo mode - local only
  if (!ghostState.provider || ghostState.walletName?.includes('demo')) {
    ghostState.ghost.beneficiaries.splice(index, 1);
    _refreshBenePickers(); renderBeneficiaries(); renderVaultHoldings();
    saveSession(); showNotif('Removed [demo]', 'green');
    return;
  }

  // On-chain remove_beneficiary(index: u8)
  // on-chain index = count of non-whole-vault-share entries before this position
  const onChainIndex = ghostState.ghost.beneficiaries
    .slice(0, index)
    .filter(b => b.action !== 'whole-vault-share')
    .length;

  try {
    showNotif('Removing beneficiary on-chain...', '');
    const { PublicKey, Transaction, TransactionInstruction } = solanaWeb3;
    const walletPk = new PublicKey(ghostState.publicKey);
    const ghostPda = new PublicKey(ghostState.ghostPda);
    const programId = new PublicKey(PROGRAM_ID);

    const disc = [67, 27, 24, 153, 135, 64, 202, 77];
    const data = new Uint8Array(9);
    data.set(disc, 0);
    data[8] = onChainIndex;

    const ix = new TransactionInstruction({ programId,
      keys: [
        { pubkey: ghostPda, isSigner: false, isWritable: true },
        { pubkey: walletPk, isSigner: true,  isWritable: true },
      ],
      data
    });

    const connection = new solanaWeb3.Connection(RPC_URL, 'confirmed');
    const { blockhash } = await connection.getLatestBlockhash();
    const tx = new Transaction({ recentBlockhash: blockhash, feePayer: walletPk });
    tx.add(ix);
    const signed = await ghostState.provider.signTransaction(tx);
    const sig = await connection.sendRawTransaction(signed.serialize(), { skipPreflight: true });
    const conf = await connection.confirmTransaction(sig, 'confirmed');
    if (conf.value?.err) throw new Error('TX failed: ' + JSON.stringify(conf.value.err));

    ghostState.ghost.beneficiaries.splice(index, 1);
    _refreshBenePickers(); renderBeneficiaries(); renderVaultHoldings();
    const _removedAddr = entry.fullAddr ? entry.fullAddr.slice(0,4)+'...'+entry.fullAddr.slice(-4) : (entry.recipient||'');
    addActivityRow('‚ùå Beneficiary removed ¬∑ ' + _removedAddr, sig.slice(0,4)+'...'+sig.slice(-4));
    showNotif('Beneficiary removed on-chain!', 'green');
  } catch(err) {
    console.error('Remove beneficiary error:', err);
    showNotif('Failed: ' + (err.message || err), 'error');
  }
}

// ‚îÄ‚îÄ‚îÄ Bene amount helpers ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function updateBeneRemaining() {
  const t = ghostState.selectedTokens.bene;
  const lbl = document.getElementById('beneRemainingLabel');
  if (!lbl || !t) return;
  const vt = ghostState.vaultTokens.find(v => v.mint === t.mint);
  if (!vt) return;
  const assigned = ghostState.ghost.beneficiaries
    .filter(b => b.token === t.symbol && b.action !== 'whole-vault-share')
    .reduce((s, b) => s + b.amount, 0);
  const rem = vt.balance - assigned;
  lbl.textContent = '¬∑ ' + rem.toLocaleString() + ' ' + t.symbol + ' remaining';
  lbl.style.color = rem <= 0 ? '#ff3d5a' : 'var(--muted)';
}

function fillMaxBene() {
  const t = ghostState.selectedTokens.bene;
  if (!t) return;
  const vt = ghostState.vaultTokens.find(v => v.mint === t.mint);
  if (!vt) return;
  const assigned = ghostState.ghost.beneficiaries
    .filter(b => b.token === t.symbol && b.action !== 'whole-vault-share')
    .reduce((s, b) => s + b.amount, 0);
  const rem = Math.max(0, vt.balance - assigned);
  document.getElementById('newAmount').value = rem;
  updateBeneRemaining();
}

// ‚îÄ‚îÄ‚îÄ Whole vault plan ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
if (!ghostState.ghost.wholeVaultShares) ghostState.ghost.wholeVaultShares = [];

function renderWholeVaultShares() {
  const shares = ghostState.ghost.wholeVaultShares || [];
  const el = document.getElementById('wholeVaultShares');
  if (!el) return;
  if (shares.length === 0) { el.innerHTML = ''; return; }
  const s = shares[0];
  const isOnChain = ghostState.ghost.wholeVaultRecipient === s.fullAddr;
  const statusSpan = isOnChain
    ? '<span style="font-family:monospace;font-size:10px;color:#33ff99;letter-spacing:0.1em">ON-CHAIN</span>'
    : '<span style="font-family:monospace;font-size:10px;color:#ff9933;letter-spacing:0.1em">PENDING</span>';
  el.innerHTML =
    '<div style="display:flex;align-items:center;gap:10px;padding:10px 14px;background:rgba(102,51,255,0.06);border:1px solid rgba(160,128,255,0.2);margin-bottom:8px">' +
    '<span style="font-family:monospace;font-size:11px;color:#a080ff;width:80px">100% of vault</span>' +
    '<span style="font-family:monospace;font-size:12px;color:#f0f0f8;flex:1">' + s.addr + '</span>' +
    statusSpan +
    '<button class="icon-btn" onclick="removeWholeVaultShare(0)" style="color:#ff6666" title="Remove">x</button>' +
    '</div>';
}

function updateSharePreview() {
  const el = document.getElementById('wholeVaultPreview');
  if (!el) return;
  const pct = 100; // always 100%
  if (!pct || pct <= 0) { el.textContent = ''; return; }
  // Show what this share would receive from current vault
  const lines = ghostState.vaultTokens
    .filter(v => v.balance >= 0)  // include dust amounts
    .map(v => {
      const amt = (v.balance * pct / 100);
      const price = getTokenPrice(v);
      const usd = price > 0 ? ' (~$' + (amt * price).toFixed(2) + ')' : '';
      return amt.toLocaleString(undefined, {maximumFractionDigits:4}) + ' ' + v.symbol + usd;
    });
  el.textContent = lines.length ? pct + '% share = ' + lines.join(' + ') : 'Deposit assets to vault first';
}

function addWholeVaultShare() {
  const addr = document.getElementById('wholeVaultAddr').value.trim();
  if (!addr || addr.length < 32) { showNotif('Enter a valid Solana address', 'error'); return; }
  if (!ghostState.ghost.wholeVaultShares) ghostState.ghost.wholeVaultShares = [];
  // Contract stores single Option<Pubkey> - replace any existing entry
  const short = addr.slice(0,4) + '...' + addr.slice(-4);
  ghostState.ghost.wholeVaultShares = [{ addr: short, fullAddr: addr, pct: 100 }];
  document.getElementById('wholeVaultAddr').value = '';
  const pctEl = document.getElementById('wholeVaultPct');
  if (pctEl) pctEl.value = '';
  renderWholeVaultShares();
}

async function removeWholeVaultShare(i) {
  // If already on-chain, clear it on-chain
  const share = ghostState.ghost.wholeVaultShares?.[i];
  if (ghostState.ghost.wholeVaultRecipient && ghostState.ghost.wholeVaultRecipient === share?.fullAddr) {
    await dbClearWholeVaultRecipient(true); // skipConfirm ‚Äî already confirmed above
    return;
  }
  // Just a pending local entry - remove locally
  ghostState.ghost.wholeVaultShares.splice(i, 1);
  renderWholeVaultShares();
}

async function dbSaveWholeVaultPlan() {
  const shares = ghostState.ghost.wholeVaultShares || [];
  if (shares.length === 0) { showNotif('Add a recipient first', 'error'); return; }
  const share = shares[0]; // contract stores single Option<Pubkey>
  const recipient = share.fullAddr;
  if (!recipient || recipient.length < 32) { showNotif('Invalid recipient address', 'error'); return; }

  if (!ghostState.provider || ghostState.walletName?.includes('demo')) {
    _applyWholeVaultLocally(share);
    showNotif('Whole vault recipient set [demo]', 'green');
    addActivityRow('Whole vault -> ' + share.addr + ' [demo]', '');
    return;
  }

  try {
    showNotif('Setting whole vault recipient on-chain...', '');
    const { PublicKey, Transaction, TransactionInstruction } = solanaWeb3;
    const walletPk = new PublicKey(ghostState.publicKey);
    const ghostPda = new PublicKey(ghostState.ghostPda);
    const programId = new PublicKey(PROGRAM_ID);

    // set_whole_vault_recipient(recipient: Option<Pubkey>)
    // Borsh: [1 tag][32 pubkey bytes] = 33 bytes
    const disc = [217, 239, 225, 75, 244, 14, 252, 91];
    const argBytes = new Uint8Array(33);
    argBytes[0] = 1; // Some
    argBytes.set(new PublicKey(recipient).toBytes(), 1);
    const data = new Uint8Array(41);
    data.set(disc, 0);
    data.set(argBytes, 8);

    const ix = new TransactionInstruction({ programId,
      keys: [
        { pubkey: ghostPda, isSigner: false, isWritable: true },
        { pubkey: walletPk, isSigner: true,  isWritable: true },
      ],
      data
    });

    const connection = new solanaWeb3.Connection(RPC_URL, 'confirmed');
    const { blockhash } = await connection.getLatestBlockhash();
    const tx = new Transaction({ recentBlockhash: blockhash, feePayer: walletPk });
    tx.add(ix);
    const signed = await ghostState.provider.signTransaction(tx);
    const sig = await connection.sendRawTransaction(signed.serialize(), { skipPreflight: true });
    const conf = await connection.confirmTransaction(sig, 'confirmed');
    if (conf.value?.err) throw new Error('TX failed: ' + JSON.stringify(conf.value.err));

    ghostState.ghost.wholeVaultRecipient = recipient;
    _applyWholeVaultLocally(share);
    addActivityRow('Whole vault recipient ‚Üí ' + share.addr, sig.slice(0,4)+'...'+sig.slice(-4));
    showNotif('Whole vault recipient set on-chain!', 'green');
  } catch(err) {
    console.error('set_whole_vault_recipient error:', err);
    showNotif('Failed: ' + (err.message || err), 'error');
  }
}

async function dbClearWholeVaultRecipient(skipConfirm) {
  if (!skipConfirm) { const _ok2 = await ghostConfirm({ icon:'üëª', title:'Remove Whole Vault Recipient', message:'Clear the whole-vault recipient on-chain? This requires a transaction signature.', okLabel:'REMOVE', danger:true }); if (!_ok2) return; }

  if (!ghostState.provider || ghostState.walletName?.includes('demo')) {
    _clearWholeVaultLocally();
    showNotif('Whole vault recipient cleared [demo]', 'green');
    return;
  }

  try {
    showNotif('Clearing whole vault recipient on-chain...', '');
    const { PublicKey, Transaction, TransactionInstruction } = solanaWeb3;
    const walletPk = new PublicKey(ghostState.publicKey);
    const ghostPda = new PublicKey(ghostState.ghostPda);
    const programId = new PublicKey(PROGRAM_ID);

    // set_whole_vault_recipient(None) - tag=0 only
    const disc = [217, 239, 225, 75, 244, 14, 252, 91];
    const data = new Uint8Array(9);
    data.set(disc, 0);
    data[8] = 0; // None tag

    const ix = new TransactionInstruction({ programId,
      keys: [
        { pubkey: ghostPda, isSigner: false, isWritable: true },
        { pubkey: walletPk, isSigner: true,  isWritable: true },
      ],
      data
    });

    const connection = new solanaWeb3.Connection(RPC_URL, 'confirmed');
    const { blockhash } = await connection.getLatestBlockhash();
    const tx = new Transaction({ recentBlockhash: blockhash, feePayer: walletPk });
    tx.add(ix);
    const signed = await ghostState.provider.signTransaction(tx);
    const sig = await connection.sendRawTransaction(signed.serialize(), { skipPreflight: true });
    const conf = await connection.confirmTransaction(sig, 'confirmed');
    if (conf.value?.err) throw new Error('TX failed: ' + JSON.stringify(conf.value.err));

    ghostState.ghost.wholeVaultRecipient = null;
    _clearWholeVaultLocally();
    addActivityRow('Whole vault recipient cleared', sig.slice(0,4)+'...'+sig.slice(-4));
    showNotif('Whole vault recipient cleared on-chain!', 'green');
  } catch(err) {
    console.error('clear whole vault error:', err);
    showNotif('Failed: ' + (err.message || err), 'error');
  }
}

function _applyWholeVaultLocally(share) {
  ghostState.ghost.beneficiaries = ghostState.ghost.beneficiaries.filter(b => b.action !== 'whole-vault-share');
  ghostState.ghost.beneficiaries.push({
    recipient: share.addr, fullAddr: share.fullAddr,
    sharePct: 100, amount: 0, token: 'VAULT x100%',
    action: 'whole-vault-share', executed: false
  });
  renderBeneficiaries();
  renderWholeVaultShares();
  saveSession();
}

function _clearWholeVaultLocally() {
  ghostState.ghost.wholeVaultRecipient = null;
  ghostState.ghost.wholeVaultShares = [];
  ghostState.ghost.beneficiaries = ghostState.ghost.beneficiaries.filter(b => b.action !== 'whole-vault-share');
  renderBeneficiaries();
  renderWholeVaultShares();
  saveSession();
}

// ‚îÄ‚îÄ‚îÄ Vault ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ




// ‚îÄ‚îÄ‚îÄ Settings ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ






// ‚îÄ‚îÄ‚îÄ Recovery ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ




// ‚îÄ‚îÄ‚îÄ Watcher ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
async function dbLookupSoul() {
  const addr = document.getElementById('soulToCheck').value.trim();
  if (!addr) { showNotif('Enter a wallet address'); return; }
  
  const result = document.getElementById('watcherResult');
  result.classList.add('visible');
  result.innerHTML = '<span style="color:#c0bce0">Looking up soul...</span>';

  try {
    // Derive ghost PDA for this address
    const { PublicKey } = solanaWeb3;
    const wallet = new PublicKey(addr);
    const programId = new PublicKey(PROGRAM_ID);
    const [ghostPda] = PublicKey.findProgramAddressSync(
      [new TextEncoder().encode('ghost'), wallet.toBytes()],
      programId
    );

    const response = await fetch(RPC_URL, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        jsonrpc: '2.0', id: 1,
        method: 'getAccountInfo',
        params: [ghostPda.toString(), { encoding: 'base64' }]
      })
    });
    const data = await response.json();

    if (!data.result?.value) {
      result.innerHTML = `
        <span style="color:#c0bce0">SOUL</span> &nbsp;${addr.slice(0,8)}...<br>
        <span style="color:#c0bce0">STATUS</span> &nbsp;<span style="color:#c0bce0">NO GHOST FOUND</span><br>
        <span style="color:rgba(120,80,255,0.4)">// This address has no ghost protocol account</span>
      `;
      return;
    }

    // Decode basic info
    const rawData = atob(data.result.value.data[0]);
    const bytes = new Uint8Array(rawData.length);
    for (let i = 0; i < rawData.length; i++) bytes[i] = rawData.charCodeAt(i);
    const view = new DataView(bytes.buffer);
    
    let offset = 8 + 32; // skip discriminator + owner
    // recovery_wallets: [Option<Pubkey>; 3] ‚Äî 3 √ó 33 bytes = 99 bytes fixed (v1.5)
    offset += 99;
    const lastBeat = Number(view.getBigInt64(offset, true)); offset += 8;
    const interval = Number(view.getBigInt64(offset, true)); offset += 8;
    const grace = Number(view.getBigInt64(offset, true)); offset += 8;
    const awakened = bytes[offset] === 1; offset += 1;
    // awakened_at: Option<i64> - None=1byte, Some=9bytes
    const awTag = bytes[offset]; offset += 1;
    if (awTag === 1) offset += 8;
    const executed = bytes[offset] === 1;

    const now = Math.floor(Date.now() / 1000);
    const silenceSeconds = now - lastBeat;
    const remainingSeconds = Math.max(0, interval - silenceSeconds);
    const remainingDays = Math.floor(remainingSeconds / 86400);
    const lastPingDays = Math.floor(silenceSeconds / 86400);

    let status, statusColor, statusNote;
    if (executed) {
      status = 'EXECUTED'; statusColor = '#ff3366';
      statusNote = '// Ghost has been executed ‚Äî assets distributed';
    } else if (awakened) {
      status = 'AWAKENED üëª'; statusColor = '#ffaa33';
      statusNote = '// Grace period active ‚Äî recovery wallet can still cancel';
    } else if (silenceSeconds > interval) {
      status = 'SILENT ‚ö†Ô∏è'; statusColor = '#ffaa33';
      statusNote = '// Silence detected ‚Äî grace period may be active';
    } else {
      status = 'ALIVE'; statusColor = '#33ff99';
      statusNote = '// Soul is alive (' + remainingDays + ' days remaining)';
    }

    result.innerHTML = `
      <span style="color:#c0bce0">SOUL</span> &nbsp;${addr.slice(0,8)}...<br>
      <span style="color:#c0bce0">GHOST PDA</span> &nbsp;${ghostPda.toString().slice(0,8)}...<br>
      <span style="color:#c0bce0">STATUS</span> &nbsp;<span style="color:${statusColor}">${status}</span><br>
      <span style="color:#c0bce0">LAST PING</span> &nbsp;${lastPingDays} days ago<br>
      <span style="color:#c0bce0">INTERVAL</span> &nbsp;${Math.floor(interval/86400)} days<br>
      <span style="color:#c0bce0">GRACE PERIOD</span> &nbsp;${Math.floor(grace/86400)} days<br>
      <span style="color:rgba(120,80,255,0.4)">${statusNote}</span>
    `;
  } catch(err) {
    result.innerHTML = '<span style="color:var(--pulse)">Error: ' + (err.message || err) + '</span>';
  }
}

async function cancelAwakening() {
  if (!ghostState.provider || ghostState.walletName?.includes('demo')) {
    ghostState.ghost.status = 'alive';
    ghostState.ghost.awakened = false;
    ghostState.ghost.awakenedAt = null;
    ghostState.ghost.lastHeartbeat = Date.now();
    showNotif('‚úÖ Awakening cancelled [demo]', 'green');
    renderDashboard();
    return;
  }
  try {
    showNotif('Cancelling awakening...', '');
    const { PublicKey, Transaction, TransactionInstruction } = solanaWeb3;
    const walletPk = new PublicKey(ghostState.publicKey);
    // cancel_awakening can be called by owner OR recovery wallet
    // ghostPda derived from the OWNER's key, not necessarily connected wallet
    const ownerKey = ghostState.ghost.ownerPubkey || ghostState.publicKey;
    const [ghostPda] = await PublicKey.findProgramAddress(
      [new TextEncoder().encode('ghost'), new PublicKey(ownerKey).toBytes()],
      new PublicKey(PROGRAM_ID)
    );
    const programId = new PublicKey(PROGRAM_ID);

    // Discriminator: sha256("global:cancel_awakening")[0:8]
    const disc = [22, 144, 208, 215, 15, 165, 157, 122]; // sha256('global:cancel_awakening')[0:8]
    const ix = new TransactionInstruction({
      programId,
      keys: [
        { pubkey: ghostPda, isSigner: false, isWritable: true },
        { pubkey: walletPk, isSigner: true, isWritable: false },
      ],
      data: new Uint8Array(disc)
    });

    const connection = new solanaWeb3.Connection(RPC_URL, 'confirmed');
    const { blockhash } = await connection.getLatestBlockhash();
    const tx = new Transaction({ recentBlockhash: blockhash, feePayer: walletPk });
    tx.add(ix);
    // Debug: log each instruction individually so console doesn't collapse
    tx.instructions.forEach((ix, i) => 
      console.log(`[Ghost] ix${i}: prog=${ix.programId.toBase58()} accounts=${ix.keys.length} data=${ix.data.length}b`)
    );
    const signed = await ghostState.provider.signTransaction(tx);
    const sig = await connection.sendRawTransaction(signed.serialize(), { skipPreflight: true });
    await connection.confirmTransaction(sig, 'confirmed');

    ghostState.ghost.status = 'alive';
    ghostState.ghost.awakened = false;
    ghostState.ghost.awakenedAt = null;
    ghostState.ghost.lastHeartbeat = Date.now();
    showNotif('‚úÖ Awakening cancelled!', 'green');
    renderDashboard();
    addActivityRow('üõë Awakening cancelled', sig.slice(0,4)+'...'+sig.slice(-4));
  } catch(err) {
    showNotif('Cancel failed: ' + (err.message || err), 'error');
  }
}

// ‚îÄ‚îÄ‚îÄ Recovery wallet mode ‚Äî check if connected wallet is someone's recovery ‚îÄ‚îÄ
function setWatcherMode(mode) {
  const obs = document.getElementById('watcherPanelObserve');
  const grd = document.getElementById('watcherPanelGuardian');
  const btnObs = document.getElementById('watcherModeObserve');
  const btnGrd = document.getElementById('watcherModeGuardian');
  if (mode === 'observe') {
    obs.style.display = ''; grd.style.display = 'none';
    btnObs.style.background = 'rgba(102,51,255,0.2)'; btnObs.style.color = '#c8a8ff';
    btnObs.style.border = '1px solid rgba(102,51,255,0.4)';
    btnGrd.style.background = 'transparent'; btnGrd.style.color = '#606080';
    btnGrd.style.border = '1px solid rgba(102,51,255,0.15)';
  } else {
    obs.style.display = 'none'; grd.style.display = '';
    btnGrd.style.background = 'rgba(255,153,102,0.15)'; btnGrd.style.color = '#ffcc99';
    btnGrd.style.border = '1px solid rgba(255,153,102,0.5)';
    btnObs.style.background = 'transparent'; btnObs.style.color = '#606080';
    btnObs.style.border = '1px solid rgba(102,51,255,0.15)';
  }
}

async function scanGuardianAssignments() {
  if (!ghostState.publicKey) { showNotif('Connect your wallet first', 'error'); return; }
  const statusEl = document.getElementById('guardianScanStatus');
  const listEl = document.getElementById('guardianAssignmentsList');
  const scanEl = document.getElementById('guardianScanState');

  statusEl.textContent = '‚ü≥ Scanning chain for ghost accounts...';
  statusEl.style.color = '#c0a0ff';

  try {
    const { PublicKey } = solanaWeb3;
    const connection = new solanaWeb3.Connection(RPC_URL, 'confirmed');
    const programId = new PublicKey(PROGRAM_ID);
    const myPk = new PublicKey(ghostState.publicKey);
    const myBytes = myPk.toBytes();

    // getProgramAccounts with memcmp filters:
    // GhostAccount layout after 8-byte discriminator (v1.5):
    // owner(32), recovery_wallets([Option<Pubkey>;3]=99)
    // Each slot: 1-byte tag + 32-byte pubkey. Offsets for pubkeys:
    //   slot 0 pubkey: off 8+32+1 = 41
    //   slot 1 pubkey: off 8+32+34 = 74
    //   slot 2 pubkey: off 8+32+67 = 107
    // We run 3 separate queries and deduplicate.
    const slotOffsets = [41, 74, 107];
    const allAccounts = [];
    for (const slotOff of slotOffsets) {
      const results = await connection.getProgramAccounts(programId, {
        filters: [
          { memcmp: { offset: slotOff, bytes: myPk.toBase58() } }
        ]
      });
      for (const r of results) {
        if (!allAccounts.find(a => a.pubkey.equals(r.pubkey))) allAccounts.push(r);
      }
    }
    const accounts = allAccounts;

    if (accounts.length === 0) {
      statusEl.textContent = '‚Äî No guardian assignments found for this wallet';
      statusEl.style.color = '#9090a8';
      return;
    }

    statusEl.textContent = '';
    scanEl.style.paddingBottom = '0';

    // Decode each account
    const cards = [];
    for (const { pubkey, account } of accounts) {
      try {
        const bytes = new Uint8Array(account.data);
        const view = new DataView(bytes.buffer);
        let off = 8;
        // owner pubkey
        const ownerBytes = bytes.slice(off, off+32); off += 32;
        const B58 = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';
        let n = 0n; for (const b of ownerBytes) n = n*256n+BigInt(b);
        let ownerB58 = ''; let tmp = n;
        while(tmp>0n){ownerB58=B58[Number(tmp%58n)]+ownerB58;tmp=tmp/58n;}
        // skip recovery_wallets [Option<Pubkey>; 3] = 99 bytes (v1.5)
        off += 99;
        // last_heartbeat, interval, grace
        const lastBeat = Number(view.getBigInt64(off,true)); off+=8;
        const interval = Number(view.getBigInt64(off,true)); off+=8;
        const grace = Number(view.getBigInt64(off,true)); off+=8;
        // awakened
        const awakened = bytes[off]===1; off++;
        // awakened_at
        const awTag = bytes[off]; off++;
        if(awTag===1) off+=8;
        // executed
        const executed = bytes[off]===1;

        const now = Math.floor(Date.now()/1000);
        const silenceSeconds = now - lastBeat;
        const remainingSeconds = Math.max(0, interval - silenceSeconds);
        const daysSince = Math.floor(silenceSeconds/86400);
        const daysLeft = Math.floor(remainingSeconds/86400);
        const statusColor = executed ? '#ff3366' : awakened ? '#ffaa33' : '#33ff99';
        const statusText = executed ? 'EXECUTED' : awakened ? '‚ö†Ô∏è AWAKENED' : '‚úÖ ALIVE';
        const graceLeft = awakened ? Math.max(0, Math.floor((grace - silenceSeconds + interval)/86400)) : 0;

        const inGrace = awakened && !executed && graceLeft > 0;

        cards.push(`
          <div style="background:#07070f;border:1px solid ${awakened?'rgba(255,170,51,0.35)':'rgba(102,51,255,0.2)'};padding:20px 22px;margin-bottom:12px" data-owner="${ownerB58}" data-awakened="${awakened}" data-executed="${executed}">
            <div style="display:flex;justify-content:space-between;align-items:flex-start;margin-bottom:14px">
              <div>
                <div style="font-family:'Share Tech Mono',monospace;font-size:11px;color:var(--muted);letter-spacing:0.15em;margin-bottom:4px">SOUL</div>
                <div style="font-family:'Share Tech Mono',monospace;font-size:13px;color:#e0ddf0">${ownerB58.slice(0,8)}...${ownerB58.slice(-6)}</div>
              </div>
              <div style="text-align:right">
                <div style="font-family:'Share Tech Mono',monospace;font-size:11px;color:var(--muted);letter-spacing:0.15em;margin-bottom:4px">STATUS</div>
                <div style="font-family:'Share Tech Mono',monospace;font-size:13px;color:${statusColor}">${statusText}</div>
              </div>
            </div>
            <div style="display:flex;gap:24px;font-family:'Share Tech Mono',monospace;font-size:12px;color:#9090a8;margin-bottom:14px">
              <span>Last ping: <span style="color:#c0bce0">${daysSince}d ago</span></span>
              <span>Interval: <span style="color:#c0bce0">${Math.floor(interval/86400)}d</span></span>
              ${awakened&&!executed ? `<span>Grace left: <span style="color:#ffaa33">${graceLeft}d</span></span>` : `<span>Time left: <span style="color:#c0bce0">${daysLeft}d</span></span>`}
            </div>
            ${!executed ? `
            <div style="display:flex;gap:8px;padding-top:14px;border-top:1px solid rgba(102,51,255,0.12)">
              ${inGrace
                ? `<button class="db-btn" style="flex:1;border-color:#ffaa33;color:#ffaa33;padding:10px" onclick="guardianCancelAwakening('${ownerB58}')">üõë Cancel Awakening</button>`
                : `<button class="db-btn" style="flex:1;border-color:#555;color:#666;padding:10px;cursor:not-allowed;opacity:0.4" disabled title="Ghost is not in grace period">üõë Cancel Awakening</button>`
              }
              <button class="db-btn" style="flex:1;background:rgba(0,220,170,0.1);border-color:rgba(0,220,170,0.55);color:#80ffd8;padding:10px;font-weight:600;box-shadow:0 0 12px rgba(0,200,150,0.15)" onclick="guardianWithdrawAll('${ownerB58}')">üì§ Withdraw Vault</button>
            </div>` : `
            <div style="padding-top:12px;border-top:1px solid rgba(255,51,102,0.15);font-family:'Share Tech Mono',monospace;font-size:11px;color:#ff3366;letter-spacing:0.1em">‚ö† EXECUTED ‚Äî ghost protocol has run</div>`}
          </div>`);
      } catch(e) { /* skip malformed */ }
    }

    listEl.innerHTML = `
      <div style="font-family:'Share Tech Mono',monospace;font-size:11px;letter-spacing:0.2em;color:var(--muted);margin-bottom:14px">${cards.length} SOUL${cards.length!==1?'S':''} UNDER YOUR PROTECTION</div>
      ${cards.join('')}`;
    listEl.style.display = '';
  } catch(err) {
    statusEl.textContent = 'Scan failed: ' + (err.message||err);
    statusEl.style.color = '#ff3366';
  }
}

async function guardianCancelAwakening(ownerAddress) {
  ghostState.ghost.ownerPubkey = ownerAddress;
  await cancelAwakening();
  await scanGuardianAssignments(); // refresh
}

async function guardianWithdrawAll(ownerAddress) {
  if (!ghostState.provider) { showNotif('Connect your wallet first', 'error'); return; }
  const _ok3 = await ghostConfirm({ icon:'üîì', title:'Guardian Withdrawal', message:'Withdraw all vault assets from ' + ownerAddress.slice(0,4) + '...' + ownerAddress.slice(-4) + ' to your recovery wallet? Each asset type requires one signature.', okLabel:'WITHDRAW ALL' }); if (!_ok3) return;

  try {
    showNotif('Preparing guardian withdrawal...', '');
    const { PublicKey, Transaction, TransactionInstruction } = solanaWeb3;
    const connection = new solanaWeb3.Connection(RPC_URL, 'confirmed');
    const programId = new PublicKey(PROGRAM_ID);
    const ownerPk = new PublicKey(ownerAddress);
    const recoveryWalletPk = new PublicKey(ghostState.publicKey);

    // Derive ghost and vault PDAs from owner (not signer)
    const [ghostPda] = await PublicKey.findProgramAddress(
      [new TextEncoder().encode('ghost'), ownerPk.toBytes()], programId
    );
    const [vaultPda] = await PublicKey.findProgramAddress(
      [new TextEncoder().encode('vault'), ownerPk.toBytes()], programId
    );
    console.log('[Ghost] Guardian withdraw - ghost:', ghostPda.toBase58(), 'vault:', vaultPda.toBase58());

    // Fetch all vault token accounts
    const TOKEN_PROG_STR = 'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA';
    const TOKEN22_PROG_STR = 'TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb';
    const fetchTAs = async (owner, prog) => {
      const r = await fetch(RPC_URL, { method:'POST', headers:{'Content-Type':'application/json'},
        body: JSON.stringify({ jsonrpc:'2.0', id:1, method:'getTokenAccountsByOwner',
          params:[owner.toBase58(), {programId:prog}, {encoding:'jsonParsed'}]
        })
      });
      return (await r.json()).result?.value || [];
    };
    // Derive stake_vault PDA for the owner so we can exclude staked GHOST
    const [ownerStakeVaultPda] = await PublicKey.findProgramAddress(
      [new TextEncoder().encode('stake_vault'), ownerPk.toBytes()], programId
    );
    const ownerStakeVaultKey = ownerStakeVaultPda.toBase58();

    const allAcctsRaw = [
      ...await fetchTAs(vaultPda, TOKEN_PROG_STR),
      ...await fetchTAs(vaultPda, TOKEN22_PROG_STR)
    ];
    // Exclude staked GHOST (stake_vault PDA), GHOST mint, and DBD mint entirely
    const WSOL_MINT_STR_G = 'So11111111111111111111111111111111111111112';
    const allAccts = allAcctsRaw.filter(a => {
      if (a.pubkey === ownerStakeVaultKey) return false; // staked GHOST ‚Äî protocol-locked
      const mint = a.account?.data?.parsed?.info?.mint;
      if (mint && isProtocolMint(mint)) return false; // GHOST/DBD ‚Äî protocol-only
      return true;
    });

    // Separate wSOL accounts (need keypair unwrap) from regular SPL
    const wsolAccts = allAccts.filter(a => a.account?.data?.parsed?.info?.mint === WSOL_MINT_STR_G);
    const splAccts  = allAccts.filter(a => a.account?.data?.parsed?.info?.mint !== WSOL_MINT_STR_G);

    // Check native SOL balance too ‚Äî vault may have SOL without SPL tokens
    let _nativeSolLamps = 0;
    try {
      const _solRes = await fetch(RPC_URL, {method:'POST',headers:{'Content-Type':'application/json'},
        body:JSON.stringify({jsonrpc:'2.0',id:'vsol',method:'getBalance',params:[vaultPda.toBase58()]})});
      _nativeSolLamps = (await _solRes.json()).result?.value || 0;
    } catch(_) {}
    const _vaultHasAssets = allAccts.length > 0 || _nativeSolLamps > 10000000; // >0.01 SOL above rent

    if (!_vaultHasAssets) { showNotif('Vault is already empty ‚Äî nothing to withdraw', ''); return; }

    // Note: remove_beneficiary requires the owner as signer (ConstraintSeeds) so a guardian
    // cannot clear beneficiaries on-chain. They are fingerprinted and wiped locally after
    // successful withdrawal in the post-success block below.

    // recovery_withdraw discriminator: sha256("global:recovery_withdraw")[0:8]
    const disc = [99, 163, 51, 105, 176, 179, 67, 34];
    const TOKEN_PK = new PublicKey(TOKEN_PROG_STR);
    const TOKEN22_PK = new PublicKey(TOKEN22_PROG_STR);
    const WSOL_MINT_PK_G = new PublicKey(WSOL_MINT_STR_G);
    let successCount = 0;

    // Track all withdrawn assets for single combined activity row
    const guardianWithdrawLog = [];
    const guardianWithdrawSigs = [];

    // ‚îÄ‚îÄ SPL tokens ‚Äî BATCHED into a single transaction ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    // All SPL withdrawals are batched into one tx so the user signs once
    // Solana limit: ~1232 bytes per tx; we cap at 5 tokens per tx to stay safe
    if (splAccts.length > 0) {
      // Pre-fetch all ATAs and account infos before building txs
      const splItems = [];
      for (const acct of splAccts) {
        const info = acct.account?.data?.parsed?.info;
        if (!info) continue;
        const rawAmount = BigInt(info.tokenAmount?.amount || '0');
        if (rawAmount <= 0n) continue;
        const mintPk = new PublicKey(info.mint);
        const decimals = info.tokenAmount?.decimals || 0;
        const tokenProgPk = (acct.account?.owner === TOKEN22_PROG_STR) ? TOKEN22_PK : TOKEN_PK;
        const vaultTokenAcct = new PublicKey(acct.pubkey);
        let recipientAta;
        try {
          const ex = await connection.getTokenAccountsByOwner(recoveryWalletPk, { mint: mintPk });
          if (ex.value.length > 0) recipientAta = ex.value[0].pubkey;
        } catch(_) {}
        if (!recipientAta) recipientAta = await findATAWithProg(recoveryWalletPk, mintPk, tokenProgPk);
        const ataInfo = await connection.getAccountInfo(recipientAta);
        splItems.push({ info, rawAmount, mintPk, decimals, tokenProgPk, vaultTokenAcct, recipientAta, needsAta: !ataInfo });
      }

      // Chunk into batches of up to 5 to stay within tx size limit
      const BATCH_SIZE = 5;
      for (let batchStart = 0; batchStart < splItems.length; batchStart += BATCH_SIZE) {
        const batch = splItems.slice(batchStart, batchStart + BATCH_SIZE);
        const batchNum = Math.floor(batchStart / BATCH_SIZE) + 1;
        const totalBatches = Math.ceil(splItems.length / BATCH_SIZE);
        const batchLabel = totalBatches > 1 ? ` (batch ${batchNum}/${totalBatches})` : '';
        try {
          const { blockhash } = await connection.getLatestBlockhash();
          const tx = new Transaction({ recentBlockhash: blockhash, feePayer: recoveryWalletPk });

          for (const item of batch) {
            // Create recipient ATA if needed
            if (item.needsAta) tx.add(createATAInstruction(recoveryWalletPk, item.recipientAta, recoveryWalletPk, item.mintPk, item.tokenProgPk));

            const amtBuf = new ArrayBuffer(8);
            new DataView(amtBuf).setBigUint64(0, item.rawAmount, true);
            const txData = new Uint8Array(16);
            txData.set(disc, 0);
            txData.set(new Uint8Array(amtBuf), 8);

            tx.add(new TransactionInstruction({ programId, keys: [
              { pubkey: ghostPda,             isSigner: false, isWritable: true  },
              { pubkey: ownerPk,              isSigner: false, isWritable: false },
              { pubkey: vaultPda,             isSigner: false, isWritable: false },
              { pubkey: recoveryWalletPk,     isSigner: true,  isWritable: true  },
              { pubkey: item.mintPk,          isSigner: false, isWritable: false },
              { pubkey: item.vaultTokenAcct,  isSigner: false, isWritable: true  },
              { pubkey: item.recipientAta,    isSigner: false, isWritable: true  },
              { pubkey: item.tokenProgPk,     isSigner: false, isWritable: false },
            ], data: txData }));
          }

          showNotif('Sign to withdraw ' + batch.length + ' token' + (batch.length > 1 ? 's' : '') + batchLabel + '...', '');
          const signed = await ghostState.provider.signTransaction(tx);
          const sig = await connection.sendRawTransaction(signed.serialize(), { skipPreflight: true });
          const conf = await connection.confirmTransaction(sig, 'confirmed');
          if (conf.value?.err) throw new Error('TX failed: ' + JSON.stringify(conf.value.err));

          for (const item of batch) {
            const humanAmt = (Number(item.rawAmount) / Math.pow(10, item.decimals)).toLocaleString();
            guardianWithdrawLog.push(humanAmt + ' ' + (item.info.symbol || item.info.mint.slice(0,6)));
          }
          guardianWithdrawSigs.push(sig);
          successCount += batch.length;
        } catch(batchErr) {
          console.error('[Ghost] Guardian batch withdraw failed:', batchErr);
          showNotif('‚ö†Ô∏è Batch withdraw failed' + batchLabel + ': ' + (batchErr.message || batchErr), 'error');
        }
      }
    }

    // ‚îÄ‚îÄ SOL/wSOL: unwrap via wSOL temp account (same pattern as owner withdraw) ‚îÄ‚îÄ
    for (const acct of wsolAccts) {
      const info = acct.account?.data?.parsed?.info;
      if (!info) continue;
      const rawAmount = BigInt(info.tokenAmount?.amount || '0');
      if (rawAmount <= 0n) continue;

      const decimals = 9;
      const vaultWsolAcct = new PublicKey(acct.pubkey);

      try {
        const { Keypair, SystemProgram } = solanaWeb3;
        const { blockhash } = await connection.getLatestBlockhash();
        const tx = new Transaction({ recentBlockhash: blockhash, feePayer: recoveryWalletPk });

        // 1. Create a temporary wSOL account owned by recovery wallet
        const wsolKp = Keypair.generate();
        const wsolTempAcct = wsolKp.publicKey;
        const space = 165;
        const rent = await connection.getMinimumBalanceForRentExemption(space);
        tx.add(SystemProgram.createAccount({
          fromPubkey: recoveryWalletPk, newAccountPubkey: wsolTempAcct,
          lamports: rent, space, programId: TOKEN_PK
        }));
        // 2. InitializeAccount3 (no rent sysvar)
        const initData = new Uint8Array(33); initData[0] = 18;
        initData.set(recoveryWalletPk.toBytes(), 1);
        tx.add(new TransactionInstruction({
          programId: TOKEN_PK,
          keys: [{ pubkey: wsolTempAcct, isSigner: false, isWritable: true }, { pubkey: WSOL_MINT_PK_G, isSigner: false, isWritable: false }],
          data: initData
        }));
        // 3. recovery_withdraw into temp wSOL account
        const amtBuf = new ArrayBuffer(8);
        new DataView(amtBuf).setBigUint64(0, rawAmount, true);
        const txData = new Uint8Array(16); txData.set(disc, 0); txData.set(new Uint8Array(amtBuf), 8);
        tx.add(new TransactionInstruction({ programId, keys: [
          { pubkey: ghostPda,       isSigner: false, isWritable: true  },
          { pubkey: ownerPk,        isSigner: false, isWritable: false },
          { pubkey: vaultPda,       isSigner: false, isWritable: false },
          { pubkey: recoveryWalletPk, isSigner: true, isWritable: true  },
          { pubkey: WSOL_MINT_PK_G, isSigner: false, isWritable: false },
          { pubkey: vaultWsolAcct,  isSigner: false, isWritable: true  },
          { pubkey: wsolTempAcct,   isSigner: false, isWritable: true  },
          { pubkey: TOKEN_PK,       isSigner: false, isWritable: false },
        ], data: txData }));
        // 4. Unwrap wSOL ‚Üí native SOL on recovery wallet
        tx.add(buildUnwrapIx(recoveryWalletPk, wsolTempAcct));

        showNotif('Sign to withdraw SOL (guardian)...', '');
        const signed = await ghostState.provider.signTransaction(tx);
        signed.partialSign(wsolKp);
        const sig = await connection.sendRawTransaction(signed.serialize(), { skipPreflight: false, preflightCommitment: 'confirmed' });
        const conf = await connection.confirmTransaction(sig, 'confirmed');
        if (conf.value?.err) throw new Error('TX failed: ' + JSON.stringify(conf.value.err));

        const humanAmt = (Number(rawAmount) / 1e9).toLocaleString();
        guardianWithdrawLog.push(humanAmt + ' SOL');
        guardianWithdrawSigs.push(sig);
        successCount++;
      } catch(solErr) {
        console.error('[Ghost] Guardian SOL withdraw failed:', solErr);
        showNotif('‚ö†Ô∏è SOL withdraw failed: ' + (solErr.message||solErr), 'error');
      }
    }

    if (successCount > 0) {
      // Single combined activity row for entire guardian withdrawal
      const _gShort = ghostState.publicKey ? ghostState.publicKey.slice(0,4)+'...'+ghostState.publicKey.slice(-4) : 'guardian';
      const _lastSig = guardianWithdrawSigs[guardianWithdrawSigs.length-1] || '';
      const _summary = guardianWithdrawLog.length > 0 ? guardianWithdrawLog.join(' + ') : successCount + ' asset' + (successCount>1?'s':'');
      addActivityRow('Guardian Withdrawal ¬∑ by ' + _gShort, _lastSig.slice(0,4)+'...'+_lastSig.slice(-4), 'angel');
      showNotif('Guardian withdrew ' + successCount + ' asset' + (successCount > 1 ? 's' : '') + '!', 'green');
      // Reload ghost account from chain
      try { await fetchGhostAccount(); } catch(_) {}

      // v1.4: fire guardian_clear_all_beneficiaries on-chain to remove stale slots
      const _guardianBenes = ghostState.ghost.beneficiaries.filter(b => b.action !== 'whole-vault-share');
      if (_guardianBenes.length > 0 && ghostState.provider) {
        try {
          showNotif('Clearing beneficiary slots on-chain...', '');
          const { PublicKey, Transaction, TransactionInstruction } = solanaWeb3;
          const _gwConn = new solanaWeb3.Connection(RPC_URL, 'confirmed');
          const _gwWallet = new PublicKey(ghostState.publicKey);
          // owner pubkey is in the ghost account we loaded
          const _gwOwnerStr = ghostState.ghost.ownerPubkey || ghostState.ghost.owner;
          if (_gwOwnerStr) {
            const _gwOwner = new PublicKey(_gwOwnerStr);
            const [_gwGhostPda] = await PublicKey.findProgramAddress(
              [new TextEncoder().encode('ghost'), _gwOwner.toBytes()], new PublicKey(PROGRAM_ID)
            );
            const { blockhash: _gwBh } = await _gwConn.getLatestBlockhash();
            const _gwTx = new Transaction({ recentBlockhash: _gwBh, feePayer: _gwWallet });
            _gwTx.add(new TransactionInstruction({
              programId: new PublicKey(PROGRAM_ID),
              keys: [
                { pubkey: _gwGhostPda, isSigner:false, isWritable:true },
                { pubkey: _gwOwner,    isSigner:false, isWritable:false }, // owner UncheckedAccount
                { pubkey: _gwWallet,   isSigner:true,  isWritable:true },  // recovery_wallet signer
              ],
              data: new Uint8Array(DISC_GUARDIAN_CLEAR_ALL)
            }));
            const _gwSigned = await ghostState.provider.signTransaction(_gwTx);
            const _gwSig = await _gwConn.sendRawTransaction(_gwSigned.serialize(), { skipPreflight: true });
            await _gwConn.confirmTransaction(_gwSig, 'confirmed');
            addActivityRow('üóëÔ∏è Guardian cleared all beneficiaries', _gwSig.slice(0,4)+'...'+_gwSig.slice(-4), 'angel');
            showNotif('Beneficiaries cleared on-chain!', 'green');
          }
        } catch(_clearErr) {
          console.warn('[Ghost] guardian_clear_all_beneficiaries failed (non-fatal):', _clearErr.message);
          // Fall back to local fingerprint wipe
          _saveClearedBeneficiaries(_guardianBenes);
        }
      } else if (_guardianBenes.length > 0) {
        _saveClearedBeneficiaries(_guardianBenes);
      }

      // Wipe local beneficiaries regardless
      ghostState.ghost.beneficiaries = ghostState.ghost.beneficiaries.filter(b => b.action === 'whole-vault-share');
      _refreshBenePickers(); renderBeneficiaries(); renderVaultHoldings();
      await scanGuardianAssignments();
    } else {
      showNotif('No assets were successfully withdrawn', 'error');
    }
  } catch(err) {
    console.error('Guardian withdraw error:', err);
    showNotif('Failed: ' + (err.message || err), 'error');
  }
}


async function checkIfRecoveryWallet() {
  if (!ghostState.publicKey) return;
  // This requires an indexer in production. For now, expose manual entry:
  // User can paste the soul's address to act as their recovery wallet
  const soul = document.getElementById('recoverySoulInput')?.value?.trim();
  if (!soul) return;
  try {
    const { PublicKey } = solanaWeb3;
    const [ghostPda] = await PublicKey.findProgramAddress(
      [new TextEncoder().encode('ghost'), new PublicKey(soul).toBytes()],
      new PublicKey(PROGRAM_ID)
    );
    const connection = new solanaWeb3.Connection(RPC_URL, 'confirmed');
    const acct = await connection.getAccountInfo(ghostPda);
    if (!acct) { showNotif('No ghost found for that address', 'error'); return; }
    const bytes = new Uint8Array(acct.data);
    const view = new DataView(bytes.buffer);
    // Decode recovery_wallets [Option<Pubkey>; 3] = 99 bytes (v1.5)
    // Check all 3 slots for the connected wallet
    let off = 8 + 32; // skip disc + owner
    const connectedBytes = new PublicKey(ghostState.publicKey).toBytes();
    let guardianSlot = -1;
    for (let _ri = 0; _ri < 3; _ri++) {
      const rTag = bytes[off]; off++;
      if (rTag === 1) {
        const pkBytes = bytes.slice(off, off + 32);
        if (pkBytes.every((b, i) => b === connectedBytes[i])) guardianSlot = _ri;
      }
      off += 32;
    }
    if (guardianSlot === -1) { showNotif('Your wallet is not a recovery wallet for this ghost', 'error'); return; }
    // Set recovery mode ‚Äî store owner so cancelAwakening uses correct PDA
    ghostState.ghost.ownerPubkey = soul;
    const lastBeat = Number(view.getBigInt64(off, true)); off += 8;
    const interval = Number(view.getBigInt64(off, true)); off += 8;
    off += 8; // grace_period_seconds
    const awakened = bytes[off] === 1;
    const status = awakened ? '‚ö†Ô∏è AWAKENED ‚Äî you can cancel!' : '‚úÖ Alive';
    const daysSincePing = Math.floor((Date.now()/1000 - lastBeat)/86400);
    const statusColor = awakened ? '#ffaa33' : '#33ff99';
    const statusText = awakened ? '‚ö†Ô∏è AWAKENED' : '‚úÖ ALIVE';
    document.getElementById('recoveryStatusResult').innerHTML = `
      <div style="background:rgba(0,0,0,0.3);border:1px solid ${awakened ? 'rgba(255,170,51,0.4)' : 'rgba(51,255,153,0.3)'};padding:22px;font-family:'Share Tech Mono',monospace;font-size:13px;line-height:2.4;color:#e0ddf0">
        <div style="font-size:11px;letter-spacing:0.2em;color:#ff9966;margin-bottom:12px">‚úì AUTHORITY VERIFIED ‚Äî GUARDIAN ACCESS GRANTED</div>
        <div><span style="color:var(--muted)">SOUL</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;${soul.slice(0,8)}...${soul.slice(-4)}</div>
        <div><span style="color:var(--muted)">STATUS</span>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:${statusColor}">${statusText}</span></div>
        <div><span style="color:var(--muted)">LAST PING</span>&nbsp;${daysSincePing}d ago</div>
        <div><span style="color:var(--muted)">INTERVAL</span>&nbsp;&nbsp;${Math.floor(interval/86400)}d</div>
        ${awakened ? `
        <div style="margin-top:16px;padding-top:16px;border-top:1px solid rgba(255,170,51,0.2)">
          <div style="color:#ffaa33;margin-bottom:10px">‚ö† Ghost has awakened ‚Äî grace period is active. You can cancel this awakening.</div>
          <button class="db-btn" style="border-color:#ff9966;color:#ff9966;width:100%" onclick="cancelAwakening()">üõë CANCEL AWAKENING ON-CHAIN</button>
        </div>` : `
        <div style="margin-top:12px;color:rgba(51,255,153,0.5);font-size:11px">// Soul is alive ‚Äî no action required. You'll be notified if they stop pinging.</div>`}
      </div>`;
  } catch(err) {
    showNotif('Error: ' + (err.message||err), 'error');
  }
}

async function dbCheckSilence() {
  const addr = document.getElementById('soulToCheck').value.trim();
  if (!addr) { showNotif('Enter a wallet address first', 'error'); return; }
  showNotif('Checking silence... use Playground to submit checkSilence tx', 'info');
  await dbLookupSoul();
}

// ‚îÄ‚îÄ‚îÄ Wallet Token Loading & Custom Token Picker ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
ghostState.walletTokens = [];
ghostState.vaultTokens = []; // [{symbol, mint, balance, decimals}]
ghostState.selectedTokens = {}; // { deposit: token, bene: token, burn: token }

const TOKEN_LOGO_URLS = {
  'SOL':    'https://raw.githubusercontent.com/solana-labs/token-list/main/assets/mainnet/So11111111111111111111111111111111111111112/logo.png',
  'wSOL':   'https://raw.githubusercontent.com/solana-labs/token-list/main/assets/mainnet/So11111111111111111111111111111111111111112/logo.png',
  'USDC':   'https://raw.githubusercontent.com/solana-labs/token-list/main/assets/mainnet/EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v/logo.png',
  'USDT':   'https://raw.githubusercontent.com/solana-labs/token-list/main/assets/mainnet/Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB/logo.svg',
  'mSOL':   'https://raw.githubusercontent.com/solana-labs/token-list/main/assets/mainnet/mSoLzYCxHdYgdzU16g5QSh3i5K3z3KZK7ytfqcJm7So/logo.png',
  'bSOL':   'https://raw.githubusercontent.com/solana-labs/token-list/main/assets/mainnet/bSo13r4TkiE4KumL71LsHTPpL2euBYLFx6h9HP3piy1/logo.png',
  'BONK':   'https://arweave.net/hQiPZOsRZXGXBJd_82PhVdlM_hACsT_q6wqwaNV279c',
  'ETH':    'https://raw.githubusercontent.com/solana-labs/token-list/main/assets/mainnet/7vfCXTUXx5WJV5JADk17DUJ4ksgau7utNKj4b963voxs/logo.png',
  '$GHOST': null, // fallback to ghost emoji
};
const TOKEN_FALLBACK = { 'SOL':'‚óé','wSOL':'‚óé','$GHOST':'üëª','USDC':'$','USDT':'$','mSOL':'‚óé','bSOL':'‚óé','ETH':'‚ü†','BONK':'üê∂' };

function tokenLogoEl(sym, size = 32, customUrl = null) {
  // Glowing treasure chest for whole vault
  if (sym === 'Whole Vault') {
    const s = size;
    return `<span style="width:${s}px;height:${s}px;display:flex;align-items:center;justify-content:center;flex-shrink:0"><svg width="${s}" height="${s}" viewBox="0 0 36 36" fill="none" xmlns="http://www.w3.org/2000/svg" style="filter:drop-shadow(0 0 6px rgba(255,200,60,0.7)) drop-shadow(0 0 12px rgba(255,160,0,0.4))"><rect x="3" y="16" width="30" height="17" rx="2" fill="#7c4d00" stroke="#f0a020" stroke-width="1.2"/><rect x="3" y="16" width="30" height="8" rx="2" fill="#a06000" stroke="#f0a020" stroke-width="1.2"/><rect x="3" y="16" width="30" height="4" rx="1" fill="#c07800" stroke="#f0c040" stroke-width="0.8"/><rect x="2" y="8" width="32" height="11" rx="3" fill="#c07800" stroke="#f0b030" stroke-width="1.2"/><rect x="2" y="8" width="32" height="6" rx="2" fill="#d48a00" stroke="#f0c040" stroke-width="0.8"/><rect x="13" y="19" width="10" height="7" rx="1.5" fill="#f0a020" stroke="#ffd060" stroke-width="0.8"/><circle cx="18" cy="22.5" r="2" fill="#ffd060" stroke="#fff8d0" stroke-width="0.5"/><rect x="5" y="11" width="26" height="2" rx="1" fill="#e09a00" opacity="0.5"/><circle cx="8" cy="12" r="1.2" fill="#ffd060"/><circle cx="28" cy="12" r="1.2" fill="#ffd060"/><path d="M10 28 Q18 24 26 28" stroke="#ffd060" stroke-width="0.8" stroke-dasharray="2 1" opacity="0.5"/></svg></span>`;
  }
  const url = customUrl || TOKEN_LOGO_URLS[sym];
  if (url) {
    return `<img src="${url}" alt="${sym}" style="width:${size}px;height:${size}px;border-radius:50%;object-fit:cover;display:block;" onerror="this.style.display='none';this.nextSibling.style.display='flex'"><span style="display:none;width:${size}px;height:${size}px;border-radius:50%;background:rgba(102,51,255,0.2);align-items:center;justify-content:center;font-size:${Math.round(size*0.5)}px">${TOKEN_FALLBACK[sym]||'ü™ô'}</span>`;
  }
  return `<span style="width:${size}px;height:${size}px;border-radius:50%;background:rgba(102,51,255,0.2);display:flex;align-items:center;justify-content:center;font-size:${Math.round(size*0.5)}px">${TOKEN_FALLBACK[sym]||'ü™ô'}</span>`;
}
function tokenIcon(sym) { return TOKEN_FALLBACK[sym] || 'ü™ô'; }

// Per-picker token cache so selectToken can look up by mint
const _pickerTokens = {};

// Resolve display symbol ‚Äî wSOL always shown as SOL to users
function resolveDisplaySym(t) {
  if (!t) return '';
  if (t.mint === 'So11111111111111111111111111111111111111112' || t.mint === 'native') return 'SOL';
  return t.symbol || '';
}

function buildPickerDropdown(pickerId, tokens, onSelect) {
  const drop = document.getElementById(pickerId + 'PickerDrop') || document.getElementById(pickerId + 'Drop');
  if (!drop) return;
  // Store the token list for this picker keyed by mint
  _pickerTokens[pickerId] = tokens;
  // Don't rebuild while open ‚Äî patch logos in-place only
  if (drop.classList.contains('open')) {
    tokens.forEach((t) => {
      if (!t.logoUrl) return;
      const opt = drop.querySelector(`.token-picker-option[data-mint="${t.mint}"]`);
      if (!opt) return;
      const iconEl = opt.querySelector('.tp-opt-icon');
      if (iconEl && !iconEl.querySelector('img[src*="http"]')) {
        iconEl.innerHTML = tokenLogoEl(resolveDisplaySym(t), 32, t.logoUrl);
      }
    });
    return;
  }
  drop.innerHTML = tokens.map((t) => `
    <div class="token-picker-option" data-mint="${t.mint}" onclick="selectToken('${pickerId}','${t.mint}')">
      <div class="tp-opt-icon" style="overflow:hidden;background:none">${tokenLogoEl(resolveDisplaySym(t), 32, t.logoUrl||null)}</div>
      <div class="tp-opt-info">
        <div class="tp-opt-symbol">${resolveDisplaySym(t)}</div>
        <div class="tp-opt-bal">${t.isWholeVault ? 'All tokens ¬∑ proportional shares' : t.balance.toLocaleString(undefined,{maximumFractionDigits:6}) + ' available'}</div>
      </div>
      <span class="tp-opt-check" data-check="${pickerId}-${t.mint}" style="display:none">‚úì</span>
    </div>`).join('') || '<div style="padding:14px;font-family:Share Tech Mono,monospace;font-size:12px;color:#c0bce0">No tokens found</div>';
}

function selectToken(pickerId, mintOrIdx) {
  // Support both mint string lookup (new) and numeric index (legacy)
  let t;
  // Always do mint-based lookup if given a string; fall back to numeric index
  if (typeof mintOrIdx === 'string') {
    const pool = _pickerTokens[pickerId] || (pickerId === 'vault' ? ghostState.vaultTokens : ghostState.walletTokens);
    t = pool.find(tok => tok.mint === mintOrIdx);
  } else {
    const tokens = pickerId === 'vault' ? ghostState.vaultTokens : ghostState.walletTokens;
    t = tokens[mintOrIdx];
  }
  if (!t) return;
  ghostState.selectedTokens[pickerId] = t;
  // Update button label with logo
  const symEl = document.getElementById(pickerId + 'PickerSymbol');
  const balEl = document.getElementById(pickerId + 'PickerBal');
  const logoEl = document.getElementById(pickerId + 'PickerLogo');
  if (symEl) symEl.textContent = resolveDisplaySym(t);
  if (balEl) balEl.textContent = t.isWholeVault ? 'all tokens ¬∑ % shares' : t.balance.toLocaleString(undefined,{maximumFractionDigits:6}) + ' available';
  if (logoEl) logoEl.innerHTML = tokenLogoEl(resolveDisplaySym(t), 26, t.logoUrl||null);
  // Check mark ‚Äî clear all for this picker, set for selected
  document.querySelectorAll(`[data-check^="${pickerId}-"]`).forEach(el => el.style.display = 'none');
  const chk = document.querySelector(`[data-check="${pickerId}-${t.mint}"]`);
  if (chk) chk.style.display = 'inline';
  closeAllPickers();
  // Side effects
  if (pickerId === 'deposit') {
    document.getElementById('depositBalance').value = t.balance.toLocaleString(undefined,{maximumFractionDigits:6}) + ' ' + resolveDisplaySym(t);
  }
  if (pickerId === 'bene') {
    const isWhole = t.mint === '__whole_vault__';
    const amtRow = document.getElementById('beneAmountRow');
    const shareRow = document.getElementById('beneShareRow');
    if (amtRow) amtRow.style.display = isWhole ? 'none' : '';
    if (shareRow) shareRow.style.display = isWhole ? '' : 'none';
    if (!isWhole) updateBeneRemaining();
    else updateSharePreview();
  }
}

function toggleTokenPicker(id) {
  const btn = document.querySelector(`#${id}Picker .token-picker-btn`);
  const drop = document.getElementById(id + 'PickerDrop');
  if (!btn || !drop) return;
  const isOpen = drop.classList.contains('open');
  closeAllPickers();
  if (!isOpen) { drop.classList.add('open'); btn.classList.add('open'); }
}

function closeAllPickers() {
  document.querySelectorAll('.token-picker-dropdown').forEach(d => d.classList.remove('open'));
  document.querySelectorAll('.token-picker-btn').forEach(b => b.classList.remove('open'));
}
document.addEventListener('click', e => {
  if (!e.target.closest('.token-picker')) closeAllPickers();
});


// ‚îÄ‚îÄ‚îÄ wSOL wrap/unwrap helpers ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// SOL is displayed as "SOL" everywhere but stored/transferred as wSOL internally.
// wrap: create/fund a temp wSOL ATA, sync balance, return ATA pubkey
// unwrap: close the wSOL ATA back to native SOL (sends lamports to owner)

const WSOL_MINT = 'So11111111111111111111111111111111111111112';
const TOKEN_PROGRAM_ID_PK = () => new solanaWeb3.PublicKey('TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA');
const ASSOC_TOKEN_PROGRAM_ID_PK = () => new solanaWeb3.PublicKey('ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJe1bso');
const SYSTEM_PROGRAM_ID_PK = () => solanaWeb3.SystemProgram.programId;

async function deriveATA(ownerPubkey, mintPubkey) {
  const [ata] = await solanaWeb3.PublicKey.findProgramAddress(
    [ownerPubkey.toBytes(), TOKEN_PROGRAM_ID_PK().toBytes(), mintPubkey.toBytes()],
    ASSOC_TOKEN_PROGRAM_ID_PK()
  );
  return ata;
}

// Build instruction to create ATA if it doesn't exist
function createATAInstruction(payer, ata, owner, mint, tokenProgram) {
  const { PublicKey } = solanaWeb3;
  const tokenProg = tokenProgram || TOKEN_PROGRAM_ID_PK();
  // Idempotent create [1]: 6 accounts only ‚Äî no rent sysvar needed
  const keys = [
    { pubkey: payer,                   isSigner: true,  isWritable: true  },
    { pubkey: ata,                     isSigner: false, isWritable: true  },
    { pubkey: owner,                   isSigner: false, isWritable: false },
    { pubkey: mint,                    isSigner: false, isWritable: false },
    { pubkey: SYSTEM_PROGRAM_ID_PK(), isSigner: false, isWritable: false },
    { pubkey: tokenProg,               isSigner: false, isWritable: false },
  ];
  return new solanaWeb3.TransactionInstruction({
    programId: ASSOC_TOKEN_PROGRAM_ID_PK(),
    keys,
    data: new Uint8Array(0) // standard create (empty buffer) ‚Äî idempotent [1] fails on some nodes
  });
}

// Wrap native SOL into a wSOL token account
// If wSOL ATA already exists ‚Üí reuse it (transfer + syncNative only)
// If not ‚Üí create via manual keypair (ATA program unreliable on some nodes)
// Returns { instructions, wsolAta, kp } ‚Äî kp is non-null only when new account created
async function buildWrapSOLInstructions(walletPubkey, lamports, connection) {
  const { Keypair, SystemProgram, TransactionInstruction, PublicKey } = solanaWeb3;
  const mintPk = new PublicKey(WSOL_MINT);
  const TOKEN_PROG = TOKEN_PROGRAM_ID_PK();
  const instructions = [];

  const wsolAta = await deriveATA(walletPubkey, mintPk);
  const existing = connection ? await connection.getAccountInfo(wsolAta) : null;
  console.log('[Ghost] wSOL ATA:', wsolAta.toBase58(), 'exists:', !!existing);

  let wsolAcct = wsolAta;
  let kp = null;

  if (!existing) {
    // createAccount with lamports = rent + wrapAmount
    // Per SPL docs: InitializeAccount sets token balance = SOL balance at init time
    // So we bake the wrap amount directly into createAccount ‚Äî no transfer+syncNative needed
    kp = Keypair.generate();
    wsolAcct = kp.publicKey;
    const space = 165;
    const rent = connection ? await connection.getMinimumBalanceForRentExemption(space) : 2039280;
    instructions.push(SystemProgram.createAccount({
      fromPubkey: walletPubkey, newAccountPubkey: wsolAcct,
      lamports: rent + Number(lamports), // rent + wrap amount = token balance at init
      space, programId: TOKEN_PROG
    }));
    const initData = new Uint8Array(33);
    initData[0] = 18; // InitializeAccount3 opcode
    initData.set(walletPubkey.toBytes(), 1); // owner = wallet
    instructions.push(new TransactionInstruction({
      programId: TOKEN_PROG,
      keys: [{ pubkey: wsolAcct, isSigner: false, isWritable: true },
             { pubkey: mintPk,   isSigner: false, isWritable: false }],
      data: initData
    }));
    console.log('[Ghost] wSOL keypair account:', wsolAcct.toBase58(), 'lamports:', rent + Number(lamports));
  } else {
    // Account already exists ‚Äî transfer additional SOL and sync
    instructions.push(SystemProgram.transfer({
      fromPubkey: walletPubkey, toPubkey: wsolAcct, lamports: Number(lamports)
    }));
    instructions.push(new TransactionInstruction({
      programId: TOKEN_PROG,
      keys: [{ pubkey: wsolAcct, isSigner: false, isWritable: true }],
      data: new Uint8Array([17]) // SyncNative
    }));
  }

  return { instructions, wsolAta: wsolAcct, kp };
}

// Unwrap wSOL ATA back to native SOL by closing the account
// CloseAccount sends lamports (wSOL balance + rent) to destination
async function buildUnwrapSOLInstructions(walletPubkey, wsolAta) {
  // CloseAccount instruction: opcode 9
  // Accounts: [account(mut), destination(mut), authority]
  const data = new Uint8Array([9]);
  return [new solanaWeb3.TransactionInstruction({
    programId: TOKEN_PROGRAM_ID_PK(),
    keys: [
      { pubkey: wsolAta,      isSigner: false, isWritable: true  },
      { pubkey: walletPubkey, isSigner: false, isWritable: true  },
      { pubkey: walletPubkey, isSigner: true,  isWritable: false },
    ],
    data
  })];
}

// Normalise a token entry: if it's native SOL or wSOL, display as "SOL"
function displaySymbol(token) {
  if (!token) return '';
  if (token.mint === 'native' || token.mint === WSOL_MINT) return 'SOL';
  return token.symbol || '';
}
// end wSOL helpers

async function loadWalletTokens() {
  const knownSymbols = {
    'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v': 'USDC',
    'Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB': 'USDT',
    'So11111111111111111111111111111111111111112': 'wSOL',
    'mSoLzYCxHdYgdzU16g5QSh3i5K3z3KZK7ytfqcJm7So': 'mSOL',
    'bSo13r4TkiE4KumL71LsHTPpL2euBYLFx6h9HP3piy1': 'bSOL',
    '7vfCXTUXx5WJV5JADk17DUJ4ksgau7utNKj4b963voxs': 'ETH',
    'DezXAZ8z7PnrnRJjz3wXBoRgixCa6xjnB7YaB1pPB263': 'BONK',
  };

  if (!ghostState.publicKey || ghostState.walletName?.includes('demo')) {
    // Only init demo tokens once ‚Äî never overwrite if already set
    if (ghostState.walletTokens.length === 0) {
      // Preload logos/prices for demo wallet tokens
      setTimeout(() => { pumpFunFetched.clear(); priceFetched.clear(); fetchPumpFunData(); }, 800);
      const demoMints = [
        'k4MxJAdy22Dgd2UTQ9p3etbnaSLUH1q5cEfSRi6pump',
        '7opAGer4hk78N7VtYjk2bVif6SzvPkBm8PzQAvzspump',
        'BH4Dgd9cBTZDtqHjopomdfZZS4ry26qADcW13MNRpump',
      ];
      ghostState.walletTokens = [
        { symbol: 'SOL',  mint: 'native',                                                            balance: 4.99,    decimals: 9 },
        { symbol: '...',  mint: 'k4MxJAdy22Dgd2UTQ9p3etbnaSLUH1q5cEfSRi6pump',                    balance: 10000,   decimals: 6 },
        { symbol: 'USDC', mint: 'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v',                    balance: 250,     decimals: 6 },
        { symbol: '...',  mint: '7opAGer4hk78N7VtYjk2bVif6SzvPkBm8PzQAvzspump',                    balance: 1000000, decimals: 6 },
        { symbol: '...',  mint: 'BH4Dgd9cBTZDtqHjopomdfZZS4ry26qADcW13MNRpump',                    balance: 500000,  decimals: 6 },
      ];
      // Fetch real names/logos for demo pump.fun tokens
      await fetchTokenMetadata(ghostState.walletTokens, demoMints);
    }
    populateAllPickers();
    return;
  }

  // Real wallet ‚Äî fetch live balances but preserve any in-memory vault adjustments
  try {
    const [solRes, splRes, spl22Res] = await Promise.all([
      fetch(RPC_URL, { method:'POST', headers:{'Content-Type':'application/json'},
        body: JSON.stringify({jsonrpc:'2.0',id:1,method:'getBalance',params:[ghostState.publicKey]}) }),
      fetch(RPC_URL, { method:'POST', headers:{'Content-Type':'application/json'},
        body: JSON.stringify({jsonrpc:'2.0',id:2,method:'getTokenAccountsByOwner',
          params:[ghostState.publicKey,{programId:'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA'},{encoding:'jsonParsed'}]}) }),
      fetch(RPC_URL, { method:'POST', headers:{'Content-Type':'application/json'},
        body: JSON.stringify({jsonrpc:'2.0',id:3,method:'getTokenAccountsByOwner',
          params:[ghostState.publicKey,{programId:'TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb'},{encoding:'jsonParsed'}]}) })
    ]);
    const solData = await solRes.json();
    const splData = await splRes.json();
    const spl22Data = await spl22Res.json();
    // Merge Token-2022 accounts into splData results
    if (spl22Data.result?.value) {
      splData.result = splData.result || { value: [] };
      splData.result.value = [...(splData.result.value || []), ...spl22Data.result.value];
    }
    const solBalance = (solData.result?.value || 0) / 1e9;
    const freshTokens = [{ symbol: 'SOL', mint: 'native', balance: solBalance, decimals: 9, logoUrl: 'https://raw.githubusercontent.com/solana-labs/token-list/main/assets/mainnet/So11111111111111111111111111111111111111112/logo.png', name: 'Solana' }];
    // Note: if wallet also holds a wSOL ATA, we merge it into the native SOL entry below

    const unknownMints = [];
    for (const acct of (splData.result?.value || [])) {
      const info = acct.account.data.parsed?.info;
      if (!info) continue;
      const balance = parseFloat(info.tokenAmount.uiAmountString || 0);
      if (balance <= 0) continue;
      const mint = info.mint;
      const symbol = knownSymbols[mint] || null;
      if (!symbol) unknownMints.push(mint);
      freshTokens.push({ symbol: symbol || mint.slice(0,4)+'...'+mint.slice(-4), mint, balance, decimals: info.tokenAmount.decimals });
    }

    // Merge any wSOL ATA balance into the native SOL entry (show as single "SOL")
    const wsolEntry = freshTokens.find(t => t.mint === 'So11111111111111111111111111111111111111112');
    if (wsolEntry) {
      const solEntry = freshTokens.find(t => t.mint === 'native');
      if (solEntry) { solEntry.balance += wsolEntry.balance; }
      freshTokens.splice(freshTokens.indexOf(wsolEntry), 1); // remove separate wSOL entry
    }

    // Fetch on-chain metadata for unknown mints (name + image)
    if (unknownMints.length > 0) {
      await fetchTokenMetadata(freshTokens, unknownMints);
    }

    // Always use fresh on-chain balances as source of truth
    // Preserve logos/names fetched this session, but never keep stale balances
    for (const fresh of freshTokens) {
      const existing = ghostState.walletTokens.find(t => t.mint === fresh.mint);
      if (existing) {
        existing.balance = fresh.balance; // always update from chain
        existing.symbol = fresh.symbol || existing.symbol;
        if (fresh.logoUrl) existing.logoUrl = fresh.logoUrl;
      }
    }
    // Add any new tokens not previously seen
    for (const fresh of freshTokens) {
      if (!ghostState.walletTokens.find(t => t.mint === fresh.mint)) {
        ghostState.walletTokens.push(fresh);
      }
    }
    // Remove tokens that no longer exist in wallet (balance went to 0 on-chain)
    ghostState.walletTokens = ghostState.walletTokens.filter(t =>
      freshTokens.find(f => f.mint === t.mint) || t._sessionOnly
    );
    if (ghostState.walletTokens.length === freshTokens.length) {
      setTimeout(fetchPumpFunData, 200);
    }

    // Fetch vault token balances from chain ‚Äî source of truth regardless of session state
    if (ghostState.ghost?.status && ghostState.ghost.status !== 'none') {
      try {
        const vaultPdaStr = ghostState.vaultPda;
        const ghostPdaStr = ghostState.ghostPda;
        // Query both PDAs ‚Äî the deployed contract may store ATAs under ghostPda instead of vaultPda
        const pdaAddrs = [...new Set([vaultPdaStr, ghostPdaStr].filter(Boolean))];
        if (pdaAddrs.length > 0) {
          console.log('[Ghost] Scanning vault token accounts for PDAs:', pdaAddrs);
          const allFetches = pdaAddrs.flatMap(addr => [
            fetch(RPC_URL, { method:'POST', headers:{'Content-Type':'application/json'},
              body: JSON.stringify({jsonrpc:'2.0',id:'vs1',method:'getTokenAccountsByOwner',
                params:[addr,{programId:'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA'},{encoding:'jsonParsed'}]})
            }).then(r=>r.json()).then(d => { console.log('[Ghost] SPL accts for',addr.slice(0,8),(d.result?.value||[]).length); return d; }),
            fetch(RPC_URL, { method:'POST', headers:{'Content-Type':'application/json'},
              body: JSON.stringify({jsonrpc:'2.0',id:'vs2',method:'getTokenAccountsByOwner',
                params:[addr,{programId:'TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb'},{encoding:'jsonParsed'}]})
            }).then(r=>r.json())
          ]);
          const fetchResults = await Promise.all(allFetches);
          const vaultAccts = fetchResults.flatMap(d => d.result?.value || []);
          // Deduplicate by token account pubkey (same ATA won't appear twice)
          const seen = new Set();
          const deduped = vaultAccts.filter(a => { if (seen.has(a.pubkey)) return false; seen.add(a.pubkey); return true; });
          // Exclude the ghost_stake_vault token account ‚Äî holds protocol-locked staked $GHOST
          // Users cannot withdraw this until they abandon ghost; it should not appear in vault UI
          const _stakeVaultKey = ghostState.ghostStakeVault;
          const userAccts = deduped.filter(a => {
            if (_stakeVaultKey && a.pubkey === _stakeVaultKey) return false; // staked GHOST ‚Äî protocol-locked
            const _mint = a.account?.data?.parsed?.info?.mint;
            if (_mint && isProtocolMint(_mint)) return false; // GHOST/DBD ‚Äî protocol-only tokens
            return true;
          });
          console.log('[Ghost] Vault accts:', deduped.length, 'after excluding stake vault + protocol mints:', userAccts.length);
          vaultAccts.splice(0, vaultAccts.length, ...userAccts);
          if (true) { // keep original block structure
          // Rebuild vaultTokens from on-chain data
          const freshVault = [];
          for (const acct of vaultAccts) {
            const info = acct.account.data.parsed?.info;
            if (!info) continue;
            // Use raw integer amount to detect presence ‚Äî uiAmountString can round to "0"
            // for small balances (e.g. 1 raw unit of a 9-decimal token = 0.000000001)
            const rawAmount = BigInt(info.tokenAmount.amount || '0');
            if (rawAmount <= 0n) continue;
            const decimals = info.tokenAmount.decimals || 0;
            // Compute balance from raw amount to avoid floating-point rounding to zero
            const balance = Number(rawAmount) / Math.pow(10, decimals);
            const mint = info.mint;
            // Normalise wSOL ‚Üí display as SOL (same as native)
            const _isWSOL = mint === 'So11111111111111111111111111111111111111112';
            const _normMint = _isWSOL ? 'native' : mint;
            const meta = ghostState.walletTokens.find(t => t.mint === _normMint || t.mint === mint)
                      || ghostState.vaultTokens.find(t => t.mint === _normMint || t.mint === mint)
                      || {};
            const _rawSym = _isWSOL ? 'SOL' : (meta.symbol || mint.slice(0,6));
            const _rawLogo = _isWSOL ? 'https://raw.githubusercontent.com/solana-labs/token-list/main/assets/mainnet/So11111111111111111111111111111111111111112/logo.png' : (meta.logoUrl || null);
            const _rawName = _isWSOL ? 'Solana' : (meta.name || null);
            freshVault.push({
              symbol: _rawSym,
              mint: _normMint, // store as 'native' so it merges with SOL entries
              balance,
              decimals,
              logoUrl: _rawLogo,
              name: _rawName,
              _unknownMeta: !_isWSOL && !meta.symbol && !meta.name
            });
          }
          // Fetch native SOL (lamport) balance of each vault PDA and inject as 'native' entry
          for (const pdaAddr of pdaAddrs) {
            try {
              const _solR = await fetch(RPC_URL, {method:'POST',headers:{'Content-Type':'application/json'},
                body:JSON.stringify({jsonrpc:'2.0',id:'vsolbal',method:'getBalance',params:[pdaAddr]})});
              const _solD = await _solR.json();
              const _lamps = _solD.result?.value || 0;
              const _solBal = Math.max(0, _lamps / 1e9 - 0.01); // subtract ~0.01 SOL rent reserve
              if (_solBal > 0) {
                const _exSol = freshVault.find(v => v.mint === 'native');
                if (_exSol) { _exSol.balance = Math.max(_exSol.balance, _solBal); }
                else { freshVault.push({symbol:'SOL',mint:'native',balance:_solBal,decimals:9,logoUrl:'https://raw.githubusercontent.com/solana-labs/token-list/main/assets/mainnet/So11111111111111111111111111111111111111112/logo.png',name:'Solana',_unknownMeta:false}); }
              }
            } catch(_) {}
          }
          if (freshVault.length > 0 || vaultAccts.length >= 0) {
            // Merge: preserve logos/names from existing entries, update balances from chain
            for (const fresh of freshVault) {
              const existing = ghostState.vaultTokens.find(v => v.mint === fresh.mint);
              if (existing) {
                existing.balance = fresh.balance;
                if (fresh.logoUrl) existing.logoUrl = fresh.logoUrl;
              } else {
                ghostState.vaultTokens.push(fresh);
              }
            }
            // Remove vault tokens that no longer have on-chain balance
            // Exception: keep tokens marked _pendingDeposit for 8s ‚Äî RPC may lag behind confirmed tx
            const _now = Date.now();
            ghostState.vaultTokens = ghostState.vaultTokens.filter(v => {
              if (freshVault.find(f => f.mint === v.mint)) return true; // found on chain ‚Äî keep
              if (v._pendingDeposit && (_now - v._pendingDeposit) < 8000) return true; // recent deposit ‚Äî protect
              return false; // genuinely gone ‚Äî remove
            });
            // Clear _pendingDeposit flag on tokens now confirmed on-chain
            ghostState.vaultTokens.forEach(v => {
              if (v._pendingDeposit && freshVault.find(f => f.mint === v.mint)) delete v._pendingDeposit;
            });
            const vaultOnlyMints = freshVault
              .filter(v => !ghostState.walletTokens.find(w => w.mint === v.mint) && !v.name)
              .map(v => v.mint);
            // Refresh picker immediately with whatever symbols we have (even mint slices)
            _refreshBenePickers();
            if (vaultOnlyMints.length > 0)
              fetchTokenMetadata(ghostState.vaultTokens, vaultOnlyMints)
                .then(()=>{renderVaultOverview();renderVaultHoldings();_refreshBenePickers();}).catch(()=>{});
          }
          console.log('[Ghost] Vault tokens from chain:', ghostState.vaultTokens.map(v => v.symbol + ':' + v.balance));
          } // end if(true)
        }
      } catch(e) { console.warn('[Ghost] Vault fetch error:', e); }
    }

    populateAllPickers();
    _refreshBenePickers(); // rebuild bene picker with freshly loaded vault tokens (SOL + SPL)
    fetchPumpFunData(); // get logos/prices for any pump.fun tokens
  } catch(err) {
    console.error('Token load error:', err);
    showNotif('Could not load wallet tokens', 'error');
  }
}

// Fetch token name + image from on-chain Metaplex metadata
async function fetchTokenMetadata(tokens, mints) {
  // Step 1: Try Jupiter token list for established tokens
  try {
    const res = await fetch('https://token.jup.ag/all');
    if (res.ok) {
      const list = await res.json();
      const byMint = {};
      for (const t of list) byMint[t.address] = t;
      for (const token of tokens) {
        if (!mints.includes(token.mint)) continue;
        const meta = byMint[token.mint];
        if (meta) {
          token.symbol = meta.symbol || token.symbol;
          token.name = meta.name;
          if (meta.logoURI) token.logoUrl = meta.logoURI;
        }
      }
    }
  } catch(e) {}

  // Step 2: For any still-unknown tokens (pump.fun etc), use Helius getAsset
  const stillUnknown = tokens.filter(t => mints.includes(t.mint) && t.symbol?.includes('...'));
  await Promise.all(stillUnknown.map(async token => {
    try {
      const res = await fetch(HELIUS_API, {
        method: 'POST', headers: {'Content-Type': 'application/json'},
        body: JSON.stringify({jsonrpc:'2.0', id:'meta', method:'getAsset', params:{id: token.mint}})
      });
      if (!res.ok) return;
      const d = await res.json();
      const asset = d?.result;
      const sym = asset?.content?.metadata?.symbol;
      const name = asset?.content?.metadata?.name;
      const img = asset?.content?.links?.image || asset?.content?.files?.[0]?.cdn_uri;
      const jsonUri = asset?.content?.json_uri;

      if (sym) { token.symbol = sym; token.name = name; }
      if (img) token.logoUrl = normaliseUrl(img);

      // Fetch off-chain JSON if no direct image
      if (!token.logoUrl && jsonUri && (jsonUri.startsWith('http') || jsonUri.startsWith('ipfs'))) {
        try {
          const metaRes = await fetch(normaliseUrl(jsonUri));
          if (metaRes.ok) {
            const meta = await metaRes.json();
            const metaImg = meta.image || meta.image_uri;
            if (metaImg) token.logoUrl = normaliseUrl(metaImg);
            if (!sym && meta.symbol) { token.symbol = meta.symbol; token.name = meta.name; }
          }
        } catch(e) {}
      }
      console.log('[Ghost] Helius metadata:', token.mint.slice(0,8), '‚Üí', token.symbol, token.logoUrl ? '(logo)' : '(no logo)');
    } catch(e) {}
  }));
}

// Rebuild bene + burn pickers from current vault + beneficiary state
function _refreshBenePickers() {
  // Re-check: if no whole vault set but pickers are empty, trigger full vault re-fetch
  const _wvPct = ghostState.ghost.beneficiaries
    .filter(b => b.action === 'whole-vault-share').reduce((s,b) => s + (b.sharePct||0), 0);
  if (_wvPct === 0 && ghostState.vaultTokens.length > 0 && ghostState.ghost.status !== 'none') {
    // Paranoia: clear any orphaned whole-vault-share entries that survived without a chain record
    if (!ghostState.ghost.wholeVaultRecipient) {
      ghostState.ghost.beneficiaries = ghostState.ghost.beneficiaries.filter(b => b.action !== 'whole-vault-share');
    }
  }
  const assignable = vaultAssignableTokens();
  buildPickerDropdown('bene', [WHOLE_VAULT_TOKEN, ...assignable]);
  buildPickerDropdown('burn', assignable);
  // If current selection is no longer available, reset it
  const curBene = ghostState.selectedTokens.bene;
  if (curBene && curBene.mint !== '__whole_vault__') {
    const stillAvailable = assignable.find(a => a.mint === curBene.mint);
    if (!stillAvailable) {
      ghostState.selectedTokens.bene = null;
      const symEl = document.getElementById('benePickerSymbol');
      const balEl = document.getElementById('benePickerBal');
      const logoEl = document.getElementById('benePickerLogo');
      if (symEl) symEl.textContent = 'Select vault asset';
      if (balEl) balEl.textContent = '';
      if (logoEl) logoEl.innerHTML = '';
    } else {
      // Update displayed remaining balance
      const balEl = document.getElementById('benePickerBal');
      if (balEl) balEl.textContent = stillAvailable.isWholeVault ? 'all tokens ¬∑ % shares' : stillAvailable.balance.toLocaleString(undefined,{maximumFractionDigits:6}) + ' available';
    }
  }
  const curBurn = ghostState.selectedTokens.burn;
  if (curBurn) {
    const stillAvailable = assignable.find(a => a.mint === curBurn.mint);
    if (!stillAvailable) {
      ghostState.selectedTokens.burn = null;
      const symEl = document.getElementById('burnPickerSymbol');
      const balEl = document.getElementById('burnPickerBal');
      const logoEl = document.getElementById('burnPickerLogo');
      if (symEl) symEl.textContent = 'Select vault asset';
      if (balEl) balEl.textContent = '';
      if (logoEl) logoEl.innerHTML = '';
    }
  }
  // Refresh remaining label
  updateBeneRemaining();
}

// Returns vault tokens with remaining unassigned balance (for bene/burn pickers)
function vaultAssignableTokens() {
  // Check if whole-vault plan covers 100% ‚Äî if so, no individual tokens available
  const wholeVaultPct = ghostState.ghost.beneficiaries
    .filter(b => b.action === 'whole-vault-share')
    .reduce((s, b) => s + (b.sharePct || 0), 0);
  if (wholeVaultPct >= 100) return []; // entire vault is already spoken for

  return ghostState.vaultTokens
    .filter(vt => {
      if (vt.balance <= 0) return false; // exclude zero/negative balance
      // NOTE: do NOT filter _unknownMeta here ‚Äî tokens appear in picker immediately after deposit
      // even before metadata resolves; symbol will be a mint slice until metadata loads
      if (isProtocolMint(vt.mint)) return false; // GHOST/DBD ‚Äî protocol-only, never vault-assignable
      // Filter out tokens with no verified metadata
      const sym = vt.symbol || '';
      const mintStr = vt.mint || '';
      // Only hard-filter tokens with NO symbol at all (truly blank) ‚Äî everything else shows
      // Metadata loads async; a mint-slice symbol is better than hiding the token entirely
      if (!sym && mintStr !== 'native') return false; // no symbol at all ‚Äî skip
      // Sum only specific transfer/burn assignments (not whole-vault-share)
      const _matchBene = b => b.action !== 'whole-vault-share' && (b.token === vt.symbol || b.token === vt.mint || b.mint === vt.mint);
      const assigned = ghostState.ghost.beneficiaries.filter(_matchBene).reduce((s, b) => s + (b.amount || 0), 0);
      return assigned < vt.balance; // still has unassigned balance
    })
    .map(vt => {
      const _matchBene = b => b.action !== 'whole-vault-share' && (b.token === vt.symbol || b.token === vt.mint || b.mint === vt.mint);
      const assigned = ghostState.ghost.beneficiaries.filter(_matchBene).reduce((s, b) => s + (b.amount || 0), 0);
      return { ...vt, balance: +(vt.balance - assigned).toFixed(9) };
    });
}

// "Whole vault" pseudo-token for the bene picker
const WHOLE_VAULT_TOKEN = { symbol: 'Whole Vault', mint: '__whole_vault__', balance: 0, logoUrl: null, isWholeVault: true, chestIcon: true };

function populateAllPickers() {
  const t = ghostState.walletTokens;
  // Deposit picker: wallet tokens with balance > 0
  const depositTokens = t.filter(tok => tok.balance > 0 && !isProtocolMint(tok.mint)); // GHOST/DBD ‚Äî protocol-only, not depositable
  buildPickerDropdown('deposit', depositTokens);
  // Bene picker: assignable vault tokens + whole vault option at bottom
  const assignable = vaultAssignableTokens();
  const beneTokens = [WHOLE_VAULT_TOKEN, ...assignable];
  buildPickerDropdown('bene', beneTokens);
  // Burn picker: only real vault tokens with remaining balance
  buildPickerDropdown('burn', assignable);
  // Auto-select first token
  if (depositTokens.length > 0 && !ghostState.selectedTokens.deposit) selectToken('deposit', depositTokens[0].mint);
  // Bene picker: show "Select asset" placeholder by default, don't auto-select
  if (!ghostState.selectedTokens.bene) {
    // Show placeholder
    const symEl = document.getElementById('benePickerSymbol');
    const balEl = document.getElementById('benePickerBal');
    if (symEl) { symEl.textContent = 'Select asset'; symEl.style.color = 'var(--muted)'; }
    if (balEl) balEl.textContent = '';
  }
  if (assignable.length > 0 && !ghostState.selectedTokens.burn) selectToken('burn', assignable[0].mint);
  buildPickerDropdown('vault', ghostState.vaultTokens);
}

// ‚îÄ‚îÄ‚îÄ Vault Overview (on Overview page) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// ‚îÄ‚îÄ‚îÄ Vault sort: SOL first, then by USD value desc ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function sortedVaultTokens() {
  return [...ghostState.vaultTokens].sort((a, b) => {
    const aIsSOL = a.mint === 'native' || a.mint === WSOL_MINT_PK_STR;
    const bIsSOL = b.mint === 'native' || b.mint === WSOL_MINT_PK_STR;
    if (aIsSOL && !bIsSOL) return -1;
    if (!aIsSOL && bIsSOL) return 1;
    const aUsd = a.balance * (getTokenPrice(a) || 0);
    const bUsd = b.balance * (getTokenPrice(b) || 0);
    return bUsd - aUsd;
  });
}

function renderVaultOverview() {
  const el = document.getElementById('dbVaultOverview');
  if (!el) return;
  const tokens = sortedVaultTokens();
  if (tokens.length === 0) {
    el.innerHTML = '<div style="padding:16px 20px;font-family:\'Share Tech Mono\',monospace;font-size:12px;color:#c0bce0">No assets in vault</div>';
    const usdEl = document.getElementById('dbVaultUsdTotal');
    const subEl = document.getElementById('dbVaultUsdSub');
    if (usdEl) usdEl.textContent = '';
    if (subEl) subEl.style.display = 'none';
    return;
  }

  let totalUsd = 0;
  const rows = tokens.map(t => {
    const price = getTokenPrice(t);
    const usdVal = t.balance * price;
    totalUsd += usdVal;
    const usdStr = usdVal > 0 ? ' ¬∑ ~$' + usdVal.toFixed(2) : '';
    return `<div data-ov-mint="${t.mint}" style="display:flex;align-items:center;gap:14px;padding:12px 20px;border-bottom:1px solid rgba(102,51,255,0.06)">
      <div data-ov-logo="${t.mint}" style="width:36px;height:36px;flex-shrink:0;overflow:hidden">${tokenLogoEl(t.symbol, 36, t.logoUrl||null)}</div>
      <div style="flex:1">
        <div style="font-family:'Syne',sans-serif;font-weight:700;font-size:15px;color:#f0f0f8">${t.symbol}</div>
        <div data-ov-bal="${t.mint}" style="font-family:'Share Tech Mono',monospace;font-size:12px;color:#c0bce0">${t.balance.toLocaleString(undefined,{maximumFractionDigits:6})} ${t.symbol}${usdStr}</div>
      </div>
    </div>`;
  }).join('');

  // Always full rebuild to avoid stale diff artifacts
  el.innerHTML = rows;
  const usdEl = document.getElementById('dbVaultUsdTotal');
  const subEl = document.getElementById('dbVaultUsdSub');
  if (usdEl) {
    if (totalUsd > 0) {
      usdEl.textContent = '$' + totalUsd.toLocaleString(undefined, {minimumFractionDigits:2, maximumFractionDigits:2});
      if (subEl) subEl.style.display = 'block';
    } else {
      usdEl.textContent = '';
      if (subEl) subEl.style.display = 'none';
    }
  }
}

// ‚îÄ‚îÄ‚îÄ Ping History ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
ghostState.pingHistory = []; // [{num, ts, tx, gap}]

function addPingToHistory(tx) {
  const now = Date.now();
  const last = ghostState.pingHistory[0]?.ts;
  const gap = last ? formatDuration(now - last) : '‚Äî';
  const num = ghostState.ghost.pingCount;
  ghostState.pingHistory.unshift({ num, ts: now, tx, gap });
  renderPingHistory();
}

function renderPingHistory() {
  const tbody = document.getElementById('dbPingHistory');
  if (!tbody) return;
  if (ghostState.pingHistory.length === 0) {
    tbody.innerHTML = '<tr><td colspan="4" style="text-align:center;color:#c0bce0;padding:20px">No pings recorded yet this session</td></tr>';
    return;
  }
  tbody.innerHTML = ghostState.pingHistory.map(p => {
    const d = new Date(p.ts);
    const dateStr = d.toLocaleDateString('en-GB', { day:'numeric', month:'short', year:'numeric' }) + ' ' + d.toLocaleTimeString('en-GB', { hour:'2-digit', minute:'2-digit' });
    return `<tr>
      <td style="color:#c0bce0">${p.num}</td>
      <td>${dateStr}</td>
      <td style="white-space:nowrap"><span class="addr-short">${p.tx.length>12?p.tx.slice(0,4)+'...'+p.tx.slice(-4):p.tx}</span><button onclick="copyAddr('${p.tx}')" title="Copy tx" style="background:none;border:1px solid rgba(102,51,255,0.25);color:#8888bb;font-size:10px;padding:1px 5px;cursor:pointer;margin-left:4px;font-family:'Share Tech Mono',monospace;vertical-align:middle;line-height:1.4">\u29C9</button></td>
      <td style="color:#c0bce0">${p.gap}</td>
    </tr>`;
  }).join('');
}

// ‚îÄ‚îÄ‚îÄ Recovery Wallets (up to 3) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
ghostState.recoveryWallets = []; // [{address, canWithdraw}]

function renderRecoveryWallets() {
  const el = document.getElementById('recoveryWalletsList');
  if (!el) return;

  const form = document.getElementById('addRecoveryForm');
  if (form) form.style.display = ghostState.recoveryWallets.length >= 3 ? 'none' : 'block';

  if (ghostState.recoveryWallets.length === 0) {
    el.innerHTML = '<div class="db-info" style="margin-bottom:0">No recovery wallets configured.</div>';
    // Update overview card
    const statusEl = document.getElementById('dbRecoveryStatus');
    const shortEl = document.getElementById('dbRecoveryShort');
    if (statusEl) statusEl.textContent = 'NONE';
    if (shortEl) shortEl.textContent = 'not configured';
    return;
  }

  el.innerHTML = ghostState.recoveryWallets.map((w, i) => `
    <div class="db-form" style="margin-bottom:12px;padding:16px 20px">
      <div style="display:flex;align-items:center;justify-content:space-between;gap:12px;flex-wrap:wrap">
        <div style="flex:1">
          <div style="font-family:'Share Tech Mono',monospace;font-size:11px;color:#c0bce0;letter-spacing:0.15em;text-transform:uppercase;margin-bottom:4px">Recovery Wallet ${i+1}</div>
          <div style="font-family:'Share Tech Mono',monospace;font-size:13px;color:var(--text);word-break:break-all;display:flex;align-items:center;gap:8px">
            ${w.address}
            <button onclick="copyAddr('${w.address}')" style="background:none;border:1px solid rgba(102,51,255,0.2);color:#c0bce0;font-family:Share Tech Mono,monospace;font-size:10px;padding:2px 7px;cursor:pointer" title="Copy">‚ßâ</button>
          </div>
          <div style="margin-top:8px;display:flex;gap:16px">
            <label style="display:flex;align-items:center;gap:6px;cursor:default;font-family:'Share Tech Mono',monospace;font-size:12px;color:var(--green)">
              <input type="checkbox" checked disabled style="accent-color:#33ff99"> Cancel awakening
            </label>
            <label style="display:flex;align-items:center;gap:6px;cursor:pointer;font-family:'Share Tech Mono',monospace;font-size:12px;color:${w.canWithdraw ? 'var(--amber)' : 'var(--muted)'}">
              <input type="checkbox" ${w.canWithdraw ? 'checked' : ''} onchange="toggleRecoveryWithdraw(${i}, this.checked)" style="accent-color:#ffb830;cursor:pointer"> Vault withdrawals
            </label>
          </div>
        </div>
        <button class="db-btn db-btn-danger" style="padding:7px 14px;font-size:11px;flex-shrink:0" onclick="dbRemoveRecoveryWallet(${i})">üóëÔ∏è Remove</button>
      </div>
    </div>`).join('');

  // Update overview card
  const statusEl = document.getElementById('dbRecoveryStatus');
  const shortEl = document.getElementById('dbRecoveryShort');
  if (statusEl) statusEl.textContent = ghostState.recoveryWallets.length + ' SET';
  if (shortEl) {
    const a = ghostState.recoveryWallets[0].address;
    shortEl.textContent = a.slice(0,4)+'...'+a.slice(-4) + (ghostState.recoveryWallets.length > 1 ? ' +' + (ghostState.recoveryWallets.length-1) + ' more' : '');
  }
}

async function dbAddRecoveryWallet() {
  const addr = document.getElementById('dbNewRecovery').value.trim();
  if (!addr || addr.length < 32) { showNotif('‚ö†Ô∏è Enter a valid Solana address', 'error'); return; }
  if (ghostState.recoveryWallets.find(w => w.address === addr)) { showNotif('‚ö†Ô∏è Address already added', 'error'); return; }
  if (ghostState.recoveryWallets.length >= 3) { showNotif('‚ö†Ô∏è Maximum 3 recovery wallets', 'error'); return; }
  const canWithdraw = document.getElementById('permWithdraw').checked;

  // Find next free slot index (0‚Äì2)
  const usedSlots = ghostState.recoveryWallets.map(w => w.slotIndex ?? 0);
  const slotIndex = [0, 1, 2].find(i => !usedSlots.includes(i)) ?? ghostState.recoveryWallets.length;

  // Demo mode
  if (!ghostState.provider || ghostState.walletName?.includes('demo')) {
    ghostState.recoveryWallets.push({ address: addr, canWithdraw, slotIndex });
    if (ghostState.recoveryWallets.length === 1) ghostState.ghost.recoveryWallet = addr;
    document.getElementById('dbNewRecovery').value = '';
    renderRecoveryWallets();
    showNotif('‚úÖ Recovery wallet set [demo]', 'green');
    return;
  }

  // On-chain: update_recovery_wallet(index: u8, wallet: Option<Pubkey>)
  try {
    showNotif('Setting recovery wallet on-chain...', '');
    const { PublicKey, Transaction, TransactionInstruction } = solanaWeb3;
    const walletPk = new PublicKey(ghostState.publicKey);
    const ghostPda = new PublicKey(ghostState.ghostPda);
    const programId = new PublicKey(PROGRAM_ID);

    // Discriminator: sha256("global:update_recovery_wallet")[0:8]
    const disc = [17, 163, 88, 154, 97, 78, 169, 93];
    // Args: index(u8=1) + wallet(Option<Pubkey>=33) = 34 bytes total
    const data = new Uint8Array(8 + 1 + 33);
    data.set(disc, 0);
    data[8] = slotIndex; // index: u8
    data[9] = 1;         // Some
    data.set(new PublicKey(addr).toBytes(), 10);

    const ix = new TransactionInstruction({
      programId,
      keys: [
        { pubkey: ghostPda, isSigner: false, isWritable: true },
        { pubkey: walletPk, isSigner: true, isWritable: false },
      ],
      data
    });

    const connection = new solanaWeb3.Connection(RPC_URL, 'confirmed');
    const { blockhash } = await connection.getLatestBlockhash();
    const tx = new Transaction({ recentBlockhash: blockhash, feePayer: walletPk });
    tx.add(ix);
    tx.instructions.forEach((ix, i) =>
      console.log(`[Ghost] ix${i}: prog=${ix.programId.toBase58()} accounts=${ix.keys.length} data=${ix.data.length}b`)
    );
    const signed = await ghostState.provider.signTransaction(tx);
    const sig = await connection.sendRawTransaction(signed.serialize(), { skipPreflight: true });
    await connection.confirmTransaction(sig, 'confirmed');

    ghostState.recoveryWallets.push({ address: addr, canWithdraw, slotIndex });
    if (ghostState.recoveryWallets.length === 1) ghostState.ghost.recoveryWallet = addr;
    document.getElementById('dbNewRecovery').value = '';
    renderRecoveryWallets();
    showNotif('‚úÖ Recovery wallet set on-chain!', 'green');
  } catch(err) {
    showNotif('Failed: ' + (err.message || err), 'error');
  }
}

async function dbRemoveRecoveryWallet(idx) {
  const _ok4 = await ghostConfirm({ icon:'üîë', title:'Remove Recovery Wallet', message:'Remove this recovery wallet on-chain? You can set a new one at any time.', okLabel:'REMOVE', danger:true }); if (!_ok4) return;

  const slotIndex = ghostState.recoveryWallets[idx]?.slotIndex ?? idx;

  if (!ghostState.provider || ghostState.walletName?.includes('demo')) {
    ghostState.recoveryWallets.splice(idx, 1);
    if (!ghostState.recoveryWallets.length) ghostState.ghost.recoveryWallet = null;
    renderRecoveryWallets();
    return;
  }

  try {
    showNotif('Removing recovery wallet on-chain...', '');
    const { PublicKey, Transaction, TransactionInstruction } = solanaWeb3;
    const walletPk = new PublicKey(ghostState.publicKey);
    const ghostPda = new PublicKey(ghostState.ghostPda);
    const programId = new PublicKey(PROGRAM_ID);

    const disc = [17, 163, 88, 154, 97, 78, 169, 93];
    // Args: index(u8=1) + wallet(Option<Pubkey>=None=1byte) = 2 bytes
    const data = new Uint8Array(8 + 2);
    data.set(disc, 0);
    data[8] = slotIndex; // index: u8
    data[9] = 0;         // None

    const ix = new TransactionInstruction({
      programId,
      keys: [
        { pubkey: ghostPda, isSigner: false, isWritable: true },
        { pubkey: walletPk, isSigner: true, isWritable: false },
      ],
      data
    });

    const connection = new solanaWeb3.Connection(RPC_URL, 'confirmed');
    const { blockhash } = await connection.getLatestBlockhash();
    const tx = new Transaction({ recentBlockhash: blockhash, feePayer: walletPk });
    tx.add(ix);
    tx.instructions.forEach((ix, i) =>
      console.log(`[Ghost] ix${i}: prog=${ix.programId.toBase58()} accounts=${ix.keys.length} data=${ix.data.length}b`)
    );
    const signed = await ghostState.provider.signTransaction(tx);
    const sig = await connection.sendRawTransaction(signed.serialize(), { skipPreflight: true });
    await connection.confirmTransaction(sig, 'confirmed');

    ghostState.recoveryWallets.splice(idx, 1);
    if (!ghostState.recoveryWallets.length) ghostState.ghost.recoveryWallet = null;
    renderRecoveryWallets();
    showNotif('Recovery wallet removed on-chain', 'green');
  } catch(err) {
    showNotif('Failed: ' + (err.message || err), 'error');
  }
}

function toggleRecoveryWithdraw(idx, val) {
  ghostState.recoveryWallets[idx].canWithdraw = val;
  showNotif(val ? '‚ö†Ô∏è Withdrawal rights granted' : 'Withdrawal rights revoked', val ? 'info' : 'info');
}

// Legacy stubs for old calls
function dbUpdateRecovery() { dbAddRecoveryWallet(); }
function dbRemoveRecovery() { if (ghostState.recoveryWallets.length) dbRemoveRecoveryWallet(0); }

// ‚îÄ‚îÄ‚îÄ Copyable addresses ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function copyAddr(addr) {
  navigator.clipboard?.writeText(addr).then(() => showNotif('‚úÖ Address copied', 'green')).catch(() => showNotif('Copy failed', 'error'));
}
// Helper: how much of a vault token is assigned to specific beneficiaries
function vaultAssignedAmount(symbol, mint) {
  return ghostState.ghost.beneficiaries
    .filter(b => b.action !== 'whole-vault-share' && (b.token === symbol || b.token === mint))
    .reduce((s, b) => s + (b.amount || 0), 0);
}

function renderVaultHoldings() {
  const el = document.getElementById('vaultHoldingsList');
  if (!el) return;
  if (ghostState.vaultTokens.length === 0) {
    el.innerHTML = '<div style="padding:24px;text-align:center;font-family:\'Share Tech Mono\',monospace;font-size:12px;color:#c0bce0">No assets in vault yet.</div>';
    const tot = document.getElementById('vaultHoldingsUsdTotal');
    if (tot) { tot.textContent = ''; tot.style.textShadow = ''; }
    const sub = document.getElementById('vaultHoldingsUsdSub');
    if (sub) sub.style.display = 'none';
    return;
  }

  const wholeVaultPct = ghostState.ghost.beneficiaries
    .filter(b => b.action === 'whole-vault-share')
    .reduce((s, b) => s + (b.sharePct || 0), 0);

  let totalUsd = 0;
  const rows = sortedVaultTokens().map((t, i) => {
    // Normalise wSOL ‚Üí display as SOL everywhere in vault
    if (t.mint === WSOL_MINT_PK_STR || t.mint === 'So11111111111111111111111111111111111111112') t.symbol = 'SOL';
    const price = getTokenPrice(t);
    const usdVal = price > 0 ? t.balance * price : null;
    if (usdVal !== null) totalUsd += usdVal;
    const usdStr = usdVal !== null ? ` <span style="color:rgba(144,144,168,0.6)">\u2248 $${usdVal.toFixed(2)}</span>` : '';

    const assigned = wholeVaultPct >= 100 ? t.balance : vaultAssignedAmount(t.symbol, t.mint);
    const free = Math.max(0, +(t.balance - assigned).toFixed(9));
    const isFullyAssigned = assigned >= t.balance - 0.000000001;
    const isPartiallyAssigned = assigned > 0.000000001 && !isFullyAssigned;

    const badge = isFullyAssigned
      ? `<span style="font-family:'Share Tech Mono',monospace;font-size:9px;letter-spacing:0.12em;color:#a080ff;background:rgba(160,128,255,0.1);border:1px solid rgba(160,128,255,0.25);padding:2px 7px;margin-left:8px">ASSIGNED</span>`
      : isPartiallyAssigned
      ? `<span style="font-family:'Share Tech Mono',monospace;font-size:9px;letter-spacing:0.12em;color:#ff9933;background:rgba(255,153,51,0.08);border:1px solid rgba(255,153,51,0.25);padding:2px 7px;margin-left:8px">PARTIAL</span>`
      : '';

    const freeNote = isPartiallyAssigned
      ? `<span style="color:#ff9933;font-size:11px"> ¬∑ ${free.toLocaleString(undefined,{maximumFractionDigits:6})} free / ${assigned.toLocaleString(undefined,{maximumFractionDigits:6})} assigned</span>`
      : isFullyAssigned
      ? `<span style="color:#a080ff;font-size:11px"> ¬∑ fully assigned to beneficiar${ghostState.ghost.beneficiaries.filter(b=>b.token===t.symbol&&b.action!=='whole-vault-share').length===1?'y':'ies'}</span>`
      : '';

    const canWd = !isFullyAssigned && free > 0;
    const wdMax = canWd ? free : 0;

    return `
    <div class="vault-asset-row" data-mint="${t.mint}" style="${isFullyAssigned ? 'opacity:0.78;background:rgba(160,128,255,0.025)' : ''}">
      <div class="vault-asset-icon" style="background:none;overflow:hidden" data-logo="${t.mint}">${tokenLogoEl(t.symbol, 36, t.logoUrl||null)}</div>
      <div class="vault-asset-info">
        <div class="vault-asset-symbol" style="display:flex;align-items:center;gap:8px">${t.symbol}${badge}<button onclick="excludeVaultMint('${t.mint}')" title="Hide this token from vault" style="background:none;border:none;color:#50406a;font-size:10px;cursor:pointer;padding:1px 3px;font-family:'Share Tech Mono',monospace;line-height:1;flex-shrink:0" onmouseover="this.style.color='#ff6688'" onmouseout="this.style.color='#50406a'">‚úï hide</button></div>
        <div class="vault-asset-bal" data-bal="${t.mint}">${t.balance.toLocaleString(undefined,{maximumFractionDigits:6})} ${t.symbol} in vault${usdStr}${freeNote}</div>
      </div>
      <div class="vault-asset-actions">
        ${canWd
          ? `<input class="vault-asset-input" type="text" inputmode="decimal" id="wdAmt${i}" placeholder="Amount" oninput="formatWithdrawInput(this,${wdMax})">
             <button class="db-btn db-btn-outline" style="padding:7px 14px;font-size:11px" onclick="dbWithdrawAsset(${i})">Withdraw</button>
             <button class="db-btn db-btn-outline" style="padding:7px 8px;font-size:11px" onclick="fillMaxWithdraw('wdAmt${i}',${wdMax})">MAX</button>`
          : `<input class="vault-asset-input" type="text" inputmode="decimal" id="wdAmt${i}" placeholder="‚Äî" disabled style="opacity:0.3">
             <button class="db-btn db-btn-outline" style="padding:7px 14px;font-size:11px;opacity:0.3;cursor:not-allowed" disabled title="${isFullyAssigned ? 'Fully assigned to beneficiaries ‚Äî remove the beneficiary first to withdraw' : 'No free balance'}">Withdraw</button>
             <button class="db-btn db-btn-outline" style="padding:7px 8px;font-size:11px;opacity:0.3;cursor:not-allowed" disabled>MAX</button>`
        }
      </div>
    </div>`;
  }).join('');

  el.innerHTML = rows;

  // Restore logos without re-fetching
  ghostState.vaultTokens.forEach((t) => {
    if (!t.logoUrl) return;
    const logoEl = el.querySelector(`[data-logo="${t.mint}"]`);
    if (logoEl) {
      const img = logoEl.querySelector('img');
      if (!img || !img.src.startsWith('http')) logoEl.innerHTML = tokenLogoEl(t.symbol, 36, t.logoUrl);
    }
  });

  const tot = document.getElementById('vaultHoldingsUsdTotal');
  const sub = document.getElementById('vaultHoldingsUsdSub');
  if (tot) {
    if (totalUsd > 0) {
      const whole = Math.floor(totalUsd).toLocaleString();
      const cents = (totalUsd % 1).toFixed(2).slice(1);
      tot.innerHTML = `<span style="font-size:0.55em;vertical-align:super;margin-right:2px;opacity:0.7">$</span>${whole}<span style="font-size:0.45em;vertical-align:super;opacity:0.6">${cents}</span>`;
      tot.style.textShadow = '0 0 40px rgba(51,255,153,0.35)';
      if (sub) sub.style.display = 'block';
    } else {
      tot.innerHTML = ''; tot.style.textShadow = '';
      if (sub) sub.style.display = 'none';
    }
  }
  fetchPumpFunData();
  // Keep WITHDRAW ALL button and deposit notice in sync with beneficiary state
  const wdAllBtn = document.querySelector('button[onclick="dbWithdrawAll()"]');
  const wvBene = ghostState.ghost.beneficiaries.find(b => b.action === 'whole-vault-share');
  if (wdAllBtn) {
    wdAllBtn.disabled = !!wvBene;
    wdAllBtn.style.opacity = wvBene ? '0.3' : '1';
    wdAllBtn.style.cursor = wvBene ? 'not-allowed' : 'pointer';
    wdAllBtn.title = wvBene ? 'Vault is assigned to a beneficiary ‚Äî remove assignment first' : 'Withdraw all vault assets';
  }
  const depNotice = document.getElementById('depositWholeVaultNotice');
  const depRecip = document.getElementById('depositWholeVaultRecip');
  if (depNotice) depNotice.style.display = wvBene ? 'block' : 'none';
  if (depRecip && wvBene) depRecip.textContent = wvBene.recipient;
}

// ‚îÄ‚îÄ‚îÄ Bulk deposit / withdraw ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function dbDepositAll() {
  if (ghostState.provider && !ghostState.walletName?.includes('demo')) {
    showNotif('Use individual deposits for each asset ‚Äî Deposit All coming soon', 'error');
    return;
  }
  const tokens = ghostState.walletTokens.filter(tok => tok.balance > 0);
  if (tokens.length === 0) { showNotif('No assets with balance in wallet', 'error'); return; }
  let count = 0;
  for (const t of tokens) {
    const amount = t.balance;
    if (!amount || amount <= 0) continue;
    const symbol = t.symbol;
    const mint = t.mint;
    t.balance = 0;
    const existing = ghostState.vaultTokens.find(v => v.mint === mint);
    if (existing) {
      existing.balance += amount;
      if (!existing.logoUrl && t.logoUrl) existing.logoUrl = t.logoUrl;
    } else {
      ghostState.vaultTokens.push({ symbol, mint, balance: amount, decimals: t.decimals, logoUrl: t.logoUrl || null, name: t.name || null });
    }
    addActivityRow('Vault Deposit ' + amount.toLocaleString() + ' ' + symbol, randomTx(), 'deposit');
    count++;
  }
  if (count === 0) { showNotif('Nothing to deposit', 'error'); return; }

  // Rebuild deposit picker ‚Äî all tokens now 0
  buildPickerDropdown('deposit', []);
  const symEl = document.getElementById('depositPickerSymbol');
  const balEl = document.getElementById('depositPickerBal');
  const logoEl = document.getElementById('depositPickerLogo');
  if (symEl) symEl.textContent = 'Select asset';
  if (balEl) balEl.textContent = '';
  if (logoEl) logoEl.innerHTML = '';
  document.getElementById('depositBalance').value = '‚Äî';
  document.getElementById('depositAmt').value = '';
  document.getElementById('depositAmtDisplay').value = '';
  ghostState.selectedTokens.deposit = null;

  renderVaultHoldings();
  renderVaultOverview();
  _refreshBenePickers();
  showNotif('üì• Deposited all ' + count + ' asset' + (count > 1 ? 's' : '') + ' to vault!', 'green');
  saveSession();
  // Chain re-fetch: rebuild vaultTokens + bene picker + chart from RPC
  loadWalletTokens().catch(()=>{});
}

async function dbWithdrawAll() {
  if (ghostState.ghost.status === 'awakened') { showNotif('‚ö†Ô∏è Withdrawals blocked while awakened', 'error'); return; }
  const wholeVaultActive = ghostState.ghost.beneficiaries.some(b => b.action === 'whole-vault-share');
  if (wholeVaultActive) {
    const rec = ghostState.ghost.beneficiaries.find(b => b.action === 'whole-vault-share')?.recipient || '';
    showNotif('‚ö†Ô∏è Vault is assigned to ' + rec + ' ‚Äî remove beneficiary first', 'error'); return;
  }
  const tokens = [...ghostState.vaultTokens];
  if (tokens.length === 0) { showNotif('Vault is empty', 'error'); return; }

  // ‚îÄ‚îÄ Demo mode ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  if (!ghostState.provider || ghostState.walletName?.includes('demo')) {
    let count = 0;
    for (const vt of tokens) {
      const wt = ghostState.walletTokens.find(w => w.mint === vt.mint);
      if (wt) { wt.balance += vt.balance; } else {
        ghostState.walletTokens.push({ symbol: vt.symbol, mint: vt.mint, balance: vt.balance, decimals: vt.decimals, logoUrl: vt.logoUrl || null });
      }
      addActivityRow('Vault Withdrawal ' + vt.balance.toLocaleString() + ' ' + vt.symbol + ' [demo]', randomTx(), 'withdraw');
      count++;
    }
    ghostState.vaultTokens = [];
    const depositPool = ghostState.walletTokens.filter(tok => tok.balance > 0 && !isProtocolMint(tok.mint));
    buildPickerDropdown('deposit', depositPool); buildPickerDropdown('bene', [WHOLE_VAULT_TOKEN, ...vaultAssignableTokens()]); buildPickerDropdown('burn', vaultAssignableTokens());
    ghostState.selectedTokens.deposit = null;
    if (depositPool.length > 0) selectToken('deposit', depositPool[0].mint);
    renderVaultHoldings(); renderVaultOverview();
    showNotif('üì§ Withdrew all ' + count + ' asset' + (count > 1 ? 's' : '') + ' from vault! [demo]', 'green');
    saveSession(); return;
  }

  // ‚îÄ‚îÄ On-chain ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  const { PublicKey, Transaction, TransactionInstruction, Keypair, SystemProgram } = solanaWeb3;
  const walletPk  = new PublicKey(ghostState.publicKey);
  const ghostPda  = new PublicKey(ghostState.ghostPda);
  const vaultPda  = new PublicKey(ghostState.vaultPda);
  const programId = new PublicKey(PROGRAM_ID);
  const WSOL_MINT_PK = new PublicKey(WSOL_MINT_PK_STR);
  const TOKEN_PROG_PK = new PublicKey(TOKEN_PROGRAM_STR);
  const disc = [180, 34, 37, 46, 156, 0, 211, 238];
  const connection = new solanaWeb3.Connection(RPC_URL, 'confirmed');
  let successCount = 0;
  showNotif('Preparing withdrawal of ' + tokens.length + ' asset' + (tokens.length > 1 ? 's' : '') + '...', '');

  // Separate SOL (needs keypair co-sig) from SPL (can batch)
  const solTokens = tokens.filter(vt => vt.mint === WSOL_MINT_PK_STR || vt.mint === 'native');
  const splTokens = tokens.filter(vt => vt.mint !== WSOL_MINT_PK_STR && vt.mint !== 'native');

  // ‚îÄ‚îÄ Pre-fetch all SPL metadata in parallel ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  const splMeta = await Promise.all(splTokens.map(async vt => {
    const withdrawMintPk = new PublicKey(effectiveMint(vt.mint));
    let rawMintOwner = TOKEN_PROGRAM_STR;
    try { const ma = await connection.getAccountInfo(withdrawMintPk); rawMintOwner = ma?.owner?.toBase58() || TOKEN_PROGRAM_STR; } catch(e) {}
    const normalizedTokenProg = normalizeTokenProg(rawMintOwner);
    const rawTokenProgPk = new PublicKey(rawMintOwner || TOKEN_PROGRAM_STR);
    let vaultAta;
    try { const va = await connection.getTokenAccountsByOwner(vaultPda, { mint: withdrawMintPk }); if (va.value.length > 0) vaultAta = va.value[0].pubkey; } catch(e) {}
    if (!vaultAta) vaultAta = await findATAWithProg(vaultPda, withdrawMintPk, new PublicKey(normalizedTokenProg));
    let ownerAta;
    if (rawMintOwner === TOKEN_PROGRAM_STR) { ownerAta = await findATA(walletPk, withdrawMintPk); }
    else { const ex = await connection.getTokenAccountsByOwner(walletPk, { mint: withdrawMintPk }).catch(()=>({value:[]})); ownerAta = ex.value[0]?.pubkey || await findATA(walletPk, withdrawMintPk); }
    const ownerAtaInfo = await connection.getAccountInfo(ownerAta);
    return { vt, withdrawMintPk, rawTokenProgPk, vaultAta, ownerAta, ownerAtaMissing: !ownerAtaInfo };
  }));

  // ‚îÄ‚îÄ Batch SPL: up to 3 withdrawals per tx (one Phantom prompt per batch) ‚îÄ‚îÄ
  const BATCH_SIZE = 3;
  for (let i = 0; i < splMeta.length; i += BATCH_SIZE) {
    const batch = splMeta.slice(i, i + BATCH_SIZE);
    try {
      const { blockhash } = await connection.getLatestBlockhash();
      const tx = new Transaction({ recentBlockhash: blockhash, feePayer: walletPk });
      for (const m of batch) {
        const { vt, withdrawMintPk, rawTokenProgPk, vaultAta, ownerAta, ownerAtaMissing } = m;
        const amountRaw = BigInt(Math.round(vt.balance * Math.pow(10, vt.decimals)));
        const buf = new ArrayBuffer(8); new DataView(buf).setBigUint64(0, amountRaw, true);
        const data = new Uint8Array(16); data.set(disc, 0); data.set(new Uint8Array(buf), 8);
        if (ownerAtaMissing) tx.add(createATAInstruction(walletPk, ownerAta, walletPk, withdrawMintPk, rawTokenProgPk));
        tx.add(new TransactionInstruction({ programId, keys: [
          { pubkey: ghostPda,       isSigner: false, isWritable: false },
          { pubkey: vaultPda,       isSigner: false, isWritable: false },
          { pubkey: walletPk,       isSigner: true,  isWritable: true  },
          { pubkey: withdrawMintPk, isSigner: false, isWritable: false },
          { pubkey: ownerAta,       isSigner: false, isWritable: true  },
          { pubkey: vaultAta,       isSigner: false, isWritable: true  },
          { pubkey: rawTokenProgPk, isSigner: false, isWritable: false },
        ], data }));
      }
      showNotif('Sign to withdraw: ' + batch.map(m => m.vt.symbol).join(', ') + '...', '');
      const signed = await ghostState.provider.signTransaction(tx);
      let sig;
      try { sig = await connection.sendRawTransaction(signed.serialize(), { skipPreflight: false, preflightCommitment: 'confirmed' }); }
      catch(simErr) {
        let logs=[]; try { logs=await simErr.getLogs(connection); } catch(_){} if (!logs?.length) { try { const s=await connection.simulateTransaction(tx); logs=s.value.logs||[]; } catch(_){} }
        console.error('[Ghost] batch TX logs:', logs); throw new Error('TX failed: ' + simErr.message + (logs.slice(-5).length?' | '+logs.slice(-5).join(' | '):''));
      }
      const conf = await connection.confirmTransaction(sig, 'confirmed');
      if (conf.value?.err) throw new Error('TX failed: ' + JSON.stringify(conf.value.err));
      for (const m of batch) {
        const { vt } = m;
        const wt = ghostState.walletTokens.find(w => w.mint === vt.mint);
        if (wt) { wt.balance += vt.balance; } else { ghostState.walletTokens.push({ symbol: vt.symbol, mint: vt.mint, balance: vt.balance, decimals: vt.decimals, logoUrl: vt.logoUrl || null }); }
        const idx = ghostState.vaultTokens.indexOf(vt); if (idx !== -1) ghostState.vaultTokens.splice(idx, 1);
        addActivityRow('Vault Withdrawal ' + vt.balance.toLocaleString() + ' ' + vt.symbol, sig.slice(0,4)+'...'+sig.slice(-4), 'withdraw');
        successCount++;
      }
    } catch(err) {
      const syms = batch.map(m => m.vt.symbol).join(', ');
      console.error('Batch withdraw error [' + syms + ']:', err);
      showNotif('‚ö†Ô∏è Batch failed [' + syms + ']: ' + (err.message || err), 'error');
    }
  }

  // ‚îÄ‚îÄ SOL: always separate tx (needs keypair co-sig) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  for (const vt of solTokens) {
    try {
      const amount = vt.balance;
      let vaultAta;
      try { const va = await connection.getTokenAccountsByOwner(vaultPda, { mint: WSOL_MINT_PK }); if (va.value.length > 0) vaultAta = va.value[0].pubkey; } catch(e) {}
      if (!vaultAta) vaultAta = await findATAWithProg(vaultPda, WSOL_MINT_PK, TOKEN_PROG_PK);
      const amountRaw = BigInt(Math.round(amount * 1e9));
      const buf = new ArrayBuffer(8); new DataView(buf).setBigUint64(0, amountRaw, true);
      const data = new Uint8Array(16); data.set(disc, 0); data.set(new Uint8Array(buf), 8);
      // Combine wSOL account creation + withdraw + unwrap into ONE tx (1 sign total)
      const wsolKp = Keypair.generate(); const wsolAcct = wsolKp.publicKey;
      const space = 165; const rent = await connection.getMinimumBalanceForRentExemption(space);
      const { blockhash } = await connection.getLatestBlockhash();
      const tx = new Transaction({ recentBlockhash: blockhash, feePayer: walletPk });
      // 1. Create wSOL account
      tx.add(SystemProgram.createAccount({ fromPubkey: walletPk, newAccountPubkey: wsolAcct, lamports: rent, space, programId: TOKEN_PROG_PK }));
      // 2. InitializeAccount3 (no rent-sysvar needed)
      const initData = new Uint8Array(33); initData[0] = 18; initData.set(walletPk.toBytes(), 1);
      tx.add(new TransactionInstruction({ programId: TOKEN_PROG_PK, keys: [{ pubkey: wsolAcct, isSigner: false, isWritable: true }, { pubkey: WSOL_MINT_PK, isSigner: false, isWritable: false }], data: initData }));
      // 3. Withdraw from vault
      tx.add(new TransactionInstruction({ programId, keys: [
        { pubkey: ghostPda,     isSigner: false, isWritable: false },
        { pubkey: vaultPda,     isSigner: false, isWritable: false },
        { pubkey: walletPk,     isSigner: true,  isWritable: true  },
        { pubkey: WSOL_MINT_PK, isSigner: false, isWritable: false },
        { pubkey: wsolAcct,     isSigner: false, isWritable: true  },
        { pubkey: vaultAta,     isSigner: false, isWritable: true  },
        { pubkey: TOKEN_PROG_PK,isSigner: false, isWritable: false },
      ], data }));
      // 4. Unwrap wSOL ‚Üí native SOL
      tx.add(buildUnwrapIx(walletPk, wsolAcct));
      showNotif('Sign to withdraw SOL...', '');
      const signed = await ghostState.provider.signTransaction(tx);
      signed.partialSign(wsolKp);
      let sig;
      try { sig = await connection.sendRawTransaction(signed.serialize(), { skipPreflight: false, preflightCommitment: 'confirmed' }); }
      catch(simErr) {
        let logs=[]; try { logs=await simErr.getLogs(connection); } catch(_){} if (!logs?.length) { try { const s=await connection.simulateTransaction(tx); logs=s.value.logs||[]; } catch(_){} }
        throw new Error('TX failed: ' + simErr.message + (logs.slice(-5).length?' | '+logs.slice(-5).join(' | '):''));
      }
      const conf = await connection.confirmTransaction(sig, 'confirmed');
      if (conf.value?.err) throw new Error('TX failed: ' + JSON.stringify(conf.value.err));
      const wt = ghostState.walletTokens.find(w => w.mint === 'native');
      if (wt) { wt.balance += amount; } else { ghostState.walletTokens.push({ symbol: 'SOL', mint: 'native', balance: amount, decimals: 9, logoUrl: null }); }
      const idx = ghostState.vaultTokens.indexOf(vt); if (idx !== -1) ghostState.vaultTokens.splice(idx, 1);
      addActivityRow('Vault Withdrawal ' + amount.toLocaleString() + ' SOL', sig.slice(0,4)+'...'+sig.slice(-4), 'withdraw');
      successCount++;
    } catch(err) { console.error('SOL withdraw error:', err); showNotif('‚ö†Ô∏è SOL withdraw failed: ' + (err.message || err), 'error'); }
  }

  if (successCount > 0) {
    const depositPool = ghostState.walletTokens.filter(tok => tok.balance > 0 && !isProtocolMint(tok.mint));
    buildPickerDropdown('deposit', depositPool); buildPickerDropdown('bene', [WHOLE_VAULT_TOKEN, ...vaultAssignableTokens()]); buildPickerDropdown('burn', vaultAssignableTokens());
    ghostState.selectedTokens.deposit = null;
    if (depositPool.length > 0) selectToken('deposit', depositPool[0].mint);
    renderVaultHoldings(); renderVaultOverview();
    showNotif('‚úÖ Withdrew ' + successCount + '/' + tokens.length + ' asset' + (successCount > 1 ? 's' : '') + ' from vault!', 'green');
    saveSession();
  }
}

// ‚îÄ‚îÄ‚îÄ Comma-formatted amount helpers ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function formatDepositInput(el) {
  let raw = el.value.replace(/[^0-9.]/g, '');
  const parts = raw.split('.');
  if (parts.length > 2) raw = parts[0] + '.' + parts.slice(1).join('');
  const [whole, dec] = raw.split('.');
  const intPart = parseInt(whole || '0', 10) || 0;
  const formatted = intPart.toLocaleString() + (dec !== undefined ? '.' + dec : '');
  el.value = raw ? formatted : '';
  document.getElementById('depositAmt').value = raw || '';
}

function formatWithdrawInput(el, maxVal) {
  let raw = el.value.replace(/[^0-9.]/g, '');
  const parts = raw.split('.');
  if (parts.length > 2) raw = parts[0] + '.' + parts.slice(1).join('');
  const [whole, dec] = raw.split('.');
  const intPart = parseInt(whole || '0', 10) || 0;
  el.value = raw ? intPart.toLocaleString() + (dec !== undefined ? '.' + dec : '') : '';
  el.dataset.raw = raw || '';
}

function fillMaxWithdraw(id, maxVal) {
  const el = document.getElementById(id);
  if (!el) return;
  el.dataset.raw = maxVal.toString();
  el.value = parseFloat(maxVal).toLocaleString(undefined, {maximumFractionDigits: 9});
}

function fillMaxDeposit() {
  const sel = ghostState.selectedTokens.deposit;
  if (!sel) return;
  // Always read balance from the live walletTokens array (not the stale selection copy)
  const live = ghostState.walletTokens.find(w => w.mint === sel.mint) || sel;
  const bal = live.balance || 0;
  document.getElementById('depositAmt').value = bal.toString();
  document.getElementById('depositAmtDisplay').value = bal.toLocaleString(undefined, {maximumFractionDigits: 9});
}

// ‚îÄ‚îÄ‚îÄ Vault Actions ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// ‚îÄ‚îÄ‚îÄ SOL/wSOL constants ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const WSOL_MINT_PK_STR = 'So11111111111111111111111111111111111111112';
const TOKEN_PROGRAM_STR    = 'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA';
const TOKEN_2022_STR       = 'TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb'; // real Token-2022

// No normalization needed ‚Äî TokenzQdBNbLqP5... IS the real Token-2022 program
function normalizeTokenProg(addr) { return addr; }
const ASSOC_TOKEN_PROG_STR = 'ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJe1bso';

// Resolve effective mint: native SOL ‚Üí wSOL mint string
function effectiveMint(mint) {
  return (mint === 'native' || mint === 'sol') ? WSOL_MINT_PK_STR : mint;
}

// Derive ATA ‚Äî synchronous using pre-fetched PDA
async function findATAWithProg(owner, mint, tokenProg) {
  const { PublicKey } = solanaWeb3;
  const ASSOC = new PublicKey('ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJe1bso');
  const [ata] = await PublicKey.findProgramAddress(
    [owner.toBytes(), tokenProg.toBytes(), mint.toBytes()], ASSOC
  );
  return ata;
}

async function findATA(ownerPk, mintPk) {
  const { PublicKey } = solanaWeb3;
  const TOKEN_PROG = new PublicKey(TOKEN_PROGRAM_STR);
  const ASSOC_PROG = new PublicKey(ASSOC_TOKEN_PROG_STR);
  const [ata] = await PublicKey.findProgramAddress(
    [ownerPk.toBytes(), TOKEN_PROG.toBytes(), mintPk.toBytes()],
    ASSOC_PROG
  );
  return ata;
}

// Build create-ATA instruction (with rent sysvar for compatibility)
// Manual token account creation ‚Äî bypasses ATA program entirely
// Generates a new keypair, creates + initializes the account, returns keypair
// Caller must call tx.partialSign(kp) before provider.signTransaction(tx)
async function buildManualTokenAccountIxs(walletPk, mintPk, ownerPk, tokenProgPk, connection) {
  const { Keypair, SystemProgram, TransactionInstruction } = solanaWeb3;
  const kp = Keypair.generate();
  // Token account space: 165 bytes (Token), 165 bytes (Token-2022 base without extensions)
  const space = 165;
  const lamports = await connection.getMinimumBalanceForRentExemption(space);

  const createIx = SystemProgram.createAccount({
    fromPubkey: walletPk,
    newAccountPubkey: kp.publicKey,
    lamports,
    space,
    programId: tokenProgPk, // token program owns the account
  });

  // InitializeAccount3: opcode 18, layout = [18u8, owner_pubkey(32)]
  const initData = new Uint8Array(33);
  initData[0] = 18;
  initData.set(ownerPk.toBytes(), 1);

  const initIx = new TransactionInstruction({
    programId: tokenProgPk,
    keys: [
      { pubkey: kp.publicKey, isSigner: false, isWritable: true },
      { pubkey: mintPk,       isSigner: false, isWritable: false },
    ],
    data: initData,
  });

  return { createIx, initIx, kp };
}

function buildCreateATAIx(payerPk, ataPk, ownerPk, mintPk, tokenProgId) {
  const { PublicKey, TransactionInstruction, SystemProgram } = solanaWeb3;
  const tokenProg = tokenProgId || new PublicKey(TOKEN_PROGRAM_STR);
  // Idempotent create [1]: 6 accounts only ‚Äî no rent sysvar
  return new TransactionInstruction({
    programId: new PublicKey(ASSOC_TOKEN_PROG_STR),
    keys: [
      { pubkey: payerPk,                 isSigner: true,  isWritable: true  },
      { pubkey: ataPk,                   isSigner: false, isWritable: true  },
      { pubkey: ownerPk,                 isSigner: false, isWritable: false },
      { pubkey: mintPk,                  isSigner: false, isWritable: false },
      { pubkey: SystemProgram.programId, isSigner: false, isWritable: false },
      { pubkey: tokenProg,               isSigner: false, isWritable: false },
    ],
    data: new Uint8Array(0) // standard create (empty buffer)
  });
}

// Build wSOL wrap instructions: Transfer native SOL ‚Üí wSOL ATA + SyncNative
// Returns { preIxs: [], wsolAta: PublicKey }
async function buildWrapIxs(walletPk, lamports) {
  const { PublicKey, SystemProgram, TransactionInstruction } = solanaWeb3;
  const mintPk = new PublicKey(WSOL_MINT_PK_STR);
  const wsolAta = await findATA(walletPk, mintPk);
  const preIxs = [
    // idempotent create ‚Äî safe to include even if ATA already exists
    buildCreateATAIx(walletPk, wsolAta, walletPk, mintPk),
    // fund it with native SOL
    SystemProgram.transfer({ fromPubkey: walletPk, toPubkey: wsolAta, lamports: Number(lamports) }),
    // SyncNative (opcode 17) ‚Äî tells token program to update balance from lamports
    new TransactionInstruction({
      programId: new PublicKey(TOKEN_PROGRAM_STR),
      keys: [{ pubkey: wsolAta, isSigner: false, isWritable: true }],
      data: new Uint8Array([17])
    }),
  ];
  return { preIxs, wsolAta };
}

// Build wSOL unwrap (CloseAccount) instruction: drains wSOL ATA ‚Üí native SOL back to wallet
// opcode 9 = CloseAccount in SPL Token program
function buildUnwrapIx(walletPk, wsolAta) {
  const { PublicKey, TransactionInstruction } = solanaWeb3;
  return new TransactionInstruction({
    programId: new PublicKey(TOKEN_PROGRAM_STR),
    keys: [
      { pubkey: wsolAta,   isSigner: false, isWritable: true  }, // account to close
      { pubkey: walletPk,  isSigner: false, isWritable: true  }, // destination (gets lamports)
      { pubkey: walletPk,  isSigner: true,  isWritable: false }, // authority
    ],
    data: new Uint8Array([9])
  });
}

// ‚îÄ‚îÄ‚îÄ Deposit ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
async function dbDeposit() {
  const sel = ghostState.selectedTokens.deposit;
  if (!sel) { showNotif('Select a token first', 'error'); return; }
  const t = ghostState.walletTokens.find(w => w.mint === sel.mint) || sel;
  ghostState.selectedTokens.deposit = t;
  const amount = parseFloat(document.getElementById('depositAmt').value);
  if (!amount || amount <= 0) { showNotif('Enter a valid amount', 'error'); return; }
  if (amount > t.balance) { showNotif('‚ö†Ô∏è Insufficient wallet balance', 'error'); return; }

  // Block GHOST deposits ‚Äî the contract routes all GHOST to stake_vault (not the user vault),
  // merging it with the staked amount and making it unwithdrawable via withdraw_from_vault.
  // GHOST staking happens only at ghost initialization, not via deposit.
  if (t.mint === GHOST_MINT) {
    showNotif('\u26A0\uFE0F $GHOST cannot be deposited into the vault ‚Äî it goes to the stake account and cannot be withdrawn separately. Use SOL or other SPL tokens.', 'error');
    return;
  }

  const isSOL   = (t.mint === 'native');
  // Display symbol ‚Äî always show "SOL" not "wSOL" to the user
  const displaySym  = isSOL ? 'SOL' : t.symbol;
  // Internal mint used for ATAs and contract calls
  const mintStr = effectiveMint(t.mint);

  // Helper: update UI state after successful deposit
  const _applyDeposit = () => {
    t.balance = Math.max(0, t.balance - amount);
    // For SOL: store as 'native' in vaultTokens so it merges correctly with chain-fetched SOL entry
    // On-chain the vault holds a wSOL ATA but we always display/track as 'native' internally
    const vaultMint = isSOL ? 'native' : mintStr;
    const vaultSym  = isSOL ? 'SOL' : displaySym;
    const vaultLogo = isSOL ? 'https://raw.githubusercontent.com/solana-labs/token-list/main/assets/mainnet/So11111111111111111111111111111111111111112/logo.png' : (t.logoUrl || null);
    const vaultName = isSOL ? 'Solana' : (t.name || null);
    const existing = ghostState.vaultTokens.find(v => v.mint === vaultMint || (isSOL && v.mint === 'So11111111111111111111111111111111111111112'));
    if (existing) {
      existing.balance += amount;
      existing.mint = vaultMint; // normalise wSOL ‚Üí native if needed
      existing.symbol = vaultSym;
      if (!existing.logoUrl) existing.logoUrl = vaultLogo;
      if (!existing.name) existing.name = vaultName;
      existing._pendingDeposit = Date.now(); // protect from premature removal
    } else {
      ghostState.vaultTokens.push({
        symbol: vaultSym, mint: vaultMint, balance: amount,
        decimals: t.decimals, logoUrl: vaultLogo, name: vaultName,
        _pendingDeposit: Date.now() // RPC may lag ‚Äî protect from premature removal for 8s
      });
    }
    buildPickerDropdown('bene', [WHOLE_VAULT_TOKEN, ...vaultAssignableTokens()]);
    buildPickerDropdown('burn', vaultAssignableTokens());
    document.getElementById('depositPickerBal').textContent =
      t.balance.toLocaleString(undefined, {maximumFractionDigits:6}) + ' available';
    document.getElementById('depositPickerLogo').innerHTML = tokenLogoEl(displaySym, 26, t.logoUrl||null);
    document.getElementById('depositBalance').value =
      t.balance.toLocaleString(undefined, {maximumFractionDigits:6}) + ' ' + displaySym;
    document.getElementById('depositAmt').value = '';
    document.getElementById('depositAmtDisplay').value = '';
    const depositPool = ghostState.walletTokens.filter(tok => tok.balance > 0 && !isProtocolMint(tok.mint));
    buildPickerDropdown('deposit', depositPool);
    if (!ghostState.selectedTokens.deposit || ghostState.selectedTokens.deposit.balance <= 0) {
      ghostState.selectedTokens.deposit = null;
      if (depositPool.length > 0) { selectToken('deposit', depositPool[0].mint); }
      else {
        const s=document.getElementById('depositPickerSymbol'),
              b=document.getElementById('depositPickerBal'),
              l=document.getElementById('depositPickerLogo');
        if(s)s.textContent='Select asset';if(b)b.textContent='';if(l)l.innerHTML='';
        document.getElementById('depositBalance').value='‚Äî';
      }
    }
    renderVaultHoldings(); renderVaultOverview(); renderBeneficiaries();
    saveSession(); pumpFunFetched.delete(mintStr); setTimeout(fetchPumpFunData, 400);
  };

  // Demo mode
  if (!ghostState.provider || ghostState.walletName?.includes('demo')) {
    _applyDeposit();
    addActivityRow('Vault Deposit ' + amount.toLocaleString() + ' ' + displaySym + ' [demo]', randomTx(), 'deposit');
    showNotif('‚úÖ Deposited ' + amount.toLocaleString(undefined,{maximumFractionDigits:4}) + ' ' + displaySym + ' to vault! [demo]', 'green');
    return;
  }

  // ‚îÄ‚îÄ On-chain ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  try {
    showNotif('Depositing ' + amount.toLocaleString(undefined,{maximumFractionDigits:4}) + ' ' + displaySym + ' to vault...', '');
    const { PublicKey, Transaction, TransactionInstruction } = solanaWeb3;
    const walletPk  = new PublicKey(ghostState.publicKey);
    const ghostPda  = new PublicKey(ghostState.ghostPda);
    const vaultPda  = new PublicKey(ghostState.vaultPda);
    const programId = new PublicKey(PROGRAM_ID);
    const TOKEN_PROG = new PublicKey(TOKEN_PROGRAM_STR);
    console.log('[Ghost] mintStr:', mintStr, 'isSOL:', isSOL);
    const mintPk     = isSOL ? null : new PublicKey(mintStr); // null for SOL, we use depositMintPk

    const connection = new solanaWeb3.Connection(RPC_URL, 'confirmed');
    const WSOL_MINT_PK = new PublicKey('So11111111111111111111111111111111111111112');

    // For SOL: work with wSOL mint + classic token program
    const depositMintPk   = isSOL ? WSOL_MINT_PK : mintPk;
    const depositMintStr  = isSOL ? 'So11111111111111111111111111111111111111112' : mintStr;
    let rawMintOwner = TOKEN_PROGRAM_STR;
    if (!isSOL && mintPk) {
      try {
        const mintAcct = await connection.getAccountInfo(mintPk);
        rawMintOwner = mintAcct?.owner?.toBase58() || TOKEN_PROGRAM_STR;
      } catch(e) { /* default to classic token */ }
    }
    // Normalize pump.fun non-standard Token-2022 ‚Üí standard for ATA creation
    const normalizedTokenProg = normalizeTokenProg(rawMintOwner);
    console.log('[Ghost] rawMintOwner:', rawMintOwner, 'normalized:', normalizedTokenProg);
    const tokenProgPk    = new PublicKey(normalizedTokenProg); // for ATA creation
    const rawTokenProgPk = new PublicKey(rawMintOwner || TOKEN_PROGRAM_STR); // for deposit instruction

    // Owner source token account
    const ownerAta = isSOL
      ? await findATA(walletPk, WSOL_MINT_PK)  // wSOL ATA (created + funded in wrap step)
      : rawMintOwner === TOKEN_PROGRAM_STR
        ? await findATA(walletPk, depositMintPk)  // classic Token ‚Äî use ATA derivation
        : (await connection.getTokenAccountsByOwner(walletPk, { mint: depositMintPk })).value[0]?.pubkey
          || await findATA(walletPk, depositMintPk); // Token-2022 ‚Äî look up real account

    // Vault destination token account
    const ghostMintStr = ghostState.ghost?.mint || GHOST_MINT;
    // For GHOST: use the stake_vault PDA (deterministic, program-owned)
    // For other tokens: look up existing token account on-chain first,
    //   fall back to ATA derivation if none found yet
    let vaultAta;
    if (depositMintStr === ghostMintStr) {
      const [pk] = await solanaWeb3.PublicKey.findProgramAddress(
        [new TextEncoder().encode('stake_vault'), walletPk.toBytes()],
        new PublicKey(PROGRAM_ID)
      );
      vaultAta = pk;
    } else {
      // Check for existing token accounts owned by vaultPda for this mint
      try {
        const existing = await connection.getTokenAccountsByOwner(vaultPda, { mint: depositMintPk });
        if (existing.value.length > 0) {
          vaultAta = existing.value[0].pubkey;
          console.log('[Ghost] Found existing vault token account:', vaultAta.toBase58());
        }
      } catch(_) {}
      if (!vaultAta) {
        vaultAta = await findATAWithProg(vaultPda, depositMintPk, tokenProgPk);
      }
    }

    console.log('[Ghost] deposit mint:', depositMintPk.toBase58(), 'tokenProg:', tokenProgPk.toBase58());
    console.log('[Ghost] ownerAta:', ownerAta.toBase58(), 'vaultAta:', vaultAta.toBase58());

    const { blockhash } = await connection.getLatestBlockhash();
    const tx = new Transaction({ recentBlockhash: blockhash, feePayer: walletPk });

    // Phase 1: Create vault token account if needed
    const vaultAtaInfo = await connection.getAccountInfo(vaultAta);
    console.log('[Ghost] vaultAta:', vaultAta.toBase58(), 'exists:', !!vaultAtaInfo);
    if (!vaultAtaInfo) {
      // Step 1a: Fund vault PDA so ATA program accepts it as a valid owner
      const vaultPdaInfo = await connection.getAccountInfo(vaultPda);
      console.log('[Ghost] vaultPda lamports:', vaultPdaInfo?.lamports ?? 0);
      if (!vaultPdaInfo || vaultPdaInfo.lamports === 0) {
        showNotif('Activating vault...', '');
        const minRent = await connection.getMinimumBalanceForRentExemption(0);
        const { blockhash: fundBh } = await connection.getLatestBlockhash();
        const fundTx = new Transaction({ recentBlockhash: fundBh, feePayer: walletPk });
        fundTx.add(solanaWeb3.SystemProgram.transfer({
          fromPubkey: walletPk, toPubkey: vaultPda, lamports: minRent
        }));
        const fundSigned = await ghostState.provider.signTransaction(fundTx);
        const fundSig = await connection.sendRawTransaction(fundSigned.serialize(), { skipPreflight: true });
        console.log('[Ghost] Vault PDA fund tx:', fundSig);
        const fundConf = await connection.confirmTransaction(fundSig, 'confirmed');
        if (fundConf.value?.err) throw new Error('Vault activation failed: ' + JSON.stringify(fundConf.value.err));
        console.log('[Ghost] Vault PDA funded');
      }

      // Step 1b: Create vault token account via raw createAccount + initializeAccount3
      // Bypasses ATA program which fails with ProgramAccountNotFound on some RPCs
      showNotif('Initializing vault token account...', '');
      console.log('[Ghost] Creating vault token account manually');
      const { blockhash: initBh } = await connection.getLatestBlockhash();
      const initTx = new Transaction({ recentBlockhash: initBh, feePayer: walletPk });
      const { createIx, initIx, kp: vaultTokenKp } = await buildManualTokenAccountIxs(
        walletPk, depositMintPk, vaultPda, rawTokenProgPk, connection
      );
      initTx.add(createIx, initIx);
      // Wallet signs first, then keypair signs ‚Äî Phantom may strip pre-existing partial sigs
      const initWalletSigned = await ghostState.provider.signTransaction(initTx);
      initWalletSigned.partialSign(vaultTokenKp); // add keypair sig AFTER wallet
      const initSig = await connection.sendRawTransaction(initWalletSigned.serialize(), { skipPreflight: true });
      console.log('[Ghost] Vault token account tx:', initSig, 'addr:', vaultTokenKp.publicKey.toBase58());
      const initConf = await connection.confirmTransaction(initSig, 'confirmed');
      if (initConf.value?.err) throw new Error('Vault init failed: ' + JSON.stringify(initConf.value.err));
      // Override vaultAta to use the newly created account
      vaultAta = vaultTokenKp.publicKey;
      console.log('[Ghost] Vault token account created:', vaultAta.toBase58());
      showNotif('Vault ready ‚Äî proceeding with deposit...', '');
      const { blockhash: newBh } = await connection.getLatestBlockhash();
      tx.recentBlockhash = newBh;
    }

    // Phase 2: For SOL ‚Äî wrap native SOL to wSOL in separate tx
    let effectiveOwnerAta = ownerAta;
    if (isSOL) {
      const lamports = Math.round(amount * 1e9);
      const { instructions: wrapIxs, wsolAta, kp: wsolKp } = await buildWrapSOLInstructions(walletPk, lamports, connection);
      showNotif('Wrapping SOL...', '');
      const { blockhash: wrapBh } = await connection.getLatestBlockhash();
      const wrapTx = new Transaction({ recentBlockhash: wrapBh, feePayer: walletPk });
      wrapIxs.forEach(ix => wrapTx.add(ix));
      console.log('[Ghost] SOL wrap account:', wsolAta.toBase58(), 'newKp:', !!wsolKp);
      const wrapWalletSigned = await ghostState.provider.signTransaction(wrapTx);
      if (wsolKp) wrapWalletSigned.partialSign(wsolKp);
      const wrapSig = await connection.sendRawTransaction(wrapWalletSigned.serialize(), { skipPreflight: true });
      const wrapConf = await connection.confirmTransaction(wrapSig, 'confirmed');
      if (wrapConf.value?.err) throw new Error('SOL wrap failed: ' + JSON.stringify(wrapConf.value.err));
      effectiveOwnerAta = wsolAta;
      showNotif('SOL wrapped ‚Äî depositing...', '');
      const { blockhash: depBh } = await connection.getLatestBlockhash();
      tx.recentBlockhash = depBh;
    }

    // Phase 3: Deposit
    const disc = [18, 62, 110, 8, 26, 106, 248, 151];
    const amountRaw = BigInt(Math.round(amount * Math.pow(10, isSOL ? 9 : t.decimals)));
    const buf = new ArrayBuffer(8);
    new DataView(buf).setBigUint64(0, amountRaw, true);
    const data = new Uint8Array(16);
    data.set(disc, 0); data.set(new Uint8Array(buf), 8);

    tx.add(new TransactionInstruction({ programId,
      keys: [
        { pubkey: ghostPda,          isSigner: false, isWritable: false },
        { pubkey: walletPk,          isSigner: true,  isWritable: true  },
        { pubkey: depositMintPk,     isSigner: false, isWritable: false },
        { pubkey: effectiveOwnerAta, isSigner: false, isWritable: true  },
        { pubkey: vaultAta,          isSigner: false, isWritable: true  },
        { pubkey: rawTokenProgPk,    isSigner: false, isWritable: false },
      ], data }));

    const signed = await ghostState.provider.signTransaction(tx);
    let sig;
    try {
      sig = await connection.sendRawTransaction(signed.serialize(), { 
        skipPreflight: false,
        preflightCommitment: 'confirmed'
      });
    } catch(simErr) {
      // Get detailed logs from the SendTransactionError
      let logs = [];
      try { logs = await simErr.getLogs(connection); } catch(_) {}
      if (!logs?.length) {
        // Fall back to manual simulation with unsigned tx
        try {
          const sim = await connection.simulateTransaction(tx);
          logs = sim.value.logs || [];
          console.error('[Ghost] Sim error:', sim.value.err);
        } catch(_) {}
      }
      console.error('[Ghost] TX logs:', logs);
      const lastLogs = logs.slice(-5).join(' | ');
      throw new Error('TX failed: ' + simErr.message + (lastLogs ? ' | ' + lastLogs : ''));
    }
    const conf   = await connection.confirmTransaction(sig, 'confirmed');
    if (conf.value?.err) throw new Error('TX failed: ' + JSON.stringify(conf.value.err));

    _applyDeposit();
    const shortSig = sig.slice(0,4)+'...'+sig.slice(-4);
    addActivityRow('Vault Deposit ' + amount.toLocaleString() + ' ' + displaySym, shortSig, 'deposit');
    showNotif('‚úÖ Deposited ' + amount.toLocaleString(undefined,{maximumFractionDigits:4}) + ' ' + displaySym + ' to vault!', 'green');
    // Hard chain re-fetch: rebuilds vaultTokens from RPC, refreshes bene picker + chart
    // Fire immediately ‚Äî tx is confirmed so RPC will reflect the new balance
    loadWalletTokens().catch(()=>{});
  } catch(err) {
    console.error('Deposit error:', err);
    showNotif('Deposit failed: ' + (err.message || err), 'error');
  }
}

// ‚îÄ‚îÄ‚îÄ Withdraw ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
async function dbWithdrawAsset(vaultIdx) {
  if (ghostState.ghost.status === 'awakened') { showNotif('‚ö†Ô∏è Withdrawals blocked while awakened', 'error'); return; }
  const vt = ghostState.vaultTokens[vaultIdx];
  if (!vt) return;
  const wdEl  = document.getElementById('wdAmt' + vaultIdx);
  const amount = parseFloat(wdEl?.dataset.raw || wdEl?.value || '0');
  if (!amount || amount <= 0) { showNotif('Enter an amount to withdraw', 'error'); return; }
  if (amount > vt.balance)   { showNotif('‚ö†Ô∏è Exceeds vault balance', 'error'); return; }

  // wSOL stored in vault always displayed as SOL to the user
  const isSOL     = (vt.mint === WSOL_MINT_PK_STR || vt.mint === 'native');
  const displaySym = isSOL ? 'SOL' : vt.symbol;
  const mintStr    = effectiveMint(vt.mint);

  const _applyWithdraw = () => {
    vt.balance -= amount;
    if (vt.balance <= 0.000000001) ghostState.vaultTokens.splice(vaultIdx, 1);
    // Return to wallet ‚Äî native SOL entry (mint:'native') for wSOL withdrawals
    const walletMint = isSOL ? 'native' : vt.mint;
    const wt = ghostState.walletTokens.find(w => w.mint === walletMint);
    if (wt) {
      wt.balance += amount;
      const sel = ghostState.selectedTokens.deposit;
      if (sel && sel.mint === walletMint) {
        document.getElementById('depositPickerBal').textContent =
          wt.balance.toLocaleString(undefined,{maximumFractionDigits:6}) + ' available';
        document.getElementById('depositBalance').value =
          wt.balance.toLocaleString(undefined,{maximumFractionDigits:6}) + ' ' + displaySym;
      }
    } else {
      ghostState.walletTokens.push({ symbol: displaySym, mint: walletMint, balance: amount, decimals: vt.decimals, logoUrl: vt.logoUrl||null });
    }
    buildPickerDropdown('deposit', ghostState.walletTokens.filter(tok => tok.balance > 0));
    buildPickerDropdown('bene', [WHOLE_VAULT_TOKEN, ...vaultAssignableTokens()]);
    buildPickerDropdown('burn', vaultAssignableTokens());
    renderVaultHoldings(); renderVaultOverview(); saveSession();
  };

  // Demo mode
  if (!ghostState.provider || ghostState.walletName?.includes('demo')) {
    _applyWithdraw();
    addActivityRow('Vault Withdrawal ' + amount.toLocaleString() + ' ' + displaySym + ' [demo]', randomTx(), 'withdraw');
    showNotif('‚úÖ Withdrew ' + amount.toLocaleString(undefined,{maximumFractionDigits:4}) + ' ' + displaySym + ' [demo]', 'green');
    return;
  }

  // ‚îÄ‚îÄ On-chain ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  try {
    showNotif('Withdrawing ' + amount.toLocaleString(undefined,{maximumFractionDigits:4}) + ' ' + displaySym + '...', '');
    const { PublicKey, Transaction, TransactionInstruction, Keypair, SystemProgram } = solanaWeb3;
    const walletPk  = new PublicKey(ghostState.publicKey);
    const ghostPda  = new PublicKey(ghostState.ghostPda);
    const vaultPda  = new PublicKey(ghostState.vaultPda);
    const programId = new PublicKey(PROGRAM_ID);
    const connection = new solanaWeb3.Connection(RPC_URL, 'confirmed');
    const WSOL_MINT_PK = new PublicKey(WSOL_MINT_PK_STR);
    const TOKEN_PROG_PK = new PublicKey(TOKEN_PROGRAM_STR);

    // Mirror deposit: resolve effective mint and detect token program
    const withdrawMintPk = isSOL ? WSOL_MINT_PK : new PublicKey(mintStr);
    let rawMintOwner = TOKEN_PROGRAM_STR;
    if (!isSOL) {
      try {
        const mintAcct = await connection.getAccountInfo(withdrawMintPk);
        rawMintOwner = mintAcct?.owner?.toBase58() || TOKEN_PROGRAM_STR;
      } catch(e) {}
    }
    const normalizedTokenProg = normalizeTokenProg(rawMintOwner);
    const rawTokenProgPk = new PublicKey(rawMintOwner || TOKEN_PROGRAM_STR);
    console.log('[Ghost] withdraw mint:', withdrawMintPk.toBase58(), 'tokenProg:', rawMintOwner);

    // Vault source ‚Äî look up real token account (raw keypair, not ATA)
    let vaultAta;
    try {
      const vaultAccts = await connection.getTokenAccountsByOwner(vaultPda, { mint: withdrawMintPk });
      if (vaultAccts.value.length > 0) {
        vaultAta = vaultAccts.value[0].pubkey;
        console.log('[Ghost] Found vault token account:', vaultAta.toBase58());
      }
    } catch(e) {}
    if (!vaultAta) {
      vaultAta = await findATAWithProg(vaultPda, withdrawMintPk, new PublicKey(normalizedTokenProg));
      console.log('[Ghost] Using derived vault ATA (fallback):', vaultAta.toBase58());
    }

    // withdraw_from_vault discriminator
    const disc = [180, 34, 37, 46, 156, 0, 211, 238];
    const amountRaw = BigInt(Math.round(amount * Math.pow(10, vt.decimals)));
    const buf = new ArrayBuffer(8); new DataView(buf).setBigUint64(0, amountRaw, true);
    const data = new Uint8Array(16); data.set(disc, 0); data.set(new Uint8Array(buf), 8);

    // ‚îÄ‚îÄ SOL: create fresh wSOL receive account via manual keypair (ATA program unreliable) ‚îÄ‚îÄ
    if (isSOL) {
      const wsolKp = Keypair.generate();
      const wsolAcct = wsolKp.publicKey;
      const space = 165;
      const rent = await connection.getMinimumBalanceForRentExemption(space);

      // Combine create + init + withdraw + unwrap into ONE tx (1 sign total)
      const { blockhash } = await connection.getLatestBlockhash();
      const tx = new Transaction({ recentBlockhash: blockhash, feePayer: walletPk });
      // 1. Create wSOL account
      tx.add(SystemProgram.createAccount({
        fromPubkey: walletPk, newAccountPubkey: wsolAcct,
        lamports: rent, space, programId: TOKEN_PROG_PK
      }));
      // 2. InitializeAccount3
      const initData = new Uint8Array(33);
      initData[0] = 18;
      initData.set(walletPk.toBytes(), 1);
      tx.add(new TransactionInstruction({
        programId: TOKEN_PROG_PK,
        keys: [{ pubkey: wsolAcct, isSigner: false, isWritable: true },
               { pubkey: WSOL_MINT_PK, isSigner: false, isWritable: false }],
        data: initData
      }));
      // 3. Withdraw from vault
      tx.add(new TransactionInstruction({ programId,
        keys: [
          { pubkey: ghostPda,    isSigner: false, isWritable: false },
          { pubkey: vaultPda,    isSigner: false, isWritable: false },
          { pubkey: walletPk,    isSigner: true,  isWritable: true  },
          { pubkey: WSOL_MINT_PK,isSigner: false, isWritable: false },
          { pubkey: wsolAcct,    isSigner: false, isWritable: true  },
          { pubkey: vaultAta,    isSigner: false, isWritable: true  },
          { pubkey: TOKEN_PROG_PK,isSigner: false, isWritable: false },
        ], data }));
      // 4. Unwrap ‚Üí native SOL
      tx.add(buildUnwrapIx(walletPk, wsolAcct));
      tx.instructions.forEach((ix, i) =>
        console.log(`[Ghost] ix${i}: prog=${ix.programId.toBase58()} accounts=${ix.keys.length} data=${ix.data.length}b`)
      );
      showNotif('Withdrawing SOL...', '');
      const signed = await ghostState.provider.signTransaction(tx);
      signed.partialSign(wsolKp); // keypair co-signs the createAccount ix
      let sig;
      try {
        sig = await connection.sendRawTransaction(signed.serialize(), { skipPreflight: false, preflightCommitment: 'confirmed' });
      } catch(simErr) {
        let logs = []; try { logs = await simErr.getLogs(connection); } catch(_) {}
        if (!logs?.length) { try { const sim = await connection.simulateTransaction(tx); logs = sim.value.logs||[]; } catch(_) {} }
        console.error('[Ghost] TX logs:', logs);
        throw new Error('TX failed: ' + simErr.message + (logs.slice(-5).length ? ' | ' + logs.slice(-5).join(' | ') : ''));
      }
      const conf = await connection.confirmTransaction(sig, 'confirmed');
      if (conf.value?.err) throw new Error('TX failed: ' + JSON.stringify(conf.value.err));
      _applyWithdraw();
      addActivityRow('Vault Withdrawal ' + amount.toLocaleString() + ' SOL', sig.slice(0,4)+'...'+sig.slice(-4), 'withdraw');
      showNotif('‚úÖ Withdrew ' + amount.toLocaleString(undefined,{maximumFractionDigits:4}) + ' SOL to wallet!', 'green');
      return;
    }

    // ‚îÄ‚îÄ SPL: check if owner ATA exists, create if needed ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    let ownerAta;
    if (rawMintOwner === TOKEN_PROGRAM_STR) {
      ownerAta = await findATA(walletPk, withdrawMintPk);
    } else {
      const existing = await connection.getTokenAccountsByOwner(walletPk, { mint: withdrawMintPk }).catch(() => ({ value: [] }));
      ownerAta = existing.value[0]?.pubkey || await findATA(walletPk, withdrawMintPk);
    }
    console.log('[Ghost] ownerAta:', ownerAta.toBase58(), 'vaultAta:', vaultAta.toBase58());

    const { blockhash } = await connection.getLatestBlockhash();
    const tx = new Transaction({ recentBlockhash: blockhash, feePayer: walletPk });

    // Create owner ATA if missing ‚Äî only needed for SPL (not SOL, handled above)
    const ownerAtaInfo = await connection.getAccountInfo(ownerAta);
    if (!ownerAtaInfo) {
      console.log('[Ghost] Owner ATA missing ‚Äî prepending createATA ix for', withdrawMintPk.toBase58());
      tx.add(createATAInstruction(walletPk, ownerAta, walletPk, withdrawMintPk, rawTokenProgPk));
    }

    tx.add(new TransactionInstruction({ programId,
      keys: [
        { pubkey: ghostPda,       isSigner: false, isWritable: false },
        { pubkey: vaultPda,       isSigner: false, isWritable: false },
        { pubkey: walletPk,       isSigner: true,  isWritable: true  },
        { pubkey: withdrawMintPk, isSigner: false, isWritable: false },
        { pubkey: ownerAta,       isSigner: false, isWritable: true  },
        { pubkey: vaultAta,       isSigner: false, isWritable: true  },
        { pubkey: rawTokenProgPk, isSigner: false, isWritable: false },
      ], data }));

    tx.instructions.forEach((ix, i) =>
      console.log(`[Ghost] ix${i}: prog=${ix.programId.toBase58()} accounts=${ix.keys.length} data=${ix.data.length}b`)
    );
    const signed = await ghostState.provider.signTransaction(tx);
    let sig;
    try {
      sig = await connection.sendRawTransaction(signed.serialize(), { skipPreflight: false, preflightCommitment: 'confirmed' });
    } catch(simErr) {
      let logs = []; try { logs = await simErr.getLogs(connection); } catch(_) {}
      if (!logs?.length) { try { const sim = await connection.simulateTransaction(tx); logs = sim.value.logs||[]; } catch(_) {} }
      console.error('[Ghost] TX logs:', logs);
      throw new Error('TX failed: ' + simErr.message + (logs.slice(-5).length ? ' | ' + logs.slice(-5).join(' | ') : ''));
    }
    const conf = await connection.confirmTransaction(sig, 'confirmed');
    if (conf.value?.err) throw new Error('TX failed: ' + JSON.stringify(conf.value.err));
    _applyWithdraw();
    addActivityRow('Vault Withdrawal ' + amount.toLocaleString() + ' ' + displaySym, sig.slice(0,4)+'...'+sig.slice(-4), 'withdraw');
    showNotif('‚úÖ Withdrew ' + amount.toLocaleString(undefined,{maximumFractionDigits:4}) + ' ' + displaySym + ' to wallet!', 'green');
  } catch(err) {
    console.error('Withdraw error:', err);
    showNotif('Withdraw failed: ' + (err.message || err), 'error');
  }
}


// ‚îÄ‚îÄ‚îÄ Settings ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function syncSettingsDisplay() {
  const g = ghostState.ghost;
  const iDays = Math.round(g.intervalSeconds / 86400);
  const gDays = Math.round(g.gracePeriodSeconds / 86400);
  const el = id => document.getElementById(id);
  if (el('settingsIntervalVal')) el('settingsIntervalVal').textContent = iDays;
  if (el('settingsIntervalSub')) el('settingsIntervalSub').textContent = 'days ¬∑ ~' + (iDays/30).toFixed(1) + ' months';
  if (el('settingsGraceVal')) el('settingsGraceVal').textContent = gDays;
  if (el('settingsGraceSub')) el('settingsGraceSub').textContent = 'days after silence detected';
  if (el('settingsStakedVal')) {
    const _ssAmt = g.stakedGhost || 10000;
    const _ssPrice = PRICE_CACHE[GHOST_MINT] || 0;
    const _ssUsd = _ssPrice > 0 ? '<span style="font-size:11px;color:#9090b8;margin-left:6px">\u2248 $' + (_ssAmt * _ssPrice).toLocaleString(undefined,{maximumFractionDigits:2}) + '</span>' : '';
    el('settingsStakedVal').innerHTML = _ssAmt.toLocaleString() + ' $GHOST' + _ssUsd;
  }
}

async function dbUpdateInterval() {
  const days = parseInt(document.getElementById('dbNewInterval').value);
  if (!days || days < 7) { showNotif('‚ö†Ô∏è Minimum 7 days required', 'error'); return; }
  const seconds = days * 86400;

  if (!ghostState.provider || ghostState.walletName?.includes('demo')) {
    ghostState.ghost.intervalSeconds = seconds;
    document.getElementById('dbInterval').textContent = days + ' days';
    document.getElementById('dbNewInterval').value = '';
    document.getElementById('dbIntervalPreview').textContent = days + ' days ‚âà ' + (days/30).toFixed(1) + ' months';
    syncSettingsDisplay(); updateCountdown();
    showNotif('‚úÖ Interval updated [demo]', 'green'); return;
  }
  try {
    showNotif('Updating interval...', '');
    const { PublicKey, Transaction, TransactionInstruction } = solanaWeb3;
    const walletPubkey = new PublicKey(ghostState.publicKey);
    const ghostPda = new PublicKey(ghostState.ghostPda);
    const programId = new PublicKey(PROGRAM_ID);
    // sha256("global:update_interval")[0:8]
    const disc = [0, 103, 203, 94, 136, 229, 87, 49];
    const buf = new ArrayBuffer(8);
    new DataView(buf).setBigInt64(0, BigInt(seconds), true);
    const data = new Uint8Array(8 + 8);
    data.set(disc, 0); data.set(new Uint8Array(buf), 8);
    const ix = new TransactionInstruction({ programId,
      keys: [{ pubkey: ghostPda, isSigner: false, isWritable: true }, { pubkey: walletPubkey, isSigner: true, isWritable: true }], data });
    const connection = new solanaWeb3.Connection(RPC_URL, 'confirmed');
    const { blockhash } = await connection.getLatestBlockhash();
    const tx = new Transaction({ recentBlockhash: blockhash, feePayer: walletPubkey });
    tx.add(ix);
    // Debug: log each instruction individually so console doesn't collapse
    tx.instructions.forEach((ix, i) => 
      console.log(`[Ghost] ix${i}: prog=${ix.programId.toBase58()} accounts=${ix.keys.length} data=${ix.data.length}b`)
    );
    const signed = await ghostState.provider.signTransaction(tx);
    const sig = await connection.sendRawTransaction(signed.serialize(), { skipPreflight: true, preflightCommitment: 'confirmed' });
    console.log('[Ghost] TX sent:', sig);
    const conf = await connection.confirmTransaction(sig, 'confirmed');
    console.log('[Ghost] TX confirmed:', conf);
    if (conf.value?.err) throw new Error('TX failed: ' + JSON.stringify(conf.value.err));
    ghostState.ghost.intervalSeconds = seconds;
    document.getElementById('dbInterval').textContent = days + ' days';
    document.getElementById('dbNewInterval').value = '';
    document.getElementById('dbIntervalPreview').textContent = days + ' days ‚âà ' + (days/30).toFixed(1) + ' months';
    syncSettingsDisplay(); updateCountdown();
    showNotif('‚úÖ Interval updated on-chain: ' + days + ' days', 'green');
  } catch(err) { showNotif('Failed: ' + (err.message || err), 'error'); }
}

async function dbUpdateGrace() {
  const days = parseInt(document.getElementById('dbNewGrace').value);
  if (!days || days < 1) { showNotif('‚ö†Ô∏è Minimum 1 day required', 'error'); return; }
  const seconds = days * 86400;

  if (!ghostState.provider || ghostState.walletName?.includes('demo')) {
    ghostState.ghost.gracePeriodSeconds = seconds;
    document.getElementById('dbGrace').textContent = days + ' days';
    document.getElementById('dbNewGrace').value = '';
    document.getElementById('dbGracePreview').textContent = days + ' days';
    syncSettingsDisplay();
    showNotif('‚úÖ Grace period updated [demo]', 'green'); return;
  }
  try {
    showNotif('Updating grace period...', '');
    const { PublicKey, Transaction, TransactionInstruction } = solanaWeb3;
    const walletPubkey = new PublicKey(ghostState.publicKey);
    const ghostPda = new PublicKey(ghostState.ghostPda);
    const programId = new PublicKey(PROGRAM_ID);
    // sha256("global:update_grace_period")[0:8]
    const disc = [7, 76, 130, 186, 86, 93, 66, 134];
    const buf = new ArrayBuffer(8);
    new DataView(buf).setBigInt64(0, BigInt(seconds), true);
    const data = new Uint8Array(8 + 8);
    data.set(disc, 0); data.set(new Uint8Array(buf), 8);
    const ix = new TransactionInstruction({ programId,
      keys: [{ pubkey: ghostPda, isSigner: false, isWritable: true }, { pubkey: walletPubkey, isSigner: true, isWritable: true }], data });
    const connection = new solanaWeb3.Connection(RPC_URL, 'confirmed');
    const { blockhash } = await connection.getLatestBlockhash();
    const tx = new Transaction({ recentBlockhash: blockhash, feePayer: walletPubkey });
    tx.add(ix);
    // Debug: log each instruction individually so console doesn't collapse
    tx.instructions.forEach((ix, i) => 
      console.log(`[Ghost] ix${i}: prog=${ix.programId.toBase58()} accounts=${ix.keys.length} data=${ix.data.length}b`)
    );
    const signed = await ghostState.provider.signTransaction(tx);
    const sig = await connection.sendRawTransaction(signed.serialize(), { skipPreflight: true, preflightCommitment: 'confirmed' });
    console.log('[Ghost] TX sent:', sig);
    const conf = await connection.confirmTransaction(sig, 'confirmed');
    console.log('[Ghost] TX confirmed:', conf);
    if (conf.value?.err) throw new Error('TX failed: ' + JSON.stringify(conf.value.err));
    ghostState.ghost.gracePeriodSeconds = seconds;
    document.getElementById('dbGrace').textContent = days + ' days';
    document.getElementById('dbNewGrace').value = '';
    document.getElementById('dbGracePreview').textContent = days + ' days';
    syncSettingsDisplay();
    showNotif('‚úÖ Grace period updated on-chain: ' + days + ' days', 'green');
  } catch(err) { showNotif('Failed: ' + (err.message || err), 'error'); }
}



async function dbAbandon() {
  // Step 1: Confirmation modal
  const confirmed = await new Promise(resolve => {
    const modal = document.createElement('div');
    modal.style.cssText = 'position:fixed;inset:0;z-index:100000;background:rgba(5,5,15,0.9);display:flex;align-items:center;justify-content:center;backdrop-filter:blur(6px)';
    modal.innerHTML = `
      <div style="background:#0e0b1a;border:1px solid rgba(255,61,90,0.4);border-radius:12px;padding:36px;max-width:420px;width:90%;text-align:center;box-shadow:0 0 60px rgba(255,61,90,0.15)">
        <div style="font-size:48px;margin-bottom:16px;filter:drop-shadow(0 0 12px rgba(255,80,40,0.6))">‚ö†Ô∏è</div>
        <div style="font-family:'Syne',sans-serif;font-weight:800;font-size:20px;color:#ff6080;margin-bottom:10px">Abandon Ghost?</div>
        <div style="font-family:'Share Tech Mono',monospace;font-size:13px;color:#b0a8d0;line-height:1.7;margin-bottom:24px">
          This permanently closes your vault and burns <span style="color:#ff6080;font-weight:700">50% of your staked $GHOST</span>.<br><br>
          Your beneficiaries will <strong>not</strong> receive anything. All assets held in your vault ‚Äî plus the remaining 50% $GHOST ‚Äî are returned directly to your wallet. <strong>This cannot be undone.</strong>
        </div>
        <div style="display:flex;gap:12px;justify-content:center">
          <button id="_abandonCancel" style="background:rgba(255,255,255,0.05);border:1px solid rgba(255,255,255,0.15);color:#b0a8d0;padding:10px 24px;border-radius:6px;cursor:pointer;font-family:'Share Tech Mono',monospace;font-size:13px">Cancel</button>
          <button id="_abandonConfirm" style="background:rgba(255,61,90,0.15);border:1px solid rgba(255,61,90,0.5);color:#ff6080;padding:10px 24px;border-radius:6px;cursor:pointer;font-family:'Syne',sans-serif;font-weight:700;font-size:14px">Yes, Abandon Forever</button>
        </div>
      </div>`;
    document.body.appendChild(modal);
    document.getElementById('_abandonCancel').onclick = () => { modal.remove(); resolve(false); };
    document.getElementById('_abandonConfirm').onclick = () => { modal.remove(); resolve(true); };
  });

  if (!confirmed) return;

  // Step 2: Ghost fly-up animation overlay
  const overlay = document.createElement('div');
  overlay.className = 'ghost-abandon-overlay';

  // Particle colors
  const particleColors = ['#a060ff','#ff60a0','#60a0ff','#ffffff','#ffcc00'];
  const particles = Array.from({length: 20}, (_, i) => {
    const angle = (i / 20) * Math.PI * 2;
    const dist = 80 + Math.random() * 100;
    const tx = Math.cos(angle) * dist + 'px';
    const ty = (Math.sin(angle) * dist - 60) + 'px';
    const color = particleColors[i % particleColors.length];
    return `<div class="particle" style="background:${color};top:50%;left:50%;margin:-4px;--tx:${tx};--ty:${ty};animation-delay:${0.7 + Math.random()*0.3}s;animation-duration:${0.8+Math.random()*0.4}s;box-shadow:0 0 6px ${color}"></div>`;
  }).join('');

  overlay.innerHTML = `
    <div style="position:relative;text-align:center">
      ${particles}
      <span class="ghost-fly-char">üëª</span>
      <div id="abandonMsg" style="font-family:'Syne',sans-serif;font-weight:800;font-size:18px;color:#a060ff;margin-top:20px;opacity:0;transition:opacity 0.6s">
        Ghost released‚Ä¶
      </div>
      <div style="font-family:'Share Tech Mono',monospace;font-size:12px;color:#6050a0;margin-top:8px;opacity:0;transition:opacity 0.6s" id="abandonSub">
        50% of staked $GHOST burned forever
      </div>
    </div>`;
  document.body.appendChild(overlay);

  // Fade in the text message after 1.2s
  setTimeout(() => {
    document.getElementById('abandonMsg').style.opacity = '1';
    document.getElementById('abandonSub').style.opacity = '1';
  }, 1200);

  // Step 3: After animation (2.8s), clean up and show aftermath
  await new Promise(r => setTimeout(r, 2800));
  overlay.remove();

  // Step 4: Reset state to show "no vault" / aftermath
  const stakedAmt = ghostState.ghost.stakedGhost || 0;
  const burnedAmt = Math.floor(stakedAmt * 0.5);
  const returnedAmt = stakedAmt - burnedAmt;

  ghostState.ghost = {
    status: 'abandoned',
    stakedGhost: 0,
    pingCount: 0,
    beneficiaries: [],
    wholeVaultShares: [],
  };
  ghostState.walletConnected = true;
  saveSession();

  // Lock nav items
  document.querySelectorAll('.db-nav-item').forEach(n => {
    if (!n.onclick?.toString().includes('watcher') && !n.onclick?.toString().includes('closeDashboard')) {
      n.classList.add('db-nav-locked');
    }
  });

  // Show aftermath screen on overview
  const overviewPage = document.getElementById('db-page-overview');
  document.querySelectorAll('.db-page').forEach(p => p.classList.remove('active'));
  document.querySelectorAll('.db-nav-item').forEach(n => n.classList.remove('active'));
  overviewPage.classList.add('active');
  document.getElementById('nav-overview')?.classList.remove('db-nav-locked');
  document.getElementById('nav-overview')?.classList.add('active');

  overviewPage.innerHTML = `
    <div class="db-page-title">Ghost Abandoned</div>
    <div class="db-page-sub">Your vault has been closed</div>
    <div style="animation:aftermath-fade-in 0.8s ease-out both">
      <div style="background:rgba(102,51,255,0.04);border:1px solid rgba(102,51,255,0.15);border-radius:10px;padding:32px;margin-bottom:20px;text-align:center">
        <div style="font-size:56px;margin-bottom:16px;opacity:0.4">üëª</div>
        <div style="font-family:'Syne',sans-serif;font-weight:800;font-size:22px;color:#a060ff;margin-bottom:8px">Your ghost is gone</div>
        <div style="font-family:'Share Tech Mono',monospace;font-size:13px;color:#7060a0;line-height:1.7">
          The vault has been closed on-chain.<br>No assets were distributed to beneficiaries.
        </div>
      </div>

      <div style="display:grid;grid-template-columns:1fr 1fr;gap:12px;margin-bottom:20px">
        <div style="background:rgba(255,61,90,0.06);border:1px solid rgba(255,61,90,0.2);border-radius:8px;padding:20px;text-align:center">
          <div style="font-family:'Share Tech Mono',monospace;font-size:11px;color:rgba(255,96,128,0.6);margin-bottom:6px;letter-spacing:0.1em">BURNED FOREVER</div>
          <div style="font-family:'Syne',sans-serif;font-weight:800;font-size:20px;color:#ff6080">${burnedAmt.toLocaleString()} $GHOST</div>
          <div style="font-family:'Share Tech Mono',monospace;font-size:11px;color:#ff6080;margin-top:4px;opacity:0.6">50% penalty</div>
        </div>
        <div style="background:rgba(102,51,255,0.06);border:1px solid rgba(102,51,255,0.2);border-radius:8px;padding:20px;text-align:center">
          <div style="font-family:'Share Tech Mono',monospace;font-size:11px;color:rgba(160,96,255,0.6);margin-bottom:6px;letter-spacing:0.1em">RETURNED TO WALLET</div>
          <div style="font-family:'Syne',sans-serif;font-weight:800;font-size:20px;color:#a060ff">${returnedAmt.toLocaleString()} $GHOST</div>
          <div style="font-family:'Share Tech Mono',monospace;font-size:11px;color:#a060ff;margin-top:4px;opacity:0.6">50% recovered</div>
        </div>
      </div>

      <div style="background:rgba(102,51,255,0.04);border:1px solid rgba(102,51,255,0.1);border-radius:8px;padding:20px;margin-bottom:20px">
        <div style="font-family:'Syne',sans-serif;font-weight:700;font-size:14px;color:#b0a8d0;margin-bottom:12px">What happened on-chain</div>
        <div style="font-family:'Share Tech Mono',monospace;font-size:12px;color:#6050a0;line-height:2">
          <span style="color:#a060ff">‚úì</span> Vault PDA closed ‚Äî rent lamports returned<br>
          <span style="color:#ff6080">‚úì</span> ${burnedAmt.toLocaleString()} $GHOST sent to burn address<br>
          <span style="color:#a060ff">‚úì</span> ${returnedAmt.toLocaleString()} $GHOST returned to your wallet<br>
          <span style="color:#a060ff">‚úì</span> All vault assets (SOL, SPL tokens) returned to your wallet<br>
          <span style="color:#6050a0">‚úó</span> No beneficiary transfers executed
        </div>
      </div>

      <div style="text-align:center">
        <button onclick="dbSummonNew()" style="background:rgba(102,51,255,0.15);border:1px solid rgba(102,51,255,0.4);color:#a060ff;padding:12px 32px;border-radius:8px;cursor:pointer;font-family:'Syne',sans-serif;font-weight:700;font-size:15px;transition:all 0.2s" onmouseover="this.style.background='rgba(102,51,255,0.25)'" onmouseout="this.style.background='rgba(102,51,255,0.15)'">
          üëª Summon a New Ghost
        </button>
      </div>
    </div>`;

  // Helper to restart  
  window.dbSummonNew = function() {
    ghostState.ghost = { status: 'none', stakedGhost: 0, pingCount: 0, beneficiaries: [], wholeVaultShares: [] };
    saveSession();
    location.reload();
  };
}
</script>

</div>

<!-- ‚îÄ‚îÄ‚îÄ GHOST CONFIRM MODAL (must be last in DOM to beat dashboard stacking context) ‚îÄ‚îÄ -->
<div id="ghostConfirmModal" onclick="if(event.target===this)_ghostConfirmReject()" style="display:none;position:fixed;inset:0;background:rgba(0,0,0,0.88);z-index:999999;justify-content:center;align-items:center;backdrop-filter:blur(5px)">
  <div style="background:#0d0d1a;border:1px solid rgba(102,51,255,0.45);max-width:400px;width:90%;padding:40px 36px;position:relative">
    <div id="ghostConfirmIcon" style="font-size:30px;margin-bottom:14px;text-align:center;line-height:1"></div>
    <h3 id="ghostConfirmTitle" style="margin-bottom:10px;font-size:20px;font-family:'Syne',sans-serif;color:#f0f0f8;font-weight:700"></h3>
    <p id="ghostConfirmMsg" style="margin-bottom:28px;font-size:13px;line-height:1.6;color:#c0bce0;font-family:'Share Tech Mono',monospace"></p>
    <div style="display:flex;gap:10px;justify-content:flex-end">
      <button onclick="_ghostConfirmReject()" style="font-family:'Share Tech Mono',monospace;font-size:11px;letter-spacing:0.1em;color:#c0bce0;background:none;border:1px solid rgba(192,188,224,0.2);padding:9px 20px;cursor:pointer;transition:all 0.2s" onmouseover="this.style.borderColor='rgba(192,188,224,0.45)'" onmouseout="this.style.borderColor='rgba(192,188,224,0.2)'">CANCEL</button>
      <button id="ghostConfirmOkBtn" onclick="_ghostConfirmAccept()" style="font-family:'Share Tech Mono',monospace;font-size:11px;letter-spacing:0.1em;padding:9px 22px;cursor:pointer;transition:all 0.2s">CONFIRM</button>
    </div>
  </div>
</div>
</body>
</html>